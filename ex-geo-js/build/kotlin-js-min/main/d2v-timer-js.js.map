{"version":3,"file":"d2v-timer-js.js","sources":["../../../../../d2v-timer-common/src/main/kotlin/io/data2viz/timer/Timer.kt","util/Standard.kt","../../../../../../../../../../dummy.kt","../../../../src/main/kotlin/io/data2viz/timer/TimerJS.kt"],"sourcesContent":["package io.data2viz.timer\n\n\n/**\n * used to make the timer sleep until next frame or event.\n */\ninternal expect fun setTimeout(handler: () -> Unit, timeout: Int):Any\n\n/**\n * clears previous timeout\n */\ninternal expect fun clearTimeout(handle:Any)\n\n/**\n * Used to launch the update skew task every second\n */\ninternal expect fun setInterval(handler: () -> Unit, interval: Int):Any\n\n/**\n * remove a potential update skew task\n */\ninternal expect fun clearInterval(handle:Any)\n\n/**\n * Used to call clearNow() and wake()\n */\ninternal expect fun callInNextFrame(block: () -> Unit)\n\n\n/**\n * Platform implementation of now in ms.\n */\ninternal expect fun delegateNow(): Double\n\n\ninternal var timeoutHandle:Any? = null\ninternal var pokeHandle:Any? = null\n\n/**\n * is animation frame pending\n * Todo use boolean?\n */\ninternal var frame = 0\n\n/**\n * how frequently we check for clock skew\n */\nprivate const val pokeDelay = 1000\n\nprivate var taskHead: Timer? = null\nprivate var taskTail: Timer? = null\nprivate var clockLast = 0.0\n\n\n/**\n * now set for all timers\n */\ninternal var clockNow = 0.0\n\n/**\n *\n */\ninternal var clockSkew = 0.0\n\n\n\n/**\n * Schedules a new timer, invoking the specified callback repeatedly until the\n * timer is stopped.\n *\n * An optional numeric delay in milliseconds may be specified\n * to invoke the given callback after a delay; if delay is not specified, it\n * defaults to zero.\n *\n * The delay is relative to the specified time in milliseconds;\n * if time is not specified, it defaults to now.\n *\n * The callback is passed the (apparent) elapsed time since the timer became active.\n *\n * (The exact values may vary depending on your JavaScript runtime and what else\n * your computer is doing.)\n *\n * Note that the first elapsed time is 3ms: this is the elapsed time since the\n * timer started, not since the timer was scheduled. Here the timer started 150ms\n * after it was scheduled due to the specified delay. The apparent elapsed time may\n * be less than the true elapsed time if the page is backgrounded and requestAnimationFrame\n * is paused; in the background, apparent time is frozen.If timer is called within the\n * callback of another timer, the new timer callback (if eligible as determined by the\n * specified delay and time) will be invoked immediately at the end of the current frame,\n * rather than waiting until the next frame. Within a frame, timer callbacks are guaranteed\n * to be invoked in the order they were scheduled, regardless of their start time.\n */\nfun timer(delay: Double = 0.0, startTime: Double = now(), callback: Timer.(Double) -> Unit): Timer {\n    return Timer().apply {\n        restart(delay, startTime, callback)\n    }\n}\n\n\n/**\n * Like timer, except the timer automatically stops on its first callback. A suitable\n * replacement for setTimeout that is guaranteed to not run in the background.\n * The callback is passed the elapsed time.\n */\nfun timeout(delay: Double = 0.0, startTime: Double = now(), callback: Timer.(Double) -> Unit): Timer {\n    return Timer().apply {\n        restart(delay, startTime) { time ->\n            stop()\n            callback(time)\n        }\n    }\n}\n\nfun interval(delay: Double = 0.0, startTime: Double = now(), callback: Timer.(Double) -> Unit): Timer {\n\n//\n//    export default function(callback, delay, time) {\n//        var t = new Timer, total = delay;\n//        if (delay == null) return t.restart(callback, delay, time), t;\n//        delay = +delay, time = time == null ? now() : +time;\n//        t.restart(function tick(elapsed) {\n//            elapsed += total;\n//            t.restart(tick, total += delay, time);\n//            callback(elapsed);\n//        }, delay, time);\n//        return t;\n//    }\n\n    fun tick(elapsed:Double){\n\n    }\n\n    var total = delay\n    val timer = Timer()\n    if (delay == 0.0){\n\n    }\n\n    return Timer().apply {\n        restart(delay, startTime) { time ->\n            stop()\n            callback(time)\n        }\n    }\n}\n\nclass Timer {\n\n\n    internal var _time: Double = 0.0\n\n    /**\n     * The lambda to be called.\n     * Set to null when stopped\n     * (todo: should be notnullable, use another param to indicate a stopped timer)\n     */\n    internal var _call: (Timer.(Double) -> Unit)? = null\n\n    /**\n     * the next timer created\n     */\n    internal var _next: Timer? = null\n\n    /**\n     * Restart a timer with the specified callback and optional delay and time.\n     * This is equivalent to stopping this timer and creating a new timer with\n     * the specified arguments, although this timer retains the original invocation priority.\n     *\n     * update taskTail and taskHead (the first timer is both tail and head)\n     *\n     * todo rename `restartWith`\n     */\n    fun restart(\n        delay: Double = .0,\n        startTime: Double = now(),\n        callback: Timer.(Double) -> Unit\n    ) {\n        val newTime = startTime + delay\n        if (_next == null && taskTail !== this) {\n            val tail = taskTail\n            if (tail != null) {\n                tail._next = this\n            } else\n                taskHead = this\n            taskTail = this\n        }\n        _call = callback\n        _time = newTime\n        sleep()\n    }\n\n    /**\n     * Stops this timer, preventing subsequent callbacks.\n     * This method has no effect if the timer has already stopped.\n     */\n    fun stop() {\n        if (_call != null) {\n            _call = null\n            _time = Double.POSITIVE_INFINITY\n            sleep()\n        }\n    }\n\n    override fun toString(): String {\n        return \"Timer(_time=$_time,) _next=$_next\"\n    }\n\n}\n\n/**\n * Returns the current time as defined by performance.now (elapsed time since document creation) if available,\n * and Date.now if not (elapsed time since 1970/01/01 00:00:00).\n *\n * The current time is updated at the start of a frame; it is thus\n * consistent during the frame, and any timers scheduled during the same frame will be\n * synchronized.\n *\n * If this method is called outside of a frame, such as in response to a user event, the current\n * time is calculated and then fixed until the next frame, again ensuring consistent timing during event handling.\n */\nfun now(): Double {\n    if (clockNow == 0.0) {\n        callInNextFrame(::clearNow)\n        clockNow = delegateNow() + clockSkew\n    }\n    return clockNow\n}\n\n\nprivate fun clearNow() {\n    clockNow = 0.0\n}\n\n/**\n * Immediately invoke any eligible timer callbacks. Note that zero-delay timers are normally\n * first executed after one frame (~17ms). This can cause a brief flicker because the browser\n * renders the page twice: once at the end of the first event loop, then again immediately on\n * the first timer callback. By flushing the timer queue at the end of the first event loop,\n * you can run any zero-delay timers immediately and avoid the flicker.\n */\nfun timerFlush() {\n    log(\"timerFlush\")\n    now()                       // Get the current time, if not already set.\n    ++frame                     // Pretend we\u2019ve set an alarm, if we haven\u2019t already.\n    var t = taskHead\n    var elapsed: Double\n    while (t != null) {\n        elapsed = clockNow - t._time\n        if (elapsed >= 0) {\n//            log(\"flushing ${t._time.toInt().toString().takeLast(6)}\")\n            t._call?.invoke(t, elapsed)\n        }\n        t = t._next\n    }\n    --frame\n}\n\n\n/**\n * Before sleeping, cleans timers, starting from head.\n * If taskHead is null, set taskTail to null.\n * @return the time of the sooner timer to execute\n */\nprivate fun updateTimers():Double {\n    var t0: Timer? = null\n    var t1 = taskHead\n    var t2: Timer?\n    var time = Double.POSITIVE_INFINITY\n    var timerCount = 0\n    while (t1 != null) {\n        timerCount++\n        if (t1._call != null) {\n            if (time > t1._time) {\n                time = t1._time\n            }\n            t0 = t1\n            t1 = t1._next\n        } else {\n            // if t1 as no call, remove t1\n            t2 = t1._next\n            t1._next = null\n            t1 = if (t0 != null) {\n                t0._next = t2\n                t2\n            } else {\n                taskHead = t2\n                taskHead\n            }\n        }\n    }\n    taskTail = t0\n    log(\"after updateTimers, timerCount $timerCount\")\n    return time\n}\n\n/**\n * Prepare sleep before wake.\n * If time is set and long (>  24 ms), use timeOut to wake up and remove the poke.\n * If time is not set or short (<= 24 ms), wake up at the next frame.\n */\nprivate fun sleep(time: Double? = null) {\n\n\n    if (frame > 0) return // Soonest alarm already set, or will be.\n    timeoutHandle?.let {\n        clearTimeout(it)\n        timeoutHandle = null\n    }\n\n    if (time != null) {\n        val delay = time - clockNow\n        if (delay > 24) {\n            if (time < Double.POSITIVE_INFINITY) {\n                timeoutHandle = setTimeout(::wake, delay.toInt())\n            }\n            pokeHandle?.let {\n                clearInterval(it)\n                pokeHandle = null\n            }\n            return\n        }\n    }\n    if (pokeHandle == null) {\n        clockLast = clockNow\n        pokeHandle = setInterval(::updateSkew, pokeDelay)\n    }\n    frame = 1\n    callInNextFrame (::wake)\n}\n\n\n/**\n * Every second update the skew\n */\nprivate fun updateSkew() {\n    log(\"updateSkew\")\n    val now = now()\n    val delay = now - clockLast\n    if (delay > pokeDelay) {\n        clockSkew -= delay\n        clockLast = now\n    }\n}\n\n\nprivate fun wake() {\n    log(\"wake\")\n    clockLast = now()\n    clockNow = clockLast + clockSkew\n    frame = 0\n    timeoutHandle = null\n    try {\n        timerFlush()\n    } finally {\n        frame = 0\n        val time = updateTimers()\n        sleep(time)\n        clockNow = 0.0\n    }\n}\n\nprivate fun log(msg:String) {\n//    println( (\"${now().toInt()} ${msg.padEnd(20)}handle:: $timeoutHandle timers::${logTimers()}\"))\n}\n\nprivate fun logTimers(): String {\n    val sb = StringBuilder(\"\")\n    var t = taskHead\n    var i = 0\n    while (t != null) {\n        sb.append(\" t$i[${t._time.toInt()}]\")\n        t = t._next\n        i++\n    }\n    return sb.toString()\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n",null,"package io.data2viz.timer\n\nimport kotlin.browser.window\nimport kotlin.js.Date\n\n\ninternal actual fun setTimeout(handler: () -> Unit, timeout: Int):Any =\n    window.setTimeout(handler, timeout)\n\ninternal actual fun clearTimeout(handle:Any) {\n    window.clearTimeout(handle as Int)\n}\n\ninternal actual fun setInterval(handler: () -> Unit, interval: Int):Any =\n    window.setInterval(handler, interval)\n\ninternal actual fun clearInterval(handle:Any) {\n    window.clearInterval(handle as Int)\n}\n\n/**\n * Todo use timeout if not available\n */\ninternal actual fun callInNextFrame(block: () -> Unit) {\n    window.requestAnimationFrame { block()}\n} \n\n/**\n * Use performance.now when available\n */\ninternal actual fun delegateNow(): Double = (if (performanceAvailable) js(\"performance.now()\") as Double else Date.now())\n\nval performanceAvailable:Boolean = js(\"((typeof performance === 'object') && performance.now) ? true : false \") as Boolean   \n"],"names":[],"mappings":"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"}