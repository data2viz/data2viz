{"version":3,"file":"d2v-color-js.js","sources":["../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/Color.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/ColorConversions.kt","generated/_ComparisonsJs.kt","kotlin/math.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/Colors.kt","util/Preconditions.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/EncodedColors.kt","util/Lazy.kt","generated/_Collections.kt","util/Standard.kt","kotlin/string.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/HclColor.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/HslColor.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/LabColor.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/LinearGradient.kt","collections/Collections.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/RadialGradient.kt","../../../../../d2v-color-common/src/main/kotlin/io/data2viz/color/RgbColor.kt","text/regex/RegexExtensions.kt","text/Strings.kt","../../../../src/main/kotlin/io/data2viz/color/color.kt"],"sourcesContent":["package io.data2viz.color\n\nimport io.data2viz.math.*\n\ndata class ColorStop(val percent:Percent, val color: Color)\n\ninterface ColorOrGradient\n\ninterface Gradient : ColorOrGradient {\n    val colorStops:List<ColorStop>\n}\n\ninterface Color : ColorOrGradient {\n    val rgb:Int\n\n    /**\n     * rgba string conforming to CSS specification `rgba(R, G, B, A)`\n     * R (red), G (green), and B (blue) can be either <integer>s or <percentage>s,\n     * where the number 255 corresponds to 100%.\n     * A (alpha) can be a <number> between 0 and 1, or a <percentage>,\n     * where the number 1 corresponds to 100% (full opacity).\n     */\n    val rgba:String\n\n    val r:Int\n    val g:Int\n    val b:Int\n    val alpha:Percent\n    val rgbHex:String\n\n    /**\n     * The relative brightness normalized to 0% for darkest black and 100% for lightest white.\n     * According to the WCAG definition: https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n     */\n    fun luminance():Percent\n\n    /**\n     * The contrast ratio between 2 colors.\n     * A minimum contrast of 4.5:1 is recommended to ensure that text is still readable against a background color.\n     * According to the WCAG definition: https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef\n     */\n    fun contrast(other:Color):Double\n\n    /**\n     * The value of the hue in the HCL colorspace (red = 40.deg, green = 136.deg, blue = 306.deg)\n     * HCL is designed to accord with human perception of color, so this colorspace provides better transition in term\n     * of \"hue perception\".\n     */\n    //val hue: Angle\n\n    fun toRgb():RgbColor\n    fun toLab():LabColor\n    fun toHcl():HclColor\n    fun toHsl():HslColor\n\n    fun brighten(strength: Double = 1.0):Color\n    fun darken(strength: Double = 1.0):Color\n    fun saturate(strength: Double = 1.0):Color\n    fun desaturate(strength: Double = 1.0):Color\n    fun withAlpha(alpha: Percent):Color\n\n    /**\n     * Change the perceived lightness of the color and return a new Color.\n     * TODO : when luminance() & contrast()  VS  darken() & brighten()   behavior will be simplified (seems to do the same thing now but produce different results)\n     */\n//    fun withLuminance(luminance: Percent):Color\n\n    /**\n     * Change the perceived hue of the color and return a new Color.\n     * Based on the value of the hue in the HCL colorspace (red = 40.deg, green = 136.deg, blue = 306.deg)\n     */\n    fun withHue(hue: Angle):Color\n}\n","package io.data2viz.color\n\nimport io.data2viz.math.*\nimport kotlin.math.*\n\n/**\n * Conversion references values\n */\ninternal const val Kn = 18f\ninternal const val Xn = 0.950470f                  // D65 standard referent\ninternal const val Yn = 1f\ninternal const val Zn = 1.088830f\ninternal const val t0 = 4f / 29f\ninternal const val t1 = 6f / 29f\ninternal const val t2 = 3f * t1 * t1\ninternal const val t3 = t1 * t1 * t1\n\ninternal const val deg60toRad = 1.047198\ninternal const val deg240toRad = 4.18879\n\ninternal val angle120deg = 120.deg\n\n\ninternal fun RgbColor.toLaba(): LabColor {\n    val labB = rgb2xyz(r)\n    val labA = rgb2xyz(g)\n    val labL = rgb2xyz(b)\n    val x = xyz2lab((0.4124564f * labB + 0.3575761f * labA + 0.1804375f * labL) / Xn)\n    val y = xyz2lab((0.2126729f * labB + 0.7151522f * labA + 0.0721750f * labL) / Yn)\n    val z = xyz2lab((0.0193339f * labB + 0.1191920f * labA + 0.9503041f * labL) / Zn)\n    return Colors.lab((116.0 * y - 16).pct, 500.0 * (x - y), 200.0 * (y - z), alpha)\n}\n\ninternal fun RgbColor.toHsla(): HslColor {\n    val rPercent = r / 255.0\n    val gPercent = g / 255.0\n    val bPercent = b / 255.0\n    val minPercent = minOf(rPercent, gPercent, bPercent)\n    val maxPercent = maxOf(rPercent, gPercent, bPercent)\n\n    var h = .0\n    var s = maxPercent - minPercent\n    val l = (maxPercent + minPercent) / 2f\n\n    if (s != .0) {\n        h = when {\n            (rPercent == maxPercent) -> if (gPercent < bPercent) ((gPercent - bPercent) / s) + 6f else ((gPercent - bPercent) / s)\n            (gPercent == maxPercent) -> (bPercent - rPercent) / s + 2f\n            else -> (rPercent - gPercent) / s + 4f\n        }\n        s /= if (l < 0.5f) maxPercent + minPercent else 2 - maxPercent - minPercent\n        h *= 60.0\n    } else {\n        s = if (l > 0 && l < 1) .0 else h\n    }\n    return Colors.hsl(h.deg, Percent(s), Percent(l), alpha)\n}\n\ninternal fun LabColor.toRgba(): RgbColor {\n    // map CIE LAB to CIE XYZ\n    var y = ((labL.value * 100.0) + 16) / 116f\n    var x = y + (labA / 500f)\n    var z = y - (labB / 200f)\n    y = Yn * lab2xyz(y)\n    x = Xn * lab2xyz(x)\n    z = Zn * lab2xyz(z)\n\n    // map CIE XYZ to RGB\n    return Colors.rgb(\n        xyz2rgb(3.2404542f * x - 1.5371385f * y - 0.4985314f * z),\n        xyz2rgb(-0.9692660f * x + 1.8760108f * y + 0.0415560f * z),\n        xyz2rgb(0.0556434f * x - 0.2040259f * y + 1.0572252f * z),\n        alpha\n    )\n}\n\n// TODO : use rad (faster)\ninternal fun HslColor.toRgba(): RgbColor =\n    if (isAchromatic())     // achromatic\n        Colors.rgb(\n            (l.value * 255).roundToInt(),\n            (l.value * 255).roundToInt(),\n            (l.value * 255).roundToInt(),\n            alpha\n        )\n    else {\n        val q = if (l < 50.pct) l * (100.pct + s) else l + s - l * s\n        val p = Percent(2 * l.value - q.value)\n        Colors.rgb(\n            (hue2rgb(p.value, q.value, h + angle120deg) * 255).roundToInt(),\n            (hue2rgb(p.value, q.value, h) * 255).roundToInt(),\n            (hue2rgb(p.value, q.value, h - angle120deg) * 255).roundToInt(),\n            alpha\n        )\n    }\n\ninternal fun HclColor.toLaba() = Colors.lab(l, (h.cos * c), (h.sin * c), alpha)\n\ninternal fun LabColor.toHcla(): HclColor {\n    val hue = Angle(atan2(labB, labA)).normalize()\n    val c = sqrt(labA * labA + labB * labB)\n    return Colors.hcl(hue, c, labL, alpha)\n}\n\n// TODO use rad (faster)\nprivate fun hue2rgb(p: Double, q: Double, hue: Angle): Double {\n    val hd = hue.normalize()\n    return when {\n        hd.rad < deg60toRad -> (p + (q - p) * (hd.rad / deg60toRad))\n        hd.rad < kotlin.math.PI -> q\n        hd.rad < deg240toRad -> (p + (q - p) * ((deg240toRad - hd.rad) / deg60toRad))\n        else -> p\n    }\n}\n\ninternal fun RgbColor.toLuminance(): Percent {\n\n    fun Int.chan2Lumi(): Double {\n        val x = this / 255.0\n        return if (x <= 0.03928) x / 12.92\n        else ((x+0.055)/1.055).pow(2.4)\n    }\n\n    return Percent(0.2126 * r.chan2Lumi() + 0.7152 * g.chan2Lumi() + 0.0722 * b.chan2Lumi()).coerceToDefault()\n}\n\n\nprivate fun xyz2lab(value: Float): Float =\n    if (value > t3)\n        value.pow(1 / 3f)\n    else\n        (value / t2 + t0)\n\nprivate fun rgb2xyz(value: Int): Float {\n    val percent = value.toFloat() / 255f\n    return if (percent <= 0.04045f) (percent / 12.92f) else ((percent + 0.055f) / 1.055f).pow(2.4f)\n}\n\nprivate fun lab2xyz(value: Double): Double =\n    if (value > t1)\n        (value * value * value)\n    else\n        (t2 * (value - t0))\n\nprivate fun xyz2rgb(value: Double): Int =\n    if (value <= 0.0031308f)\n        round(12.92f * value * 255).toInt()\n    else\n        round(255 * (1.055 * value.pow(1 / 2.4) - 0.055)).toInt()\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n\n\n\n// ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n","@file:Suppress(\"unused\", \"DEPRECATION\")\n\npackage io.data2viz.color\n\nimport io.data2viz.geom.Point\nimport io.data2viz.math.Angle\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\n\n\n// TODO : move to common and remove expect when available\ninternal expect fun Int.toString(radix: Int): String\n\n\nobject Colors {\n\n    /***************************** COLORSPACE CONSTRUCTORS *******************************************/\n\n    /**\n     * Instantiate a color using its rgb Int value and alpha. Should be used with hexadecimal literal.\n     * @sample: `Colors.rgb(0x0b0b0b, .5)`\n     */\n    fun rgb(rgb:Int, alpha: Percent = 100.pct): RgbColor = RgbColor(rgb, alpha)\n\n    /**\n     * Instantiate a color using its r,g,b Int values and alpha\n     * @sample: `Colors.rgb(128, 128, 128, .5)`\n     */\n    fun rgb(red: Int, green: Int, blue: Int, alpha: Percent = 100.pct): RgbColor {\n        val rgb = (red.coerceIn(0, 255) shl 16) + (green.coerceIn(0, 255) shl 8) + blue.coerceIn(0, 255)\n        return rgb(rgb, alpha)\n    }\n\n    fun lab(lightness: Percent, aComponent: Double, bComponent: Double, alpha: Percent = 100.pct) =\n            LabColor(lightness, aComponent, bComponent, alpha)\n\n    fun lab(lightness: Percent, aComponent: Int, bComponent: Int, alpha: Percent = 100.pct) =\n            LabColor(lightness, aComponent.toDouble(), bComponent.toDouble(), alpha)\n\n    fun hsl(hue: Angle, saturation: Percent, lightness: Percent, alpha: Percent = 100.pct) =\n            HslColor(hue, saturation, lightness, alpha)\n\n    fun hcl(hue: Angle, chroma: Double, luminance: Percent, alpha: Percent = 100.pct) =\n            HclColor(hue, chroma, luminance, alpha)\n\n    fun hcl(hue: Angle, chroma: Int, luminance: Percent, alpha: Percent = 100.pct) =\n            HclColor(hue, chroma.toDouble(), luminance, alpha)\n\n    fun lch(luminance: Percent, chroma: Double, hue: Angle, alpha: Percent = 100.pct) =\n            hcl(hue, chroma, luminance, alpha)\n\n    fun lch(luminance: Percent, chroma: Int, hue: Angle, alpha: Percent = 100.pct) = hcl(hue, chroma, luminance, alpha)\n\n\n    /***************************** GRADIENTS *********************************************************/\n\n    object Gradient {\n        fun linear(from:Point, to:Point) = LinearGradientFirstColorBuilder(from, to)\n        fun radial(center:Point, radius:Double) = RadialGradientFirstColorBuilder(center, radius)\n    }\n\n\n    /***************************** NAMED WEB COLORS ******************************************************/\n\n    object Web {\n        val aliceblue               = 0xf0f8ff.col\n        val antiquewhite            = 0xfaebd7.col\n        val aqua                    = 0x00ffff.col\n        val aquamarine              = 0x7fffd4.col\n        val azure                   = 0xf0ffff.col\n        val beige                   = 0xf5f5dc.col\n        val bisque                  = 0xffe4c4.col\n        val black                   = 0x000000.col\n        val blanchedalmond          = 0xffebcd.col\n        val blue                    = 0x0000ff.col\n        val blueviolet              = 0x8a2be2.col\n        val brown                   = 0xa52a2a.col\n        val burlywood               = 0xdeb887.col\n        val cadetblue               = 0x5f9ea0.col\n        val chartreuse              = 0x7fff00.col\n        val chocolate               = 0xd2691e.col\n        val coral                   = 0xff7f50.col\n        val cornflowerblue          = 0x6495ed.col\n        val cornsilk                = 0xfff8dc.col\n        val crimson                 = 0xdc143c.col\n        val cyan                    = 0x00ffff.col\n        val darkblue                = 0x00008b.col\n        val darkcyan                = 0x008b8b.col\n        val darkgoldenrod           = 0xb8860b.col\n        val darkgray                = 0xa9a9a9.col\n        val darkgreen               = 0x006400.col\n        val darkgrey                = 0xa9a9a9.col\n        val darkkhaki               = 0xbdb76b.col\n        val darkmagenta             = 0x8b008b.col\n        val darkolivegreen          = 0x556b2f.col\n        val darkorange              = 0xff8c00.col\n        val darkorchid              = 0x9932cc.col\n        val darkred                 = 0x8b0000.col\n        val darksalmon              = 0xe9967a.col\n        val darkseagreen            = 0x8fbc8f.col\n        val darkslateblue           = 0x483d8b.col\n        val darkslategray           = 0x2f4f4f.col\n        val darkslategrey           = 0x2f4f4f.col\n        val darkturquoise           = 0x00ced1.col\n        val darkviolet              = 0x9400d3.col\n        val deeppink                = 0xff1493.col\n        val deepskyblue             = 0x00bfff.col\n        val dimgray                 = 0x696969.col\n        val dimgrey                 = 0x696969.col\n        val dodgerblue              = 0x1e90ff.col\n        val firebrick               = 0xb22222.col\n        val floralwhite             = 0xfffaf0.col\n        val forestgreen             = 0x228b22.col\n        val fuchsia                 = 0xff00ff.col\n        val gainsboro               = 0xdcdcdc.col\n        val ghostwhite              = 0xf8f8ff.col\n        val gold                    = 0xffd700.col\n        val goldenrod               = 0xdaa520.col\n        val gray                    = 0x808080.col\n        val green                   = 0x008000.col\n        val greenyellow             = 0xadff2f.col\n        val grey                    = 0x808080.col\n        val honeydew                = 0xf0fff0.col\n        val hotpink                 = 0xff69b4.col\n        val indianred               = 0xcd5c5c.col\n        val indigo                  = 0x4b0082.col\n        val ivory                   = 0xfffff0.col\n        val khaki                   = 0xf0e68c.col\n        val lavender                = 0xe6e6fa.col\n        val lavenderblush           = 0xfff0f5.col\n        val lawngreen               = 0x7cfc00.col\n        val lemonchiffon            = 0xfffacd.col\n        val lightblue               = 0xadd8e6.col\n        val lightcoral              = 0xf08080.col\n        val lightcyan               = 0xe0ffff.col\n        val lightgoldenrodyellow    = 0xfafad2.col\n        val lightgray               = 0xd3d3d3.col\n        val lightgreen              = 0x90ee90.col\n        val lightgrey               = 0xd3d3d3.col\n        val lightpink               = 0xffb6c1.col\n        val lightsalmon             = 0xffa07a.col\n        val lightseagreen           = 0x20b2aa.col\n        val lightskyblue            = 0x87cefa.col\n        val lightslategray          = 0x778899.col\n        val lightslategrey          = 0x778899.col\n        val lightsteelblue          = 0xb0c4de.col\n        val lightyellow             = 0xffffe0.col\n        val lime                    = 0x00ff00.col\n        val limegreen               = 0x32cd32.col\n        val linen                   = 0xfaf0e6.col\n        val magenta                 = 0xff00ff.col\n        val maroon                  = 0x800000.col\n        val mediumaquamarine        = 0x66cdaa.col\n        val mediumblue              = 0x0000cd.col\n        val mediumorchid            = 0xba55d3.col\n        val mediumpurple            = 0x9370db.col\n        val mediumseagreen          = 0x3cb371.col\n        val mediumslateblue         = 0x7b68ee.col\n        val mediumspringgreen       = 0x00fa9a.col\n        val mediumturquoise         = 0x48d1cc.col\n        val mediumvioletred         = 0xc71585.col\n        val midnightblue            = 0x191970.col\n        val mintcream               = 0xf5fffa.col\n        val mistyrose               = 0xffe4e1.col\n        val moccasin                = 0xffe4b5.col\n        val navajowhite             = 0xffdead.col\n        val navy                    = 0x000080.col\n        val oldlace                 = 0xfdf5e6.col\n        val olive                   = 0x808000.col\n        val olivedrab               = 0x6b8e23.col\n        val orange                  = 0xffa500.col\n        val orangered               = 0xff4500.col\n        val orchid                  = 0xda70d6.col\n        val palegoldenrod           = 0xeee8aa.col\n        val palegreen               = 0x98fb98.col\n        val paleturquoise           = 0xafeeee.col\n        val palevioletred           = 0xdb7093.col\n        val papayawhip              = 0xffefd5.col\n        val peachpuff               = 0xffdab9.col\n        val peru                    = 0xcd853f.col\n        val pink                    = 0xffc0cb.col\n        val plum                    = 0xdda0dd.col\n        val powderblue              = 0xb0e0e6.col\n        val purple                  = 0x800080.col\n        val rebeccapurple           = 0x663399.col\n        val red                     = 0xff0000.col\n        val rosybrown               = 0xbc8f8f.col\n        val royalblue               = 0x4169e1.col\n        val saddlebrown             = 0x8b4513.col\n        val salmon                  = 0xfa8072.col\n        val sandybrown              = 0xf4a460.col\n        val seagreen                = 0x2e8b57.col\n        val seashell                = 0xfff5ee.col\n        val sienna                  = 0xa0522d.col\n        val silver                  = 0xc0c0c0.col\n        val skyblue                 = 0x87ceeb.col\n        val slateblue               = 0x6a5acd.col\n        val slategray               = 0x708090.col\n        val slategrey               = 0x708090.col\n        val snow                    = 0xfffafa.col\n        val springgreen             = 0x00ff7f.col\n        val steelblue               = 0x4682b4.col\n        val tan                     = 0xd2b48c.col\n        val teal                    = 0x008080.col\n        val thistle                 = 0xd8bfd8.col\n        val tomato                  = 0xff6347.col\n        val turquoise               = 0x40e0d0.col\n        val violet                  = 0xee82ee.col\n        val wheat                   = 0xf5deb3.col\n        val white                   = 0xffffff.col\n        val whitesmoke              = 0xf5f5f5.col\n        val yellow                  = 0xffff00.col\n        val yellowgreen             = 0x9acd32.col\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package io.data2viz.color\n\n\nimport kotlin.math.floor\n\n\n/**\n * Predefined colors defined as concatenated hex strings.\n */\nclass EncodedColors(colorsAsString: String) {\n    companion object {\n\n        // CATEGORICAL\n        val category10 by lazy { EncodedColors(\"1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf\") }\n        val category20 by lazy { EncodedColors(\"1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5\") }\n        val category20b by lazy { EncodedColors(\"393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6\") }\n        val category20c by lazy { EncodedColors(\"3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9\") }\n        val accents by lazy { EncodedColors(\"7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666\") }\n        val dark2 by lazy { EncodedColors(\"1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666\") }\n        val paired by lazy { EncodedColors(\"a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928\") }\n        val pastel1 by lazy { EncodedColors(\"fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2\") }\n        val pastel2 by lazy { EncodedColors(\"b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc\") }\n        val set1 by lazy { EncodedColors(\"e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999\") }\n        val set2 by lazy { EncodedColors(\"66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3\") }\n        val set3 by lazy { EncodedColors(\"8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f\") }\n\n        // DIVERGING\n        private val BrBG3   by lazy { EncodedColors(\"d8b365f5f5f55ab4ac\"                                                    ) }\n        private val BrBG4   by lazy { EncodedColors(\"a6611adfc27d80cdc1018571\"                                              ) }\n        private val BrBG5   by lazy { EncodedColors(\"a6611adfc27df5f5f580cdc1018571\"                                        ) }\n        private val BrBG6   by lazy { EncodedColors(\"8c510ad8b365f6e8c3c7eae55ab4ac01665e\"                                  ) }\n        private val BrBG7   by lazy { EncodedColors(\"8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e\"                            ) }\n        private val BrBG8   by lazy { EncodedColors(\"8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e\"                      ) }\n        private val BrBG9   by lazy { EncodedColors(\"8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e\"                ) }\n        private val BrBG10  by lazy { EncodedColors(\"5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30\"          ) }\n        private val BrBG11  by lazy { EncodedColors(\"5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30\"    ) }\n        val BrBG       by lazy { listOf(BrBG3, BrBG4, BrBG5, BrBG6, BrBG7, BrBG8, BrBG9, BrBG10, BrBG11) }\n\n        private val PiYG3   by lazy { EncodedColors(\"e9a3c9f7f7f7a1d76a\"                                                    ) }\n        private val PiYG4   by lazy { EncodedColors(\"d01c8bf1b6dab8e1864dac26\"                                              ) }\n        private val PiYG5   by lazy { EncodedColors(\"d01c8bf1b6daf7f7f7b8e1864dac26\"                                        ) }\n        private val PiYG6   by lazy { EncodedColors(\"c51b7de9a3c9fde0efe6f5d0a1d76a4d9221\"                                  ) }\n        private val PiYG7   by lazy { EncodedColors(\"c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221\"                            ) }\n        private val PiYG8   by lazy { EncodedColors(\"c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221\"                      ) }\n        private val PiYG9   by lazy { EncodedColors(\"c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221\"                ) }\n        private val PiYG10  by lazy { EncodedColors(\"8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419\"          ) }\n        private val PiYG11  by lazy { EncodedColors(\"8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419\"    ) }\n        val PiYG       by lazy { listOf(PiYG3, PiYG4, PiYG5, PiYG6, PiYG7, PiYG8, PiYG9, PiYG10, PiYG11) }\n\n        private val PRGn3   by lazy { EncodedColors(\"af8dc3f7f7f77fbf7b\"                                                    ) }\n        private val PRGn4   by lazy { EncodedColors(\"7b3294c2a5cfa6dba0008837\"                                              ) }\n        private val PRGn5   by lazy { EncodedColors(\"7b3294c2a5cff7f7f7a6dba0008837\"                                        ) }\n        private val PRGn6   by lazy { EncodedColors(\"762a83af8dc3e7d4e8d9f0d37fbf7b1b7837\"                                  ) }\n        private val PRGn7   by lazy { EncodedColors(\"762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837\"                            ) }\n        private val PRGn8   by lazy { EncodedColors(\"762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837\"                      ) }\n        private val PRGn9   by lazy { EncodedColors(\"762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837\"                ) }\n        private val PRGn10  by lazy { EncodedColors(\"40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b\"          ) }\n        private val PRGn11  by lazy { EncodedColors(\"40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b\"    ) }\n        val PRGn       by lazy { listOf(PRGn3, PRGn4, PRGn5, PRGn6, PRGn7, PRGn8, PRGn9, PRGn10, PRGn11) }\n\n        private val PuOR3   by lazy { EncodedColors(\"998ec3f7f7f7f1a340\"                                                    ) }\n        private val PuOR4   by lazy { EncodedColors(\"5e3c99b2abd2fdb863e66101\"                                              ) }\n        private val PuOR5   by lazy { EncodedColors(\"5e3c99b2abd2f7f7f7fdb863e66101\"                                        ) }\n        private val PuOR6   by lazy { EncodedColors(\"542788998ec3d8daebfee0b6f1a340b35806\"                                  ) }\n        private val PuOR7   by lazy { EncodedColors(\"542788998ec3d8daebf7f7f7fee0b6f1a340b35806\"                            ) }\n        private val PuOR8   by lazy { EncodedColors(\"5427888073acb2abd2d8daebfee0b6fdb863e08214b35806\"                      ) }\n        private val PuOR9   by lazy { EncodedColors(\"5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806\"                ) }\n        private val PuOR10  by lazy { EncodedColors(\"2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08\"          ) }\n        private val PuOR11  by lazy { EncodedColors(\"2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08\"    ) }\n        val PuOR       by lazy { listOf(PuOR3, PuOR4, PuOR5, PuOR6, PuOR7, PuOR8, PuOR9, PuOR10, PuOR11) }\n\n        private val RdBU3   by lazy { EncodedColors(\"ef8a62f7f7f767a9cf\"                                                    ) }\n        private val RdBU4   by lazy { EncodedColors(\"ca0020f4a58292c5de0571b0\"                                              ) }\n        private val RdBU5   by lazy { EncodedColors(\"ca0020f4a582f7f7f792c5de0571b0\"                                        ) }\n        private val RdBU6   by lazy { EncodedColors(\"b2182bef8a62fddbc7d1e5f067a9cf2166ac\"                                  ) }\n        private val RdBU7   by lazy { EncodedColors(\"b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac\"                            ) }\n        private val RdBU8   by lazy { EncodedColors(\"b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac\"                      ) }\n        private val RdBU9   by lazy { EncodedColors(\"b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac\"                ) }\n        private val RdBU10  by lazy { EncodedColors(\"67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061\"          ) }\n        private val RdBU11  by lazy { EncodedColors(\"67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061\"    ) }\n        val RdBU       by lazy { listOf(RdBU3, RdBU4, RdBU5, RdBU6, RdBU7, RdBU8, RdBU9, RdBU10, RdBU11) }\n\n        private val RdGY3   by lazy { EncodedColors(\"ef8a62ffffff999999\"                                                    ) }\n        private val RdGY4   by lazy { EncodedColors(\"ca0020f4a582bababa404040\"                                              ) }\n        private val RdGY5   by lazy { EncodedColors(\"ca0020f4a582ffffffbababa404040\"                                        ) }\n        private val RdGY6   by lazy { EncodedColors(\"b2182bef8a62fddbc7e0e0e09999994d4d4d\"                                  ) }\n        private val RdGY7   by lazy { EncodedColors(\"b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d\"                            ) }\n        private val RdGY8   by lazy { EncodedColors(\"b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d\"                      ) }\n        private val RdGY9   by lazy { EncodedColors(\"b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d\"                ) }\n        private val RdGY10  by lazy { EncodedColors(\"67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a\"          ) }\n        private val RdGY11  by lazy { EncodedColors(\"67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a\"    ) }\n        val RdGY       by lazy { listOf(RdGY3, RdGY4, RdGY5, RdGY6, RdGY7, RdGY8, RdGY9, RdGY10, RdGY11) }\n\n        private val RdYlBu3   by lazy { EncodedColors(\"fc8d59ffffbf91bfdb\"                                                  ) }\n        private val RdYlBu4   by lazy { EncodedColors(\"d7191cfdae61abd9e92c7bb6\"                                            ) }\n        private val RdYlBu5   by lazy { EncodedColors(\"d7191cfdae61ffffbfabd9e92c7bb6\"                                      ) }\n        private val RdYlBu6   by lazy { EncodedColors(\"d73027fc8d59fee090e0f3f891bfdb4575b4\"                                ) }\n        private val RdYlBu7   by lazy { EncodedColors(\"d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4\"                          ) }\n        private val RdYlBu8   by lazy { EncodedColors(\"d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4\"                    ) }\n        private val RdYlBu9   by lazy { EncodedColors(\"d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4\"              ) }\n        private val RdYlBu10  by lazy { EncodedColors(\"a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695\"        ) }\n        private val RdYlBu11  by lazy { EncodedColors(\"a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695\"  ) }\n        val RdYlBu       by lazy { listOf(RdYlBu3, RdYlBu4, RdYlBu5, RdYlBu6, RdYlBu7, RdYlBu8, RdYlBu9, RdYlBu10, RdYlBu11) }\n\n        private val RdYlGn3   by lazy { EncodedColors(\"fc8d59ffffbf91cf60\"                                                  ) }\n        private val RdYlGn4   by lazy { EncodedColors(\"d7191cfdae61a6d96a1a9641\"                                            ) }\n        private val RdYlGn5   by lazy { EncodedColors(\"d7191cfdae61ffffbfa6d96a1a9641\"                                      ) }\n        private val RdYlGn6   by lazy { EncodedColors(\"d73027fc8d59fee08bd9ef8b91cf601a9850\"                                ) }\n        private val RdYlGn7   by lazy { EncodedColors(\"d73027fc8d59fee08bffffbfd9ef8b91cf601a9850\"                          ) }\n        private val RdYlGn8   by lazy { EncodedColors(\"d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850\"                    ) }\n        private val RdYlGn9   by lazy { EncodedColors(\"d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850\"              ) }\n        private val RdYlGn10  by lazy { EncodedColors(\"a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837\"        ) }\n        private val RdYlGn11  by lazy { EncodedColors(\"a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837\"  ) }\n        val RdYlGn       by lazy { listOf(RdYlGn3, RdYlGn4, RdYlGn5, RdYlGn6, RdYlGn7, RdYlGn8, RdYlGn9, RdYlGn10, RdYlGn11) }\n\n        private val spectral3   by lazy { EncodedColors(\"fc8d59ffffbf99d594\"                                                ) }\n        private val spectral4   by lazy { EncodedColors(\"d7191cfdae61abdda42b83ba\"                                          ) }\n        private val spectral5   by lazy { EncodedColors(\"d7191cfdae61ffffbfabdda42b83ba\"                                    ) }\n        private val spectral6   by lazy { EncodedColors(\"d53e4ffc8d59fee08be6f59899d5943288bd\"                              ) }\n        private val spectral7   by lazy { EncodedColors(\"d53e4ffc8d59fee08bffffbfe6f59899d5943288bd\"                        ) }\n        private val spectral8   by lazy { EncodedColors(\"d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd\"                  ) }\n        private val spectral9   by lazy { EncodedColors(\"d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd\"            ) }\n        private val spectral10  by lazy { EncodedColors(\"9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2\"      ) }\n        private val spectral11  by lazy { EncodedColors(\"9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2\") }\n        val spectral       by lazy { listOf(spectral3, spectral4, spectral5, spectral6, spectral7, spectral8, spectral9, spectral10, spectral11) }\n\n        // SEQUENTIAL-MULTI\n        // TODO CUBEHELIX + RAINBOW\n        val viridis by lazy { EncodedColors(\"44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725\") }\n        val magma by lazy { EncodedColors(\"00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf\") }\n        val inferno by lazy { EncodedColors(\"00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4\") }\n        val plasma by lazy { EncodedColors(\"0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921\") }\n\n        private val BuGN3   by lazy { EncodedColors(\"e5f5f999d8c92ca25f\"                                                    ) }\n        private val BuGN4   by lazy { EncodedColors(\"edf8fbb2e2e266c2a4238b45\"                                              ) }\n        private val BuGN5   by lazy { EncodedColors(\"edf8fbb2e2e266c2a42ca25f006d2c\"                                        ) }\n        private val BuGN6   by lazy { EncodedColors(\"edf8fbccece699d8c966c2a42ca25f006d2c\"                                  ) }\n        private val BuGN7   by lazy { EncodedColors(\"edf8fbccece699d8c966c2a441ae76238b45005824\"                            ) }\n        private val BuGN8   by lazy { EncodedColors(\"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824\"                      ) }\n        private val BuGN9   by lazy { EncodedColors(\"f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b\"                ) }\n        val BuGN       by lazy { listOf(BuGN3, BuGN4, BuGN5, BuGN6, BuGN7, BuGN8, BuGN9) }\n\n        private val BuPu3   by lazy { EncodedColors(\"e0ecf49ebcda8856a7\"                                                    ) }\n        private val BuPu4   by lazy { EncodedColors(\"edf8fbb3cde38c96c688419d\"                                              ) }\n        private val BuPu5   by lazy { EncodedColors(\"edf8fbb3cde38c96c68856a7810f7c\"                                        ) }\n        private val BuPu6   by lazy { EncodedColors(\"edf8fbbfd3e69ebcda8c96c68856a7810f7c\"                                  ) }\n        private val BuPu7   by lazy { EncodedColors(\"edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b\"                            ) }\n        private val BuPu8   by lazy { EncodedColors(\"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b\"                      ) }\n        private val BuPu9   by lazy { EncodedColors(\"f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b\"                ) }\n        val BuPu       by lazy { listOf(BuPu3, BuPu4, BuPu5, BuPu6, BuPu7, BuPu8, BuPu9) }\n\n        private val GnBu3   by lazy { EncodedColors(\"e0f3dba8ddb543a2ca\"                                                    ) }\n        private val GnBu4   by lazy { EncodedColors(\"f0f9e8bae4bc7bccc42b8cbe\"                                              ) }\n        private val GnBu5   by lazy { EncodedColors(\"f0f9e8bae4bc7bccc443a2ca0868ac\"                                        ) }\n        private val GnBu6   by lazy { EncodedColors(\"f0f9e8ccebc5a8ddb57bccc443a2ca0868ac\"                                  ) }\n        private val GnBu7   by lazy { EncodedColors(\"f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e\"                            ) }\n        private val GnBu8   by lazy { EncodedColors(\"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e\"                      ) }\n        private val GnBu9   by lazy { EncodedColors(\"f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081\"                ) }\n        val GnBu       by lazy { listOf(GnBu3, GnBu4, GnBu5, GnBu6, GnBu7, GnBu8, GnBu9) }\n\n        private val OrRd3   by lazy { EncodedColors(\"fee8c8fdbb84e34a33\"                                                    ) }\n        private val OrRd4   by lazy { EncodedColors(\"fef0d9fdcc8afc8d59d7301f\"                                              ) }\n        private val OrRd5   by lazy { EncodedColors(\"fef0d9fdcc8afc8d59e34a33b30000\"                                        ) }\n        private val OrRd6   by lazy { EncodedColors(\"fef0d9fdd49efdbb84fc8d59e34a33b30000\"                                  ) }\n        private val OrRd7   by lazy { EncodedColors(\"fef0d9fdd49efdbb84fc8d59ef6548d7301f990000\"                            ) }\n        private val OrRd8   by lazy { EncodedColors(\"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000\"                      ) }\n        private val OrRd9   by lazy { EncodedColors(\"fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000\"                ) }\n        val OrRd       by lazy { listOf(OrRd3, OrRd4, OrRd5, OrRd6, OrRd7, OrRd8, OrRd9) }\n\n        private val PuBu3   by lazy { EncodedColors(\"ece7f2a6bddb2b8cbe\"                                                    ) }\n        private val PuBu4   by lazy { EncodedColors(\"f1eef6bdc9e174a9cf0570b0\"                                              ) }\n        private val PuBu5   by lazy { EncodedColors(\"f1eef6bdc9e174a9cf2b8cbe045a8d\"                                        ) }\n        private val PuBu6   by lazy { EncodedColors(\"f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d\"                                  ) }\n        private val PuBu7   by lazy { EncodedColors(\"f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b\"                            ) }\n        private val PuBu8   by lazy { EncodedColors(\"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b\"                      ) }\n        private val PuBu9   by lazy { EncodedColors(\"fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858\"                ) }\n        val PuBu       by lazy { listOf(PuBu3, PuBu4, PuBu5, PuBu6, PuBu7, PuBu8, PuBu9) }\n\n        private val PuBuGn3   by lazy { EncodedColors(\"ece2f0a6bddb1c9099\"                                                  ) }\n        private val PuBuGn4   by lazy { EncodedColors(\"f6eff7bdc9e167a9cf02818a\"                                            ) }\n        private val PuBuGn5   by lazy { EncodedColors(\"f6eff7bdc9e167a9cf1c9099016c59\"                                      ) }\n        private val PuBuGn6   by lazy { EncodedColors(\"f6eff7d0d1e6a6bddb67a9cf1c9099016c59\"                                ) }\n        private val PuBuGn7   by lazy { EncodedColors(\"f6eff7d0d1e6a6bddb67a9cf3690c002818a016450\"                          ) }\n        private val PuBuGn8   by lazy { EncodedColors(\"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450\"                    ) }\n        private val PuBuGn9   by lazy { EncodedColors(\"fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636\"              ) }\n        val PuBuGn       by lazy { listOf(PuBuGn3, PuBuGn4, PuBuGn5, PuBuGn6, PuBuGn7, PuBuGn8, PuBuGn9) }\n\n        private val PuRd3   by lazy { EncodedColors(\"e7e1efc994c7dd1c77\"                                                    ) }\n        private val PuRd4   by lazy { EncodedColors(\"f1eef6d7b5d8df65b0ce1256\"                                              ) }\n        private val PuRd5   by lazy { EncodedColors(\"f1eef6d7b5d8df65b0dd1c77980043\"                                        ) }\n        private val PuRd6   by lazy { EncodedColors(\"f1eef6d4b9dac994c7df65b0dd1c77980043\"                                  ) }\n        private val PuRd7   by lazy { EncodedColors(\"f1eef6d4b9dac994c7df65b0e7298ace125691003f\"                            ) }\n        private val PuRd8   by lazy { EncodedColors(\"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f\"                      ) }\n        private val PuRd9   by lazy { EncodedColors(\"f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f\"                ) }\n        val PuRd       by lazy { listOf(PuRd3, PuRd4, PuRd5, PuRd6, PuRd7, PuRd8, PuRd9) }\n\n        private val RdPu3   by lazy { EncodedColors(\"fde0ddfa9fb5c51b8a\"                                                    ) }\n        private val RdPu4   by lazy { EncodedColors(\"feebe2fbb4b9f768a1ae017e\"                                              ) }\n        private val RdPu5   by lazy { EncodedColors(\"feebe2fbb4b9f768a1c51b8a7a0177\"                                        ) }\n        private val RdPu6   by lazy { EncodedColors(\"feebe2fcc5c0fa9fb5f768a1c51b8a7a0177\"                                  ) }\n        private val RdPu7   by lazy { EncodedColors(\"feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177\"                            ) }\n        private val RdPu8   by lazy { EncodedColors(\"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177\"                      ) }\n        private val RdPu9   by lazy { EncodedColors(\"fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a\"                ) }\n        val RdPu       by lazy { listOf(RdPu3, RdPu4, RdPu5, RdPu6, RdPu7, RdPu8, RdPu9) }\n\n        private val YlGn3   by lazy { EncodedColors(\"f7fcb9addd8e31a354\"                                                    ) }\n        private val YlGn4   by lazy { EncodedColors(\"ffffccc2e69978c679238443\"                                              ) }\n        private val YlGn5   by lazy { EncodedColors(\"ffffccc2e69978c67931a354006837\"                                        ) }\n        private val YlGn6   by lazy { EncodedColors(\"ffffccd9f0a3addd8e78c67931a354006837\"                                  ) }\n        private val YlGn7   by lazy { EncodedColors(\"ffffccd9f0a3addd8e78c67941ab5d238443005a32\"                            ) }\n        private val YlGn8   by lazy { EncodedColors(\"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32\"                      ) }\n        private val YlGn9   by lazy { EncodedColors(\"ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529\"                ) }\n        val YlGn       by lazy { listOf(YlGn3, YlGn4, YlGn5, YlGn6, YlGn7, YlGn8, YlGn9) }\n\n        private val YlGnbU3   by lazy { EncodedColors(\"edf8b17fcdbb2c7fb8\"                                                  ) }\n        private val YlGnbU4   by lazy { EncodedColors(\"ffffcca1dab441b6c4225ea8\"                                            ) }\n        private val YlGnbU5   by lazy { EncodedColors(\"ffffcca1dab441b6c42c7fb8253494\"                                      ) }\n        private val YlGnbU6   by lazy { EncodedColors(\"ffffccc7e9b47fcdbb41b6c42c7fb8253494\"                                ) }\n        private val YlGnbU7   by lazy { EncodedColors(\"ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84\"                          ) }\n        private val YlGnbU8   by lazy { EncodedColors(\"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84\"                    ) }\n        private val YlGnbU9   by lazy { EncodedColors(\"ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58\"              ) }\n        val YlGnbU       by lazy { listOf(YlGnbU3, YlGnbU4, YlGnbU5, YlGnbU6, YlGnbU7, YlGnbU8, YlGnbU9) }\n\n        private val YlGnBr3   by lazy { EncodedColors(\"fff7bcfec44fd95f0e\"                                                  ) }\n        private val YlGnBr4   by lazy { EncodedColors(\"ffffd4fed98efe9929cc4c02\"                                            ) }\n        private val YlGnBr5   by lazy { EncodedColors(\"ffffd4fed98efe9929d95f0e993404\"                                      ) }\n        private val YlGnBr6   by lazy { EncodedColors(\"ffffd4fee391fec44ffe9929d95f0e993404\"                                ) }\n        private val YlGnBr7   by lazy { EncodedColors(\"ffffd4fee391fec44ffe9929ec7014cc4c028c2d04\"                          ) }\n        private val YlGnBr8   by lazy { EncodedColors(\"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04\"                    ) }\n        private val YlGnBr9   by lazy { EncodedColors(\"ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506\"              ) }\n        val YlGnBr       by lazy { listOf(YlGnBr3, YlGnBr4, YlGnBr5, YlGnBr6, YlGnBr7, YlGnBr8, YlGnBr9) }\n\n        private val YlGnRd3   by lazy { EncodedColors(\"ffeda0feb24cf03b20\"                                                  ) }\n        private val YlGnRd4   by lazy { EncodedColors(\"ffffb2fecc5cfd8d3ce31a1c\"                                            ) }\n        private val YlGnRd5   by lazy { EncodedColors(\"ffffb2fecc5cfd8d3cf03b20bd0026\"                                      ) }\n        private val YlGnRd6   by lazy { EncodedColors(\"ffffb2fed976feb24cfd8d3cf03b20bd0026\"                                ) }\n        private val YlGnRd7   by lazy { EncodedColors(\"ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026\"                          ) }\n        private val YlGnRd8   by lazy { EncodedColors(\"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026\"                    ) }\n        private val YlGnRd9   by lazy { EncodedColors(\"ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026\"              ) }\n        val YlGnRd       by lazy { listOf(YlGnRd3, YlGnRd4, YlGnRd5, YlGnRd6, YlGnRd7, YlGnRd8, YlGnRd9) }\n\n        \n        // SEQUENTIAL SINGLE\n        private val blues3   by lazy { EncodedColors(\"deebf79ecae13182bd\"                                                   ) }\n        private val blues4   by lazy { EncodedColors(\"eff3ffbdd7e76baed62171b5\"                                             ) }\n        private val blues5   by lazy { EncodedColors(\"eff3ffbdd7e76baed63182bd08519c\"                                       ) }\n        private val blues6   by lazy { EncodedColors(\"eff3ffc6dbef9ecae16baed63182bd08519c\"                                 ) }\n        private val blues7   by lazy { EncodedColors(\"eff3ffc6dbef9ecae16baed64292c62171b5084594\"                           ) }\n        private val blues8   by lazy { EncodedColors(\"f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594\"                     ) }\n        private val blues9   by lazy { EncodedColors(\"f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b\"               ) }\n        val blues       by lazy { listOf(blues3, blues4, blues5, blues6, blues7, blues8, blues9) }\n\n        private val greens3   by lazy { EncodedColors(\"e5f5e0a1d99b31a354\"                                                  ) }\n        private val greens4   by lazy { EncodedColors(\"edf8e9bae4b374c476238b45\"                                            ) }\n        private val greens5   by lazy { EncodedColors(\"edf8e9bae4b374c47631a354006d2c\"                                      ) }\n        private val greens6   by lazy { EncodedColors(\"edf8e9c7e9c0a1d99b74c47631a354006d2c\"                                ) }\n        private val greens7   by lazy { EncodedColors(\"edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32\"                          ) }\n        private val greens8   by lazy { EncodedColors(\"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32\"                    ) }\n        private val greens9   by lazy { EncodedColors(\"f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b\"              ) }\n        val greens       by lazy { listOf(greens3, greens4, greens5, greens6, greens7, greens8, greens9) }\n\n        private val greys3   by lazy { EncodedColors(\"f0f0f0bdbdbd636363\"                                                   ) }\n        private val greys4   by lazy { EncodedColors(\"f7f7f7cccccc969696525252\"                                             ) }\n        private val greys5   by lazy { EncodedColors(\"f7f7f7cccccc969696636363252525\"                                       ) }\n        private val greys6   by lazy { EncodedColors(\"f7f7f7d9d9d9bdbdbd969696636363252525\"                                 ) }\n        private val greys7   by lazy { EncodedColors(\"f7f7f7d9d9d9bdbdbd969696737373525252252525\"                           ) }\n        private val greys8   by lazy { EncodedColors(\"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525\"                     ) }\n        private val greys9   by lazy { EncodedColors(\"fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000\"               ) }\n        val greys       by lazy { listOf(greys3, greys4, greys5, greys6, greys7, greys8, greys9) }\n\n        private val oranges3   by lazy { EncodedColors(\"fee6cefdae6be6550d\"                                                 ) }\n        private val oranges4   by lazy { EncodedColors(\"feeddefdbe85fd8d3cd94701\"                                           ) }\n        private val oranges5   by lazy { EncodedColors(\"feeddefdbe85fd8d3ce6550da63603\"                                     ) }\n        private val oranges6   by lazy { EncodedColors(\"feeddefdd0a2fdae6bfd8d3ce6550da63603\"                               ) }\n        private val oranges7   by lazy { EncodedColors(\"feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04\"                         ) }\n        private val oranges8   by lazy { EncodedColors(\"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04\"                   ) }\n        private val oranges9   by lazy { EncodedColors(\"fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704\"             ) }\n        val oranges       by lazy { listOf(oranges3, oranges4, oranges5, oranges6, oranges7, oranges8, oranges9) }\n\n        private val purples3   by lazy { EncodedColors(\"efedf5bcbddc756bb1\"                                                 ) }\n        private val purples4   by lazy { EncodedColors(\"f2f0f7cbc9e29e9ac86a51a3\"                                           ) }\n        private val purples5   by lazy { EncodedColors(\"f2f0f7cbc9e29e9ac8756bb154278f\"                                     ) }\n        private val purples6   by lazy { EncodedColors(\"f2f0f7dadaebbcbddc9e9ac8756bb154278f\"                               ) }\n        private val purples7   by lazy { EncodedColors(\"f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486\"                         ) }\n        private val purples8   by lazy { EncodedColors(\"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486\"                   ) }\n        private val purples9   by lazy { EncodedColors(\"fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d\"             ) }\n        val purples       by lazy { listOf(purples3, purples4, purples5, purples6, purples7, purples8, purples9) }\n\n        private val reds3   by lazy { EncodedColors(\"fee0d2fc9272de2d26\"                                                    ) }\n        private val reds4   by lazy { EncodedColors(\"fee5d9fcae91fb6a4acb181d\"                                              ) }\n        private val reds5   by lazy { EncodedColors(\"fee5d9fcae91fb6a4ade2d26a50f15\"                                        ) }\n        private val reds6   by lazy { EncodedColors(\"fee5d9fcbba1fc9272fb6a4ade2d26a50f15\"                                  ) }\n        private val reds7   by lazy { EncodedColors(\"fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d\"                            ) }\n        private val reds8   by lazy { EncodedColors(\"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d\"                      ) }\n        private val reds9   by lazy { EncodedColors(\"fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d\"                ) }\n        val reds       by lazy { listOf(reds3, reds4, reds5, reds6, reds7, reds8, reds9) }\n    }\n\n    init {\n        require(colorsAsString.length % 6 == 0) { \"colorsAsString size should be a multiple of 6\" }\n    }\n\n    val colors by lazy {\n        with(colorsAsString) {\n            (0..((this.length / 6) - 1)).map { \"#${substring(6 * it, 6 * it + 6)}\".col }\n        }\n    }\n\n    /**\n     * Returns the color corresponding at the given percentage of the gradient\n     */\n    fun color(percent: Double) = colors[floor(percent * colors.size).toInt()\n            .coerceAtLeast(0)\n            .coerceAtMost(colors.size - 1)]\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    return String(chars.copyOfRange(offset, offset + length))\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","package io.data2viz.color\n\nimport io.data2viz.math.*\nimport kotlin.math.max\n\n/**\n * Create a color in the HCL color space (CIELCH)\n *\n * This Colorspace is designed to accord with human perception of color.\n * HCL has been adopted by information visualization practitioners to present data without the bias implicit in\n * using varying saturation.\n *\n * @param h hue: Angle\n * @param c chroma: Double, the upper bound for chroma depends on hue and luminance (typically in 0..230)\n * @param lightness: Percent, value between 0% and 100%\n * @param alpha: Opacity, value between 0% and 100%\n */\nclass HclColor\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"Colors.hcl(h,c,l,alpha)\", \"io.data2viz.colors.Colors\"))\ninternal constructor(val h: Angle, val c: Double, lightness: Percent, a: Percent = 100.pct) : Color {\n\n    val l = lightness//.coerceIn(.0, 100.0)\n    override val alpha = a.coerceToDefault()\n\n    override val rgb = toRgb().rgb\n    override val rgba = toRgb().rgba\n    override val r = toRgb().r\n    override val g = toRgb().g\n    override val b = toRgb().b\n    override val rgbHex: String = toRgb().rgbHex\n\n    override fun luminance() = toRgb().luminance()\n    override fun contrast(other:Color) = toRgb().contrast(other)\n\n    override fun toRgb():RgbColor = toLab().toRgb()\n    override fun toLab(): LabColor = toLaba()\n    override fun toHcl(): HclColor = this\n    override fun toHsl(): HslColor = toLab().toHsl()\n\n    override fun brighten(strength: Double): Color = Colors.hcl(h, c, (l + (Kn * strength).pct), alpha)\n    override fun darken(strength: Double): Color = Colors.hcl(h, c, (l - (Kn * strength).pct), alpha)\n    override fun saturate(strength: Double): Color = Colors.hcl(h, max(.0, (c + (Kn * strength))), l, alpha)\n    override fun desaturate(strength: Double): Color = Colors.hcl(h, max(.0, (c - (Kn * strength))), l, alpha)\n    override fun withAlpha(alpha: Percent) = Colors.hcl(h, c, l, alpha)\n    override fun withHue(hue: Angle) = Colors.hcl(hue, c, l, alpha)\n\n    fun isAchromatic() = (c == .0) || (l.value <= .0) || (l.value >= 1.0)\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || other !is Color) return false\n\n        if (rgb != other.rgb) return false\n        if (alpha != other.alpha) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = rgb\n        result = 31 * result + alpha.hashCode()\n        return result\n    }\n\n    override fun toString() = \"HCL(${h.deg}\u00b0, $c, $l%, alpha=$alpha)\"\n}","package io.data2viz.color\n\nimport io.data2viz.math.*\n\n/**\n * Create a color in the HSL color space\n *\n * @param h hue: Angle\n * @param s saturation: Percent, value between 0% and 100%\n * @param l lightness: Percent, value between 0% and 100%\n * @param alpha: Opacity, value between 0% and 100%\n */\nclass HslColor\n@Deprecated(\"Deprecated\", ReplaceWith(\"Colors.hsl(hue,saturation,luminance,a)\", \"io.data2viz.colors.Colors\"))\ninternal constructor(hue: Angle, saturation: Percent, lightness: Percent, a: Percent = 100.pct) : Color {\n\n    val h = hue.normalize()\n    val s = saturation.coerceToDefault()\n    val l = lightness.coerceToDefault()\n    override val alpha = a.coerceToDefault()\n\n    override val rgb = toRgb().rgb\n    override val rgba = toRgb().rgba\n    override val r = toRgb().r\n    override val g = toRgb().g\n    override val b = toRgb().b\n    override val rgbHex: String = toRgb().rgbHex\n\n    override fun luminance() = toRgb().luminance()\n    override fun contrast(other:Color) = toRgb().contrast(other)\n\n    override fun toRgb(): RgbColor = toRgba()\n    override fun toLab(): LabColor = toRgb().toLab()\n    override fun toHcl(): HclColor = toRgb().toHcl()\n    override fun toHsl(): HslColor = this\n\n    override fun brighten(strength: Double): Color = toRgb().brighten(strength)\n    override fun darken(strength: Double): Color = toRgb().darken(strength)\n    override fun saturate(strength: Double): Color = toRgb().saturate(strength)\n    override fun desaturate(strength: Double): Color = toRgb().desaturate(strength)\n    override fun withAlpha(alpha: Percent) = Colors.hsl(h, s, l, alpha)\n    override fun withHue(hue: Angle) = toHcl().withHue(hue)\n\n    fun isAchromatic() = (s.value == .0) || (l.value <= .0) || (l.value >= 1.0)\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || other !is Color) return false\n\n        if (rgb != other.rgb) return false\n        if (alpha != other.alpha) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = rgb\n        result = 31 * result + alpha.hashCode()\n        return result\n    }\n\n    override fun toString() = \"HSL(${h.deg}\u00b0, $s, $l, alpha=$alpha)\"\n}","package io.data2viz.color\n\nimport io.data2viz.math.*\n\n/**\n * Create a color in the LAB color space (CIE L*a*b* D65 whitepoint)\n *\n * @param lightness: Percent, value between 0% and 100%\n * @param aComponent \"a\"-component: Double for green-red between -128 and +128\n * @param bComponent \"b\"-component: Double for blue-yellow between -128 and +128\n * @param alpha: Opacity, value between 0% and 100%\n */\nclass LabColor\n@Deprecated(\"Deprecated\", ReplaceWith(\"Colors.lab(labL,labA,labB,alpha)\", \"io.data2viz.colors.Colors\"))\ninternal constructor(lightness: Percent, aComponent: Double, bComponent: Double, a: Percent = 100.pct) : Color {\n\n    // TODO : need to choose behavior: if values are coerced the results are not what expected when referring to test values from chroma.js\n    val labL = lightness//.coerceIn(.0, 100.0)\n    val labA = aComponent//.coerceIn(-128.0, 128.0)\n    val labB = bComponent//.coerceIn(-128.0, 128.0)\n    override val alpha = a.coerceToDefault()\n\n    override val rgb = toRgb().rgb\n    override val rgba = toRgb().rgba\n    override val r = toRgb().r\n    override val g = toRgb().g\n    override val b = toRgb().b\n    override val rgbHex: String = toRgb().rgbHex\n\n    override fun luminance() = toRgb().luminance()\n    override fun contrast(other:Color) = toRgb().contrast(other)\n\n    override fun toRgb(): RgbColor = toRgba()\n    override fun toLab(): LabColor = this\n    override fun toHcl(): HclColor = toHcla()\n    override fun toHsl(): HslColor = toRgb().toHsl()\n\n    override fun brighten(strength: Double): Color = Colors.lab((labL + (Kn * strength).pct), labA, labB, alpha)\n    override fun darken(strength: Double): Color = Colors.lab((labL - (Kn * strength).pct), labA, labB, alpha)\n    override fun saturate(strength: Double): Color = toHcl().saturate(strength)\n    override fun desaturate(strength: Double): Color = toHcl().desaturate(strength)\n    override fun withAlpha(alpha: Percent) = Colors.lab(labL, labA, labB, alpha)\n    override fun withHue(hue: Angle) = toHcl().withHue(hue)\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || other !is Color) return false\n\n        if (rgb != other.rgb) return false\n        if (alpha != other.alpha) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = rgb\n        result = 31 * result + alpha.hashCode()\n        return result\n    }\n\n    override fun toString() = \"LAB($labL%, $labA, $labB, alpha=$alpha)\"\n}","@file:Suppress(\"DEPRECATION\")\n\npackage io.data2viz.color\n\nimport io.data2viz.geom.Point\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\n\n// TODO : move to \"core.geom\" ?\n// TODO : remove access to x1, y1, x2, y2\ninterface HasStartAndEnd {\n    var x1: Double\n    var y1: Double\n    var x2: Double\n    var y2: Double\n\n    var start: Point\n        get() = Point(x1, y1)\n        set(value) {\n            x1 = value.x\n            y1 = value.y\n        }\n\n    var end: Point\n        get() = Point(x2, y2)\n        set(value) {\n            x2 = value.x\n            y2 = value.y\n        }\n}\n\ndata class LinearGradientFirstColorBuilder\ninternal constructor(val start: Point, val end: Point) {\n    fun withColor(startColor: Color, percent: Percent = 0.pct): LinearGradientSecondColorBuilder =\n        LinearGradientSecondColorBuilder(this, ColorStop(percent, startColor))\n}\n\ndata class LinearGradientSecondColorBuilder\ninternal constructor(val builder: LinearGradientFirstColorBuilder, val firstColor: ColorStop) {\n    fun andColor(color: Color, percent: Percent = 100.pct): LinearGradient = LinearGradient()\n        .apply {\n            x1 = builder.start.x\n            y1 = builder.start.y\n            x2 = builder.end.x\n            y2 = builder.end.y\n            andColor(firstColor.color, firstColor.percent)\n            andColor(color, percent)\n        }\n}\n\nclass LinearGradient\n@Deprecated(\"Deprecated\", ReplaceWith(\"Colors.Gradient.linear()\", \"io.data2viz.colors.Colors\"))\ninternal constructor() : Gradient, HasStartAndEnd {\n\n    override var x1: Double = .0\n    override var y1: Double = .0\n    override var x2: Double = .0\n    override var y2: Double = .0\n\n    private val colors = mutableListOf<ColorStop>()\n    override val colorStops: List<ColorStop>\n        get() = colors.toList()\n\n    fun andColor(color: Color, percent: Percent): LinearGradient {\n        colors.add(ColorStop(percent.coerceToDefault(), color))\n        return this\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","@file:Suppress(\"DEPRECATION\")\n\npackage io.data2viz.color\n\nimport io.data2viz.geom.Point\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\n\n// TODO : move to \"core.geom\" ?\n// TODO : remove access to cx, cy, leave only access to center\ninterface HasCenter {\n    var cx: Double\n    var cy: Double\n\n    var center:Point\n        get() = Point(cx,cy)\n        set(value) {\n            cx = value.x\n            cy = value.y\n        }\n}\n\ndata class RadialGradientFirstColorBuilder\ninternal constructor(val center: Point, val radius: Double) {\n    fun withColor(startColor: Color, percent: Percent = 0.pct): RadialGradientSecondColorBuilder =\n        RadialGradientSecondColorBuilder(this, ColorStop(percent, startColor))\n}\n\ndata class RadialGradientSecondColorBuilder\ninternal constructor(val builder: RadialGradientFirstColorBuilder, val firstColor: ColorStop) {\n    fun andColor(color: Color, percent: Percent = 100.pct): RadialGradient = RadialGradient()\n        .apply {\n            cx = builder.center.x\n            cy = builder.center.y\n            radius = builder.radius\n            andColor(firstColor.color, firstColor.percent)\n            andColor(color, percent)\n        }\n}\n\nclass RadialGradient\n\n@Deprecated(\"Deprecated\", ReplaceWith(\"Colors.Gradient.radial()\", \"io.data2viz.colors.Colors\"))\nconstructor(): Gradient, HasCenter {\n\n    override var cx:Double = .0\n    override var cy:Double = .0\n    var radius:Double = .0\n\n    private val colors = mutableListOf<ColorStop>()\n    override val colorStops: List<ColorStop>\n        get() = colors.toList()\n\n    fun andColor(color: Color, percent: Percent): RadialGradient {\n        colors.add(ColorStop(percent.coerceToDefault(), color))\n        return this\n    }\n}","package io.data2viz.color\n\nimport io.data2viz.math.Angle\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\n\n/**\n * Implementation of Color as an rgb integer and an alpha channel.\n *\n * Provides conversion with hex string notation.\n *\n * See https://developer.mozilla.org/en-US/docs/Web/CSS/color_value and\n * https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Colors/Color_picker_tool\n */\nclass RgbColor\n    @Deprecated(\"Use factory function or Int.col extension.\", ReplaceWith(\"Colors.rgb(rgb,a)\", \"io.data2viz.colors.Colors\"))\n    constructor(override val rgb: Int, a: Percent = 100.pct) : Color {\n\n    override val alpha = a.coerceToDefault()\n\n    override val r: Int\n        get() = (rgb shr 16) and 0xff\n\n    override val g: Int\n        get() = (rgb shr 8) and 0xff\n\n    override val b: Int\n        get() = rgb and 0xff\n\n    override fun luminance() = toLuminance()\n    override fun contrast(other:Color): Double {\n        val lumA = luminance()\n        val lumB = other.luminance()\n        return if (lumA > lumB) (lumA.value + 0.05) / (lumB.value + 0.05) else (lumB.value + 0.05) / (lumA.value + 0.05)\n    }\n\n    override fun toRgb(): RgbColor = this\n    override fun toLab(): LabColor = toLaba()\n    override fun toHcl(): HclColor = toLab().toHcl()\n    override fun toHsl(): HslColor = toHsla()\n\n    override fun brighten(strength: Double): Color = toLab().brighten(strength)\n    override fun darken(strength: Double): Color = toLab().darken(strength)\n    override fun saturate(strength: Double): Color = toLab().saturate(strength)\n    override fun desaturate(strength: Double): Color = toLab().desaturate(strength)\n    override fun withHue(hue: Angle) = toHcl().withHue(hue)\n\n    fun withRed(red: Int): RgbColor {\n        val rgb = (rgb and 0x00ffff) + (red.coerceIn(0, 255) shl 16)\n        return Colors.rgb(rgb, alpha)\n    }\n\n    fun withGreen(green: Int): RgbColor {\n        val rgb = (rgb and 0xff00ff) + (green.coerceIn(0, 255) shl 8)\n        return Colors.rgb(rgb, alpha)\n    }\n\n    fun withBlue(blue: Int): RgbColor {\n        val rgb = (rgb and 0xffff00) + blue.coerceIn(0, 255)\n        return Colors.rgb(rgb, alpha)\n    }\n\n    override val rgbHex: String\n        get() = \"#\" +\n                ((rgb shr 20) and 0xf).toString(16) +\n                ((rgb shr 16) and 0xf).toString(16) +\n                ((rgb shr 12) and 0xf).toString(16) +\n                ((rgb shr 8) and 0xf).toString(16) +\n                ((rgb shr 4) and 0xf).toString(16) +\n                (rgb and 0xf).toString(16)\n\n    override val rgba: String\n        get() = \"rgba($r, $g, $b, ${alpha.value})\"\n\n    override fun withAlpha(alpha: Percent) = Colors.rgb(rgb, alpha)\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other == null || other !is Color) return false\n\n        if (rgb != other.rgb) return false\n        if (alpha != other.alpha) return false\n\n        return true\n    }\n\n    override fun hashCode(): Int {\n        var result = rgb\n        result = 31 * result + alpha.hashCode()\n        return result\n    }\n\n    override fun toString() = \"RGB($r, $g, $b, alpha=$alpha) - $rgbHex\"\n}\n\n\n/**\n * Instantiate a color from an Int. It should be used\n * using the HEX code like this : `0x0b0b0b.col`\n */\nval Int.col: RgbColor\n    get() = Colors.rgb(this)\n\n@Deprecated(\"Use the 3 characters version of it.\", ReplaceWith(\"this.col\"))\nval Int.color: RgbColor\n    get() = this.col\n\n/**\n * Instantiate a color from an String representing its hexadecimal value.\n * Ex: \"#12abCD\".col\n */\nval String.col: RgbColor\n    get():RgbColor {\n        val regex = \"\"\"^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$\"\"\".toRegex()\n        require(this.matches(regex)) {\n            \"Conversion of string to io.data2viz.col.RgbColor works for encoded colors like #12abCD\"\n        }\n        return Colors.rgb(substring(1).toInt(16))\n    }\n\n@Deprecated(\"Use the 3 characters version of it.\", ReplaceWith(\"this.col\"))\nval String.color: RgbColor\n    get() = this.col","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\n\npackage kotlin.text\n\nimport kotlin.*\nimport kotlin.comparisons.*\nimport kotlin.contracts.contract\n\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.append(this, 0, startIndex)\n    sb.append(replacement)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.append(this, 0, startIndex)\n    sb.append(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" } )\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    require(limit >= 0, { \"Limit must be non-negative, but was $limit.\" })\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n","package io.data2viz.color\n\n\ninternal actual fun Int.toString(radix: Int): String  = asDynamic().toString(radix)\n"],"names":[],"mappings":"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oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;IAElB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;IAElB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;IAElB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;IAElB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,wBAAuB,KAAK,qCAAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;IAElB,uBAAuB,KAAK,oCAAL,C;IACvB,uBAAuB,KAAK,oCAA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AAL,C;IACvB,sBAAkB,KAAK,yCAAL,C;EA7RtB,C;;;aCiCwF,+B;ID/BpF,C;;;;aC+BoF,+B;ID7BpF,C;;;;aC6BoF,gC;ID5BpF,C;;;;aC4BoF,gC;ID3BpF,C;;;;aC2BoF,4B;ID1BpF,C;;;;aC0BoF,0B;IDzBpF,C;;;;aCyBoF,0B;IDxBpF,C;;;;aCwBoF,4B;IDvBpF,C;;;;aCuBoF,4B;IDtBpF,C;;;;aCsBoF,yB;IDrBpF,C;;;;aCqBoF,yB;IDpBpF,C;;;;aCoBoF,yB;IDnBpF,C;;;;aCmBoF,0B;IDjBpF,C;;;;aCiBoF,0B;IDfpF,C;;;;aCeoF,0B;IDdpF,C;;;;aCcoF,0B;IDbpF,C;;;;aCaoF,0B;IDZpF,C;;;;aCYoF,0B;IDXpF,C;;;;aCWoF,0B;IDVpF,C;;;;aCUoF,2B;IDTpF,C;;;;aCSoF,2B;IDRpF,C;;;;aCQoF,yB;IDPpF,C;;;;aCOoF,0B;IDLpF,C;;;;aCKoF,0B;IDJpF,C;;;;aCIoF,0B;IDHpF,C;;;;aCGoF,0B;IDFpF,C;;;;aCEoF,0B;IDDpF,C;;;;aCCoF,0B;IDApF,C;;;;aCAoF,0B;IDCpF,C;;;;aCDoF,2B;IDEpF,C;;;;aCFoF,2B;IDGpF,C;;;;aCHoF,yB;IDIpF,C;;;;aCJoF,0B;IDMpF,C;;;;aCNoF,0B;IDOpF,C;;;;aCPoF,0B;IDQpF,C;;;;aCRoF,0B;IDSpF,C;;;;aCToF,0B;IDUpF,C;;;;aCVoF,0B;IDWpF,C;;;;aCXoF,0B;IDYpF,C;;;;aCZoF,2B;IDapF,C;;;;aCboF,2B;IDcpF,C;;;;aCdoF,yB;IDepF,C;;;;aCfoF,0B;IDiBpF,C;;;;aCjBoF,0B;IDkBpF,C;;;;aClBoF,0B;IDmBpF,C;;;;aCnBoF,0B;IDoBpF,C;;;;aCpBoF,0B;IDqBpF,C;;;;aCrBoF,0B;IDsBpF,C;;;;aCtBoF,0B;IDuBpF,C;;;;aCvBoF,2B;IDwBpF,C;;;;aCxBoF,2B;IDyBpF,C;;;;aCzBoF,yB;ID0BpF,C;;;;aC1BoF,0B;ID4BpF,C;;;;aC5BoF,0B;ID6BpF,C;;;;aC7BoF,0B;ID8BpF,C;;;;aC9BoF,0B;ID+BpF,C;;;;aC/BoF,0B;IDgCpF,C;;;;aChCoF,0B;IDiCpF,C;;;;aCjCoF,0B;IDkCpF,C;;;;aClCoF,2B;IDmCpF,C;;;;aCnCoF,2B;IDoCpF,C;;;;aCpCoF,yB;IDqCpF,C;;;;aCrCoF,0B;IDuCpF,C;;;;aCvCoF,0B;IDwCpF,C;;;;aCxCoF,0B;IDyCpF,C;;;;aCzCoF,0B;ID0CpF,C;;;;aC1CoF,0B;ID2CpF,C;;;;aC3CoF,0B;ID4CpF,C;;;;aC5CoF,0B;ID6CpF,C;;;;aC7CoF,2B;ID8CpF,C;;;;aC9CoF,2B;ID+CpF,C;;;;aC/CoF,yB;IDgDpF,C;;;;aChDoF,4B;IDkDpF,C;;;;aClDoF,4B;IDmDpF,C;;;;aCnDoF,4B;IDoDpF,C;;;;aCpDoF,4B;IDqDpF,C;;;;aCrDoF,4B;IDsDpF,C;;;;aCtDoF,4B;IDuDpF,C;;;;aCvDoF,4B;IDwDpF,C;;;;aCxDoF,6B;IDyDpF,C;;;;aCzDoF,6B;ID0DpF,C;;;;aC1DoF,2B;ID2DpF,C;;;;aC3DoF,4B;ID6DpF,C;;;;aC7DoF,4B;ID8DpF,C;;;;aC9DoF,4B;ID+DpF,C;;;;aC/DoF,4B;IDgEpF,C;;;;aChEoF,4B;IDiEpF,C;;;;aCjEoF,4B;IDkEpF,C;;;;aClEoF,4B;IDmEpF,C;;;;aCnEoF,6B;IDoEpF,C;;;;aCpEoF,6B;IDqEpF,C;;;;aCrEoF,2B;IDsEpF,C;;;;aCtEoF,8B;IDwEpF,C;;;;aCxEoF,8B;IDyEpF,C;;;;aCzEoF,8B;ID0EpF,C;;;;aC1EoF,8B;ID2EpF,C;;;;aC3EoF,8B;ID4EpF,C;;;;aC5EoF,8B;ID6EpF,C;;;;aC7EoF,8B;ID8EpF,C;;;;aC9EoF,+B;ID+EpF,C;;;;aC/EoF,+B;IDgFpF,C;;;;aChFoF,6B;IDiFpF,C;;;;aCjFoF,4B;IDmFpF,C;;;;aCnFoF,0B;IDsFpF,C;;;;aCtFoF,4B;IDuFpF,C;;;;aCvFoF,2B;IDwFpF,C;;;;aCxFoF,0B;ID0FpF,C;;;;aC1FoF,0B;ID2FpF,C;;;;aC3FoF,0B;ID4FpF,C;;;;aC5FoF,0B;ID6FpF,C;;;;aC7FoF,0B;ID8FpF,C;;;;aC9FoF,0B;ID+FpF,C;;;;aC/FoF,0B;IDgGpF,C;;;;aChGoF,yB;IDiGpF,C;;;;aCjGoF,0B;IDmGpF,C;;;;aCnGoF,0B;IDoGpF,C;;;;aCpGoF,0B;IDqGpF,C;;;;aCrGoF,0B;IDsGpF,C;;;;aCtGoF,0B;IDuGpF,C;;;;aCvGoF,0B;IDwGpF,C;;;;aCxGoF,0B;IDyGpF,C;;;;aCzGoF,yB;ID0GpF,C;;;;aC1GoF,0B;ID4GpF,C;;;;aC5GoF,0B;ID6GpF,C;;;;aC7GoF,0B;ID8GpF,C;;;;aC9GoF,0B;ID+GpF,C;;;;aC/GoF,0B;IDgHpF,C;;;;aChHoF,0B;IDiHpF,C;;;;aCjHoF,0B;IDkHpF,C;;;;aClHoF,yB;IDmHpF,C;;;;aCnHoF,0B;IDqHpF,C;;;;aCrHoF,0B;IDsHpF,C;;;;aCtHoF,0B;IDuHpF,C;;;;aCvHoF,0B;IDwHpF,C;;;;aCxHoF,0B;IDyHpF,C;;;;aCzHoF,0B;ID0HpF,C;;;;aC1HoF,0B;ID2HpF,C;;;;aC3HoF,yB;ID4HpF,C;;;;aC5HoF,0B;ID8HpF,C;;;;aC9HoF,0B;ID+HpF,C;;;;aC/HoF,0B;IDgIpF,C;;;;aChIoF,0B;IDiIpF,C;;;;aCjIoF,0B;IDkIpF,C;;;;aClIoF,0B;IDmIpF,C;;;;aCnIoF,0B;IDoIpF,C;;;;aCpIoF,yB;IDqIpF,C;;;;aCrIoF,4B;IDuIpF,C;;;;aCvIoF,4B;IDwIpF,C;;;;aCxIoF,4B;IDyIpF,C;;;;aCzIoF,4B;ID0IpF,C;;;;aC1IoF,4B;ID2IpF,C;;;;aC3IoF,4B;ID4IpF,C;;;;aC5IoF,4B;ID6IpF,C;;;;aC7IoF,2B;ID8IpF,C;;;;aC9IoF,0B;IDgJpF,C;;;;aChJoF,0B;IDiJpF,C;;;;aCjJoF,0B;IDkJpF,C;;;;aClJoF,0B;IDmJpF,C;;;;aCnJoF,0B;IDoJpF,C;;;;aCpJoF,0B;IDqJpF,C;;;;aCrJoF,0B;IDsJpF,C;;;;aCtJoF,yB;IDuJpF,C;;;;aCvJoF,0B;IDyJpF,C;;;;aCzJoF,0B;ID0JpF,C;;;;aC1JoF,0B;ID2JpF,C;;;;aC3JoF,0B;ID4JpF,C;;;;aC5JoF,0B;ID6JpF,C;;;;aC7JoF,0B;ID8JpF,C;;;;aC9JoF,0B;ID+JpF,C;;;;aC/JoF,yB;IDgKpF,C;;;;aChKoF,0B;IDkKpF,C;;;;aClKoF,0B;IDmKpF,C;;;;aCnKoF,0B;IDoKpF,C;;;;aCpKoF,0B;IDqKpF,C;;;;aCrKoF,0B;IDsKpF,C;;;;aCtKoF,0B;IDuKpF,C;;;;aCvKoF,0B;IDwKpF,C;;;;aCxKoF,yB;IDyKpF,C;;;;aCzKoF,2B;ID2KpF,C;;;;aC3KoF,2B;ID4KpF,C;;;;aC5KoF,2B;ID6KpF,C;;;;aC7KoF,2B;ID8KpF,C;;;;aC9KoF,2B;ID+KpF,C;;;;aC/KoF,2B;IDgLpF,C;;;;aChLoF,2B;IDiLpF,C;;;;aCjLoF,2B;IDkLpF,C;;;;aClLoF,2B;IDoLpF,C;;;;aCpLoF,2B;IDqLpF,C;;;;aCrLoF,2B;IDsLpF,C;;;;aCtLoF,2B;IDuLpF,C;;;;aCvLoF,2B;IDwLpF,C;;;;aCxLoF,2B;IDyLpF,C;;;;aCzLoF,2B;ID0LpF,C;;;;aC1LoF,2B;ID2LpF,C;;;;aC3LoF,2B;ID6LpF,C;;;;aC7LoF,2B;ID8LpF,C;;;;aC9LoF,2B;ID+LpF,C;;;;aC/LoF,2B;IDgMpF,C;;;;aChMoF,2B;IDiMpF,C;;;;aCjMoF,2B;IDkMpF,C;;;;aClMoF,2B;IDmMpF,C;;;;aCnMoF,2B;IDoMpF,C;;;;aCpMoF,2B;IDuMpF,C;;;;aCvMoF,2B;IDyMpF,C;;;;aCzMoF,2B;ID0MpF,C;;;;aC1MoF,2B;ID2MpF,C;;;;aC3MoF,2B;ID4MpF,C;;;;aC5MoF,2B;ID6MpF,C;;;;aC7MoF,2B;ID8MpF,C;;;;aC9MoF,yB;ID+MpF,C;;;;aC/MoF,4B;IDiNpF,C;;;;aCjNoF,4B;IDkNpF,C;;;;aClNoF,4B;IDmNpF,C;;;;aCnNoF,4B;IDoNpF,C;;;;aCpNoF,4B;IDqNpF,C;;;;aCrNoF,4B;IDsNpF,C;;;;aCtNoF,4B;IDuNpF,C;;;;aCvNoF,2B;IDwNpF,C;;;;aCxNoF,2B;ID0NpF,C;;;;aC1NoF,2B;ID2NpF,C;;;;aC3NoF,2B;ID4NpF,C;;;;aC5NoF,2B;ID6NpF,C;;;;aC7NoF,2B;ID8NpF,C;;;;aC9NoF,2B;ID+NpF,C;;;;aC/NoF,2B;IDgOpF,C;;;;aChOoF,0B;IDiOpF,C;;;;aCjOoF,6B;IDmOpF,C;;;;aCnOoF,6B;IDoOpF,C;;;;aCpOoF,6B;IDqOpF,C;;;;aCrOoF,6B;IDsOpF,C;;;;aCtOoF,6B;IDuOpF,C;;;;aCvOoF,6B;IDwOpF,C;;;;aCxOoF,6B;IDyOpF,C;;;;aCzOoF,4B;ID0OpF,C;;;;aC1OoF,6B;ID4OpF,C;;;;aC5OoF,6B;ID6OpF,C;;;;aC7OoF,6B;ID8OpF,C;;;;aC9OoF,6B;ID+OpF,C;;;;aC/OoF,6B;IDgPpF,C;;;;aChPoF,6B;IDiPpF,C;;;;aCjPoF,6B;IDkPpF,C;;;;aClPoF,4B;IDmPpF,C;;;;aCnPoF,0B;IDqPpF,C;;;;aCrPoF,0B;IDsPpF,C;;;;aCtPoF,0B;IDuPpF,C;;;;aCvPoF,0B;IDwPpF,C;;;;aCxPoF,0B;IDyPpF,C;;;;aCzPoF,0B;ID0PpF,C;;;;aC1PoF,0B;ID2PpF,C;;;;aC3PoF,yB;ID4PpF,C;;;IA1RyB,yBAAc,8DAAd,C;EAA8E,C;;IAC9E,yBAAc,0HAAd,C;EAA0I,C;;IACzI,yBAAc,0HAAd,C;EAA0I,C;;IAC1I,yBAAc,0HAAd,C;EAA0I,C;;IAC9I,yBAAc,kDAAd,C;EAAkE,C;;IACpE,yBAAc,kDAAd,C;EAAkE,C;;IACjE,yBAAc,0EAAd,C;EAA0F,C;;IACzF,yBAAc,wDAAd,C;EAAwE,C;;IACxE,yBAAc,kDAAd,C;EAAkE,C;;IACrE,yBAAc,wDAAd,C;EAAwE,C;;IACxE,yBAAc,kDAAd,C;EAAkE,C;;IAClE,yBAAc,0EAAd,C;EAA0F,C;;IAG/E,yBAAc,oBAAd,C;EAAwF,C;;IACxF,yBAAc,0BAAd,C;EAAwF,C;;IACxF,yBAAc,gCAAd,C;EAAwF,C;;IACxF,yBAAc,sCAAd,C;EAAwF,C;;IACxF,yBAAc,4CAAd,C;EAAwF,C;;IACxF,yBAAc,kDAAd,C;EA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"}