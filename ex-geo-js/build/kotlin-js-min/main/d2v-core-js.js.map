{"version":3,"file":"d2v-core-js.js","sources":["../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/CircleGeom.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Extent.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Path.kt","collections/Collections.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/PathGeom.kt","collections/MutableCollections.kt","util/Preconditions.kt","util/Standard.kt","kotlin/math.kt","generated/_Collections.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Point.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Polygon.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Rect.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/RectGeom.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Size.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/geom/Vector.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/math/Angle.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/math/Matrix.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/math/Percent.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/math/ticks.kt","util/Lazy.kt","generated/_ComparisonsJs.kt","../../../../../d2v-core-common/src/main/kotlin/io/data2viz/math/Constants.kt"],"sourcesContent":["package io.data2viz.geom\n\nclass CircleGeom: Circle {\n    override var x: Double = .0\n    override var y: Double = .0\n    override var radius: Double = .0\n}","package io.data2viz.geom\n\n\n/**\n * Todo this is really representing a rectangle. Is there a reason to name it Extent.\n * Todo make it immutable (data class)\n */\nclass Extent(var x0: Double, var y0: Double, var x1: Double, var y1: Double) {\n    var width\n        get() = x1 - x0\n        set(value) {\n            x0 = .0\n            x1 = value\n        }\n\n    var height\n        get() = y1 - y0\n        set(value) {\n            y0 = .0\n            y1 = value\n        }\n\n    fun copy(): Extent {\n        return Extent(x0, y0, x1, y1)\n    }\n}","package io.data2viz.geom\n\n\n/**\n * Common path denominator between Canvas, SVG, JavaFX, Android\n */\ninterface Path {\n    fun moveTo(x: Double, y: Double)\n    fun lineTo(x: Double, y: Double)\n    fun closePath()\n    fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double)\n    fun bezierCurveTo(cpx1: Double, cpy1: Double, cpx2: Double, cpy2: Double, x: Double, y: Double)\n    fun arcTo(cpx: Double, cpy: Double, x: Double, y: Double, radius: Double)\n\n    /**\n     * HTML CANVAS STANDARDS:\n     *\n     * Given x, y, radiusX, radiusY, rotation, startAngle, endAngle, and counterClockWise:\n     *\n     * TODO : check this before sending arguments to canvas? (then remove this doc line)\n     * - If any of the arguments are infinite, then return.\n     *\n     * SPECIAL CASE OF ANGLE GREATER THAN 2\u03c0:\n     * - If anticlockwise is false and endAngle-startAngle is equal to or greater than 2\u03c0, or, if anticlockwise is true\n     * and startAngle-endAngle is equal to or greater than 2\u03c0, then the arc is the whole circumference of the circle,\n     * and the point at startAngle along this circle's circumference, measured in radians acts as both the start point\n     * and the end point.\n     *\n     * - Otherwise, the points at startAngle and endAngle along this circle's circumference, measured in radians\n     * clockwise from the ellipse's semi-major axis, are the start and end points respectively, and the arc is the\n     * path along the circumference of this ellipse from the start point to the end point, going anti-clockwise if\n     * anticlockwise is true, and clockwise otherwise. Since the points are on the circle, as opposed to being simply\n     * angles from zero, the arc can never cover an angle greater than 2\u03c0 radians.\n     */\n    fun arc(\n        centerX: Double,\n        centerY: Double,\n        radius: Double,\n        startAngle: Double,\n        endAngle: Double,\n        counterClockWise: Boolean = false\n    )\n\n    @Deprecated(\"To be discussed: should it be available in addition to Rect class?\")\n    fun rect(x: Double, y: Double, w: Double, h: Double)\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package io.data2viz.geom\n\nimport io.data2viz.math.EPSILON\nimport io.data2viz.math.TAU\nimport io.data2viz.math.TAU_EPSILON\nimport kotlin.math.*\n\n\nclass PathGeom : Path {\n\n    val commands = mutableListOf<PathCommand>()\n\n    fun clearPath() {\n        commands.clear()\n    }\n\n    override fun moveTo(x: Double, y: Double) {\n        commands += MoveTo(x, y)\n    }\n\n    override fun lineTo(x: Double, y: Double) {\n        commands += LineTo(x, y)\n    }\n\n    override fun closePath() {\n        commands += ClosePath()\n    }\n\n    override fun quadraticCurveTo(cpx: Double, cpy: Double, x: Double, y: Double) {\n        commands += QuadraticCurveTo(cpx, cpy, x, y)\n    }\n\n    override fun bezierCurveTo(cpx1: Double, cpy1: Double, cpx2: Double, cpy2: Double, x: Double, y: Double) {\n        commands += BezierCurveTo(cpx1, cpy1, cpx2, cpy2, x, y)\n    }\n\n    override fun arcTo(cpx: Double, cpy: Double, x: Double, y: Double, radius: Double) {\n        require(radius >= .0) { \"Negative radius:$radius\" }\n        commands += ArcTo(cpx, cpy, x, y, radius)\n    }\n\n    override fun arc(\n        centerX: Double,\n        centerY: Double,\n        radius: Double,\n        startAngle: Double,\n        endAngle: Double,\n        counterClockWise: Boolean\n    ) {\n        require(radius >= .0) { \"Negative radius:$radius\" }\n        commands += Arc(centerX, centerY, radius, startAngle, endAngle, counterClockWise)\n    }\n\n    override fun rect(x: Double, y: Double, w: Double, h: Double) {\n        commands += RectCmd(x, y, w, h)\n    }\n}\n\n\n//Todo use sealed class\n\ninterface PathCommand {\n    val x: Double\n    val y: Double\n}\n\ndata class MoveTo(override val x: Double, override val y: Double) : PathCommand\ndata class LineTo(override val x: Double, override val y: Double) : PathCommand\ndata class RectCmd(override val x: Double, override val y: Double, val w: Double, val h: Double) : PathCommand\ndata class QuadraticCurveTo(val cpx: Double, val cpy: Double, override val x: Double, override val y: Double) :\n    PathCommand\n\ndata class BezierCurveTo(\n    val cpx1: Double,\n    val cpy1: Double,\n    val cpx2: Double,\n    val cpy2: Double,\n    override val x: Double,\n    override val y: Double\n) :\n    PathCommand\n\ndata class Arc(\n    val centerX: Double,\n    val centerY: Double,\n    val radius: Double,\n    val startAngle: Double,\n    val endAngle: Double,\n    val counterClockWise: Boolean\n) : PathCommand {\n    override val x: Double\n        get() = TODO(\"not implemented\")\n    override val y: Double\n        get() = TODO(\"not implemented\")\n}\n\ndata class ArcTo(\n    val fromX: Double,\n    val fromY: Double,\n    override val x: Double,\n    override val y: Double,\n    val radius: Double\n) :\n    PathCommand\n\nclass ClosePath : PathCommand {\n    override val x: Double\n        get() = .0\n    override val y: Double\n        get() = .0\n}\n\nval PathGeom.svgPath: String\n    get() {\n        var tempX0 = 0.0\n        var tempY0 = 0.0\n        var tempX1: Double? = null\n        var tempY1: Double? = null\n        val sb = StringBuilder()\n\n        commands.forEach { cmd ->\n            when (cmd) {\n                is MoveTo -> {\n                    tempX0 = cmd.x\n                    tempY0 = cmd.y\n                    tempX1 = cmd.x\n                    tempY1 = cmd.y\n                    sb.append(\"M${cmd.x},${cmd.y}\")\n                }\n\n                is LineTo -> {\n                    tempX1 = cmd.x\n                    tempY1 = cmd.y\n                    sb.append(\"L${cmd.x},${cmd.y}\")\n                }\n\n                is ClosePath -> {\n                    if (tempX1 != null) {\n                        tempX1 = tempX0\n                        tempY1 = tempY0\n                        sb.append(\"Z\")\n                    }\n                }\n\n                is QuadraticCurveTo -> {\n                    tempX1 = cmd.x\n                    tempY1 = cmd.y\n                    sb.append(\"Q${cmd.cpx},${cmd.cpy},${cmd.x},${cmd.y}\")\n                }\n\n                is RectCmd -> {\n                    tempX0 = cmd.x\n                    tempX1 = cmd.x\n                    tempY0 = cmd.y\n                    tempY1 = cmd.y\n                    sb.append(\"M${cmd.x},${cmd.y}h${cmd.w}v${cmd.h}h${-cmd.w}Z\")\n                }\n\n                is BezierCurveTo -> {\n                    tempX1 = cmd.x\n                    tempY1 = cmd.y\n                    sb.append(\"C${cmd.cpx1},${cmd.cpy1},${cmd.cpx2},${cmd.cpy2},${cmd.x},${cmd.y}\")\n\n                }\n\n                is ArcTo -> {\n                    val X0 = tempX1 ?: .0\n                    val Y0 = tempY1 ?: .0\n\n                    val x21 = cmd.x - cmd.fromX\n                    val y21 = cmd.y - cmd.fromY\n                    val x01 = X0 - cmd.fromX\n                    val y01 = Y0 - cmd.fromY\n                    val l01_2 = x01 * x01 + y01 * y01\n\n                    with(tempX1) {\n                        //path is empty, introduce private function?\n                        if (this == null) {\n                            // Is this path empty? Move to (x1,y1).\n                            tempX1 = cmd.fromX\n                            tempY1 = cmd.fromY\n                            sb.append(\"M${cmd.fromX},${cmd.fromY}\")\n                        }\n                        // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.\n                        else if (l01_2 <= EPSILON) {\n                        }\n\n                        // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?\n                        // Equivalently, is (x1,y1) coincident with (x2,y2)?\n                        // Or, is the radius zero? Line to (x1,y1).\n                        else if (abs(y01 * x21 - y21 * x01) <= EPSILON || cmd.radius == .0) {\n                            tempX1 = cmd.fromX\n                            tempY1 = cmd.fromY\n                            sb.append(\"L${cmd.fromX},${cmd.fromY}\")\n                        }\n\n                        // Otherwise, draw an arc!\n                        else {\n                            val x20 = cmd.x - X0\n                            val y20 = cmd.y - Y0\n                            val l21_2 = x21 * x21 + y21 * y21\n                            val l20_2 = x20 * x20 + y20 * y20\n                            val l21 = sqrt(l21_2)\n                            val l01 = sqrt(l01_2)\n                            val l = cmd.radius * tan((PI - acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2)\n                            val t01 = l / l01\n                            val t21 = l / l21\n\n                            // If the start tangent is not coincident with (x0,y0), line to.\n                            if (abs(t01 - 1) > EPSILON) {\n                                sb.append(\"L${cmd.fromX + t01 * x01},${cmd.fromY + t01 * y01}\")\n                            }\n\n                            tempX1 = cmd.fromX + t21 * x21\n                            tempY1 = cmd.fromY + t21 * y21\n                            val yes = if (y01 * x20 > x01 * y20) 1 else 0\n                            sb.append(\"A${cmd.radius},${cmd.radius},0,0,$yes,${tempX1},${tempY1}\")\n                        }\n                    }\n                }\n\n                is Arc -> {\n                    val dx = cmd.radius * cos(cmd.startAngle)\n                    val dy = cmd.radius * sin(cmd.startAngle)\n                    val x0 = cmd.centerX + dx\n                    val y0 = cmd.centerY + dy\n                    val cw = if (cmd.counterClockWise) 0 else 1\n                    var da = if (cmd.counterClockWise) cmd.startAngle - cmd.endAngle else cmd.endAngle - cmd.startAngle\n\n                    with(tempX1) {\n\n                        //path is empty, introduce private function?\n                        if (this == null) {\n                            sb.append(\"M$x0,$y0\")\n                        } else if (abs(this.toDouble() - x0) > EPSILON || abs(\n                                tempY1!!.toDouble() - y0\n                            ) > EPSILON\n                        ) {\n                            sb.append(\"L$x0,$y0\")\n                        } else {\n                        }\n                    }\n\n                    if (cmd.radius < EPSILON) return@forEach\n\n                    if (da < 0) da = da % TAU + TAU\n\n                    //complete circle\n                    if (da > TAU_EPSILON) {\n                        tempX1 = x0\n                        tempY1 = y0\n                        sb.append(\"A${cmd.radius},${cmd.radius},0,1,$cw,${cmd.centerX - dx},${cmd.centerY - dy}A${cmd.radius},${cmd.radius},0,1,$cw,$x0,$y0\")\n                    }\n\n                    // Is this arc non-empty? Draw an arc!\n                    else if (da > EPSILON) {\n                        tempX1 = cmd.centerX + cmd.radius * cos(cmd.endAngle)\n                        tempY1 = cmd.centerY + cmd.radius * sin(cmd.endAngle)\n                        sb.append(\"A${cmd.radius},${cmd.radius},0,${if (da >= PI) 1 else 0},$cw,$tempX1,$tempY1\")\n                    }\n                }\n            }\n        }\n        return sb.toString()\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.toHashSet())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.toHashSet())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.toHashSet()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n/**\n * Randomly shuffles elements in this mutable list using the specified [random] instance as the source of randomness.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n\n\n\n// ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package io.data2viz.geom\n\n/**\n * Creates a point.\n */\nfun point(x: Double, y: Double) = Point(x, y)\n\n/**\n * Creates a point from Ints.\n */\nfun point(x: Int, y: Int) = Point(x.toDouble(), y.toDouble())\n\ndata class Point(val x: Double = 0.0, val y: Double = 0.0) {\n\n    companion object {\n        val origin = Point()\n    }\n    operator fun plus(vector: Vector) = Point(x + vector.vx, y + vector.vy)\n    operator fun plus(other: Point) = Point(x + other.x, y + other.y)\n    operator fun minus(other: Point) = Point(x - other.x, y - other.y)\n    operator fun div(value:Number) = Point(x / value.toDouble(), y / value.toDouble())\n    operator fun times(value:Number) = Point(x * value.toDouble(), y * value.toDouble())\n\n    operator fun unaryMinus(): Point = Point(-x, -y)\n}","package io.data2viz.geom\n\nimport kotlin.math.sqrt\n\ndata class Polygon(val points: List<Point>)\n\n/**\n * Returns the signed area of the polygon. If the vertices of the polygon are in counterclockwise order\n * (assuming a coordinate system where the origin \u27e80,0\u27e9 is in the top-left corner), the returned area is positive;\n * otherwise it is negative, or zero.\n */\nval Polygon.area: Double\n    get() {\n        var i = -1\n        val size = points.size\n        var b = points.last()\n        var area = .0\n\n        while (++i < size) {\n            val a = b\n            b = points[i]\n            area += a.y * b.x - a.x * b.y\n        }\n        return area / 2\n    }\n\n/**\n * Returns the centroid of the polygon.\n */\nval Polygon.centroid: Point\n    get() {\n        var i = -1\n        val size = points.size\n        var x = .0\n        var y = .0\n        var b = points.last()\n        var k = .0\n\n        while (++i < size) {\n            val a = b\n            b = points[i]\n            val c = a.x * b.y - b.x * a.y\n            k += c\n            x += (a.x + b.x) * c\n            y += (a.y + b.y) * c\n        }\n\n        k *= 3.0\n        return Point(x / k, y / k)\n    }\n\n/**\n * Returns the length of the perimeter of the specified polygon.\n */\nval Polygon.length: Double\n    get() {\n        var i = -1\n        val size = points.size\n        var b = points.last()\n        var xb = b.x\n        var yb = b.y\n        var perimeter = .0\n\n        while (++i < size) {\n            var xa = xb\n            var ya = yb\n            b = points[i]\n            xb = b.x\n            yb = b.y\n            xa -= xb\n            ya -= yb\n            perimeter += sqrt(xa * xa + ya * ya)\n        }\n\n        return perimeter\n    }\n\n/**\n * Returns true if and only if the specified point is inside the polygon.\n */\nfun Polygon.contains(point: Point): Boolean {\n    val size = points.size\n    var p = points.last()\n    val x = point.x\n    val y = point.y\n    var x0 = p.x\n    var y0 = p.y\n    var inside = false\n\n    (0 until size).forEach { i ->\n        p = points[i]\n        val x1 = p.x\n        val y1 = p.y\n        if (((y1 > y) != (y0 > y)) && (x < (x0 - x1) * (y - y1) / (y0 - y1) + x1)) inside = !inside\n        x0 = x1\n        y0 = y1\n    }\n\n    return inside\n}\n\n/**\n * Returns the Polygon convex hull of the specified points using Andrew\u2019s monotone chain algorithm.\n * The returned hull is represented as a Polygon containing a subset of the input points arranged in counterclockwise\n * order.\n * Returns null if points has fewer than three elements.\n */\nfun polygonHull(points: List<Point>): Polygon {\n    val size = points.size\n    require(size > 2) {\"A polygon must have at least 3 points\"}\n\n\n    data class PointIndex(val point: Point, val index: Int)\n\n    val sortedPoints = mutableListOf<PointIndex>()\n    val flippedPoints = mutableListOf<Point>()\n\n    (0 until size).forEach { i -> sortedPoints.add(PointIndex(points[i], i)) }\n    sortedPoints.sortWith(compareBy({ it.point.x }, { it.point.y }))\n\n    (0 until size).forEach { i -> flippedPoints.add(Point(sortedPoints[i].point.x, -sortedPoints[i].point.y)) }\n\n    val upperIndexes = computeUpperHullIndexes(sortedPoints.map { it.point })\n    val lowerIndexes = computeUpperHullIndexes(flippedPoints)\n\n    // Construct the hull polygon, removing possible duplicate endpoints.\n    val skipLeft = lowerIndexes[0] == upperIndexes[0]\n    val skipRight = lowerIndexes[lowerIndexes.size - 1] == upperIndexes[upperIndexes.size - 1]\n    val hull = mutableListOf<Point>()\n\n    // Add upper hull in right-to-left order.\n    // Then add lower hull in left-to-right order.\n    (upperIndexes.lastIndex downTo 0).forEach { i -> hull.add(points[sortedPoints[upperIndexes[i]].index]) }\n\n    val start = if (skipLeft) 1 else 0\n    val end = if (skipRight) 1 else 0\n    (start until lowerIndexes.size - end).forEach { i -> hull.add(points[sortedPoints[lowerIndexes[i]].index]) }\n\n    return Polygon(hull)\n}\n\n/**\n * Computes the upper convex hull per the monotone chain algorithm.\n * Assumes points.length >= 3, is sorted by x, unique in y.\n * Returns an array of indices into points in left-to-right order.\n */\nprivate fun computeUpperHullIndexes(points: List<Point>): List<Int> {\n    val indexes = MutableList(points.size, { 0 })\n    indexes[1] = 1\n    var size = 2\n\n    (2 until points.size).forEach { i ->\n        while (size > 1 && cross(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size\n        if (size < indexes.lastIndex) indexes[size] = i else indexes.add(i)\n        size++\n    }\n\n    return indexes.subList(0, size)      // remove popped points\n}\n\n/**\n * Returns the 2D cross product of AB and AC vectors, i.e., the z-component of the 3D cross product in a\n * quadrant I Cartesian coordinate system (+x is right, +y is up).\n * Returns a positive value if ABC is counter-clockwise, negative if clockwise, and zero if the points are collinear.\n */\nprivate fun cross(a: Point, b: Point, c: Point): Double {\n    return ((b.x - a.x) * (c.y - a.y)) - ((b.y - a.y) * (c.x - a.x))\n}\n","package io.data2viz.geom\n\ninterface Rect: HasSize {\n\n\tvar x: Double\n\tvar y: Double\n\n\tval top\n\t\tget() = y\n\n\tval bottom\n\t\tget() = y + height\n\n\tval left\n\t\tget() = x\n\n\tval right\n\t\tget() = x + width\n\n\tval topLeft:Point\n\t\tget() = Point(x, y)\n\n\tval topRight:Point\n\t\tget() = Point(x + width, y)\n\n\tval bottomLeft:Point\n\t\tget() = Point(x, y + height)\n\n\tval bottomRight:Point\n\t\tget() = Point(x + width, y + height)\n\n\tval center: Point\n\t\tget() = Point(x + .5 * width, y + .5 * height)\n\n\toperator fun contains(point: Point):Boolean {\n\t\tval x = point.x\n\t\tval y = point.y\n\t\treturn x >= this.x && y >= this.y\n\t\t\t\t&& x <= this.x + this.width\n\t\t\t\t&& y <= this.y + this.height\n\t}\n\n\toperator fun contains(rect: Rect):Boolean {\n\t\tval x = rect.x\n\t\tval y = rect.y\n\t\treturn x >= this.x && y >= this.y\n                && x + rect.width <= this.x + this.width\n                && y + rect.height <= this.y + this.height\n\t}\n\n}","package io.data2viz.geom\n\nimport kotlin.math.absoluteValue\nimport kotlin.math.min\n\n\ndata class RectGeom(\n        override var x: Double = .0,\n        override var y: Double = .0,\n        override var width: Double = .0,\n        override var height: Double = .0) : Rect {\n\n    constructor(point: Point, size: Size): this(point.x, point.y, size.width, size.height)\n    constructor(from: Point, to: Point):\n            this(\n                    min(from.x, to.x)\n                    ,min(from.y, to.y),\n                    (to.x - from.x).absoluteValue,\n                    (to.y - from.y).absoluteValue)\n\n\n\n}\n\n","package io.data2viz.geom\n\n/**\n * Creates a size.\n */\nfun size(x: Double, y: Double) = Size(x, y)\n\n/**\n * Creates a size from Ints.\n */\nfun size(x: Int, y: Int) = Size(x.toDouble(), y.toDouble())\n\n/**\n * Size represents a rectangle dimension. The second parameter of the constructor (height)\n * is option and takes by default the same value as the width.\n */\ndata class Size(val width: Double, val height: Double = width) {\n\n    operator fun plus(value: Double): Size  = Size(width + value, height + value)\n    operator fun minus(value: Double): Size = Size(width - value, height - value)\n    operator fun times(value: Double): Size = Size(width * value, height * value)\n    operator fun div(value: Double): Size   = Size(width / value, height / value)\n    operator fun rem(value: Double): Size   = Size(width % value, height % value)\n\n    operator fun plus(size: Size): Size     = Size(width + size.width, height + size.height)\n    operator fun minus(size: Size): Size    = Size(width - size.width, height - size.height)\n    operator fun times(size: Size): Size    = Size(width * size.width, height * size.height)\n    operator fun div(size: Size): Size      = Size(width / size.width, height / size.height)\n    operator fun rem(size: Size): Size      = Size(width % size.width, height % size.height)\n}\n\n/**\n * Indicates a class that has a width and a height. Adds an size property to\n * set and get width and height in a single line.\n */\ninterface HasSize {\n\n    var width: Double\n    var height: Double\n\n    var size:Size\n        get() = Size(width, height)\n        set(value) {\n            width = value.width\n            height = value.height\n        }\n}","package io.data2viz.geom\n\n\ndata class Vector(val vx: Double = 0.0, val vy: Double = 0.0) {\n    operator fun plus(vector: Vector) = Vector(vx + vector.vx, vy + vector.vy)\n    operator fun minus(vector: Vector) = Vector(vx - vector.vx, vy - vector.vy)\n}","package io.data2viz.math\n\nimport kotlin.math.cos\nimport kotlin.math.sin\nimport kotlin.math.tan\n\n/**\n * Abstraction of an angle to have some more typesafe angle manipulations.\n */\ninline class Angle(val rad: Double){\n    val cos:Double get() = cos(rad)\n    val sin:Double get() = sin(rad)\n    val tan:Double get() = tan(rad)\n    val deg:Double get() = rad * RAD_TO_DEG\n\n    fun normalize():Angle =\n            if (rad >= 0) Angle(rad % TAU_ANGLE.rad)\n            else Angle((rad % TAU_ANGLE.rad) + TAU_ANGLE.rad)\n\n    operator fun plus(angle: Angle)     = Angle(rad + angle.rad)\n    operator fun minus(angle: Angle)    = Angle(rad - angle.rad)\n    operator fun times(d: Number)       = Angle(rad * d.toDouble())\n    operator fun div(d: Number)         = Angle(rad / d.toDouble())\n    operator fun div(other: Angle)      = rad / other.rad\n    operator fun unaryMinus() = Angle(-rad)\n\n}\n\n\n/**\n * Assuming this represents a value in degrees, converts the value to radians.\n */\nfun Double.toRadians() = this * DEG_TO_RAD\n\n/**\n * Assuming this represents a value in radians, converts the value to degrees.\n */\nfun Double.toDegrees() = this * RAD_TO_DEG\n\n/**\n * Extension property to create easily an angle from a number representing degrees\n */\nval Number.deg:Angle\n    get() = Angle(toDouble() * DEG_TO_RAD)\n\n/**\n * Extension property to create easily an angle from a number representing radians\n */\nval Number.rad:Angle\n    get() = Angle(toDouble())\n\n\n/**\n * Extension function operator on Number to allow 2 * PI.rad\n */\noperator fun Number.times(angle: Angle) = Angle(angle.rad * this.toDouble())\n","package io.data2viz.math\n\nimport io.data2viz.geom.*\n\n/**\n * An affine transformation matrix performs a linear mapping from 2D\n * coordinates to other 2D coordinates that preserves the \"straightness\" and\n * \"parallelness\" of lines.\n *\n * Such a coordinate transformation can be represented by a 3 row by 3\n * column matrix with an implied last row of `[ 0 0 1 ]`. This matrix\n * transforms source coordinates `(x, y)` into destination coordinates `(x',y')`\n * by considering them to be a column vector and multiplying the coordinate\n * vector by the matrix according to the following process:\n *\n *     [ x ]   [ a  c  tx ] [ x ]   [ a * x + c * y + tx ]\n *     [ y ] = [ b  d  ty ] [ y ] = [ b * x + d * y + ty ]\n *     [ 1 ]   [ 0  0  1  ] [ 1 ]   [         1          ]\n *\n * Note the locations of b and c.\n *\n * This class is optimized for speed and minimizes calculations based on its\n * knowledge of the underlying matrix (as opposed to say simply performing\n * matrix multiplication).\n *\n * todo should we accept non invertible matrix (scale = .0 or infinite transformation params)?\n * https://math.stackexchange.com/questions/2875241/what-does-a-non-invertible-affine-transformation-look-like-geometrically-in-term\n *\n * todo make it immutable?\n */\ndata class Matrix(\n    internal var a: Double = 1.0,\n    internal var b: Double = 0.0,\n    internal var c: Double = 0.0,\n    internal var d: Double = 1.0,\n    internal var tx: Double = 0.0,\n    internal var ty: Double = 0.0\n) {\n\n    /**\n     * Change transformation parameters to make the transformation an identity.\n     */\n    fun reset(): Matrix {\n        a = 1.0\n        d = 1.0\n        b = .0\n        c = .0\n        tx = .0\n        ty = .0\n        return this\n    }\n\n    fun isIdentity() = (a == 1.0\n                    && b == .0\n                    && c == .0\n                    && d == 1.0\n                    && tx == .0\n                    && ty == .0)\n\n\n    /**\n     * Appends the specified matrix to this matrix. This is the equivalent of\n     * multiplying `(this matrix) * (specified matrix)`.\n     *\n     * @param {Matrix} matrix the matrix to append\n     * @return {Matrix} this matrix, modified\n     */\n    fun append (other: Matrix): Matrix {\n        val a1 = a\n        val b1 = b\n        val c1 = c\n        val d1 = d\n        val a2 = other.a\n        val b2 = other.b\n        val c2 = other.c\n        val d2 = other.d\n        val tx2 = other.tx\n        val ty2 = other.ty\n\n        a = a2 * a1 + c2 * c1\n        c = b2 * a1 + d2 * c1\n        b = a2 * b1 + c2 * d1\n        d = b2 * b1 + d2 * d1\n        tx += tx2 * a1 + ty2 * c1\n        ty += tx2 * b1 + ty2 * d1\n        return this\n    }\n\n    /**\n     * Prepends the specified matrix to this matrix. This is the equivalent of\n     * multiplying `(specified matrix) * (this matrix)`.\n     *\n     * @param {Matrix} matrix the matrix to prepend\n     * @return {Matrix} this matrix, modified\n     */\n    fun prepend(mx: Matrix): Matrix {\n            val a1 = a\n            val b1 = b\n            val c1 = c\n            val d1 = d\n            val tx1 = tx\n            val ty1 = ty\n            val a2 = mx.a\n            val b2 = mx.c\n            val c2 = mx.b\n            val d2 = mx.d\n            val tx2 = mx.tx\n            val ty2 = mx.ty\n            a = a2 * a1 + b2 * b1\n            c = a2 * c1 + b2 * d1\n            b = c2 * a1 + d2 * b1\n            d = c2 * c1 + d2 * d1\n            tx = a2 * tx1 + b2 * ty1 + tx2\n            ty = c2 * tx1 + d2 * ty1 + ty2\n        return this\n    }\n\n    /**\n     * Add a translation to the current transformation.\n     */\n    fun translate(pt: Point) = translate(pt.x, pt.y)\n\n    /**\n     * Add a translation to the current transformation.\n     */\n    fun translate(x: Double, y: Double): Matrix {\n        tx += x * a + y * c\n        ty += x * b + y * d\n        return this\n    }\n\n    /**\n     * Add a scale transformation to the current one, using the same scale\n     * factor for X and Y and an optional point f\n     */\n    fun scale(scaleXY: Double, center: Point? = null) = scale(scaleXY, scaleXY, center)\n\n    /**\n     * Add a scale transformation to the current one, using the same scale\n     * factor for X and Y\n     */\n    fun scale(scaleX: Double, scaleY: Double, center: Point? = null): Matrix {\n\n        require(scaleX != .0) { \"$scaleX should be different than 0.0 to ensure the matrix is invertible \"}\n        require(scaleY != .0) { \"$scaleY should be different than 0.0 to ensure the matrix is invertible \"}\n\n        center?.let {\n            translate(it)\n        }\n        a *= scaleX\n        b *= scaleX\n        c *= scaleY\n        d *= scaleY\n        center?.let {\n            translate(-it)\n        }\n        return this\n    }\n\n    /**\n     * Add a rotation to the current transformation. The rotation is done\n     * using the optional center point as pivot. Without a center parameter,\n     * the rotation uses the\n     */\n    fun rotate(angle: Angle, center: Point? = null): Matrix {\n        val cos = angle.cos\n        val sin = angle.sin\n        val tempA = a\n        val tempB = b\n        val tempC = c\n        val tempD = d\n\n        a = cos * tempA + sin * tempC\n        b = cos * tempB + sin * tempD\n        c = -sin * tempA + cos * tempC\n        d = -sin * tempB + cos * tempD\n\n        center?.let {\n            val x = it.x\n            val y = it.y\n            val tempTx = x - x * cos + y * sin\n            val tempTy = y - x * sin - y * cos\n            tx += tempTx * tempA + tempTy * tempC\n            ty += tempTx * tempB + tempTy * tempD\n        }\n        return this\n    }\n\n    /**\n     * Apply the current transformation matrix to a point.\n     * @return the point coordinates after apply the transformation.\n     */\n    fun transform(point: Point) = point(\n        point.x * a + point.y * c + tx,\n        point.x * b + point.y * d + ty\n    )\n\n    /**\n     * Apply the inverse transformations\n     * @return the point coordinates after apply the inverse transformation.\n     */\n    fun inverseTransform(point: Point):Point {\n        //matrix should always be invertible\n        val x = point.x - tx\n        val y = point.y - ty\n        val det = a * d  - b * c\n        return point(\n            (x * d - y * c) / det,\n            (y * a - x * b) / det)\n    }\n\n    /**\n     * Checks whether the matrix is invertible. A matrix is not invertible if\n     * the determinant is 0 or any value is infinite or NaN.\n     *\n     * @return {Boolean} whether the matrix is invertible\n     */\n    inline internal fun isInvertible(): Boolean{\n        val det = a * d - c * b\n        return det != .0\n                && !det.isNaN()\n                && tx.isFinite()\n                && ty.isFinite()\n    }\n}","package io.data2viz.math\n\n\n/**\n * Utility class used to represent a percentage value.\n * You can create a Percent using the default constructor:\n *  - val p = Percent(0.15)             // 15%\n *\n *  But it is easier to do so using the extension value \".pct\":\n *  - val p = 15.pct                    //15%\n */\ninline class Percent(val value:Double) {\n\n    operator fun plus(other: Percent)       = Percent(value + other.value)\n    operator fun minus(other: Percent)      = Percent(value - other.value)\n    operator fun times(other: Percent)      = Percent(value * other.value)\n    operator fun div(d: Number)             = Percent(value / d.toDouble())\n\n    /**\n     * Operator to allow to write `20.pct * 3` (= 0.6)\n     */\n    operator fun times(d: Number)           = value * d.toDouble()\n    operator fun unaryMinus()               = Percent(-value)\n\n    operator fun unaryPlus()                = this\n    operator fun compareTo(other:Percent)   = this.value.compareTo(other.value)\n\n\n    /**\n     * Ensures that this percent is not less than the specified min.\n     * @return this percent if it's greater than or equal to the min or the min otherwise.\n     */\n    fun coerceAtLeast(min:Percent)          = Percent(value.coerceAtLeast(min.value))\n\n    /**\n     * Ensures that this percent is not greater than the specified max.\n     * @return this percent if it's less than or equal to the max or the max otherwise.\n     */\n    fun coerceAtMost(max:Percent)           = Percent(value.coerceAtMost(max.value))\n\n    /**\n     * Ensures that this percent lies in the specified range min..max.\n     *\n     * @return this value if it's in the range, or minimumValue if this value is less than minimumValue,\n     * or maximumValue if this value is greater than maximumValue.\n     */\n    fun coerceIn(min:Percent, max:Percent)  = Percent(value.coerceIn(min.value, max.value))\n\n    /**\n     * if > 100% returns 100%,\n     * if < 0% returns 0%,\n     * else return the current value.\n     */\n    fun coerceToDefault(): Percent          = Percent(value.coerceIn(.0, 1.0))                  // TODO: rename ?\n\n\n    override fun toString(): String = \"${value*100}%\"\n}\n\n/**\n * Extension property to create a percent from any number.\n */\nval Number.pct:Percent\n    get() = Percent(toDouble() / 100.0)\n\n/**\n * Extension operator to allow to write `3 * 20.pct` (= 0.6)\n */\noperator fun Number.times(percent:Percent) = percent.value * toDouble()","package io.data2viz.math\n\nimport kotlin.math.*\n\nval e10 = sqrt(50.0)\nval e5 = sqrt(10.0)\nval e2 = sqrt(2.0)\nval ln10:Double by lazy { ln(10.0) }\n\nfun ticks(start:Number, stop: Number, count :Int): List<Double> {\n    // require(count > 0, { \"Ticks count must be greater than 0.\" }) // TODO check or return empty array ?\n    val step = tickStep(start.toDouble(), stop.toDouble(), count)\n    return range(\n            ceil(start.toDouble() / step) * step,\n            floor(stop.toDouble() / step) * step + step / 2, // inclusive\n            step\n    )\n}\n\nfun tickStep(start:Double, stop:Double, count:Int): Double {\n    val step0 = abs(stop -start) / count\n    var step1 = 10.0.pow(floor(ln(step0) / ln10))\n    val error = step0 / step1\n    if(error >= e10) step1 *=10\n    else if(error >= e5) step1 *=5\n    else if(error >= e2) step1 *=2\n    return if (stop < start) -step1 else step1\n}\n\nfun range (start:Double, stop:Double, step: Double = 1.0): List<Double> {\n    val n = maxOf(0, ceil((stop - start) / step).toInt())\n    return  (0..n-1).map { start + it*step }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\n\n/**\n * Returns the greater of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return Math.max(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return Math.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return Math.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return Math.max(a, b, c)\n}\n\n/**\n * Returns the smaller of two values.\n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return Math.min(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"DEPRECATION_ERROR\", \"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return Math.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return Math.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return Math.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION_ERROR\")\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return Math.min(a, b, c)\n}\n\n","package io.data2viz.math\n\n\n\nconst val EPSILON = 1e-6\nconst val EPSILON2 = EPSILON * EPSILON\n\nconst val PI = kotlin.math.PI\nconst val HALFPI = PI / 2.0\nconst val THIRDPI = PI / 3.0\nconst val QUARTERPI = PI / 4.0\n\nconst val TAU = PI * 2.0\nconst val TAU_EPSILON = TAU - EPSILON\n\nconst val DEG_TO_RAD = kotlin.math.PI / 180\nconst val RAD_TO_DEG = 180 / kotlin.math.PI\n\n\nval PI_ANGLE = Angle(kotlin.math.PI)\nval HALFPI_ANGLE = PI_ANGLE / 2\nval TAU_ANGLE = PI_ANGLE * 2\n\n"],"names":[],"mappings":"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Km5CG,OLn5CK,EAAR,SKm5CG,OLn5Cc,EAAxB,C;;cAGP,kBKg5CiB,OLh5CjB,a;UACI,IAAI,gBAAJ,C;YACI,WAAS,Q;YACT,WAAS,Q;YACN,kBAAO,GAAP,C;;;cAIX,kBKw4CiB,OLx4CjB,oB;UACI,WKu4Ca,OLv4CA,E;UACb,WKs4Ca,OLt4CA,E;UACV,kBAAO,MKq4CG,OLr4CK,IAAR,SKq4CG,OLr4CgB,IAAnB,SKq4CG,OLr4C2B,EAA9B,SKq4CG,OLr4CoC,EAA9C,C;;cAGP,kBKk4CiB,OLl4CjB,W;UACI,WKi4Ca,OLj4CA,E;UACb,WKg4Ca,OLh4CA,E;UACb,WK+3Ca,OL/3CA,E;UACb,WK83Ca,OL93CA,E;UACV,kBAAO,MK63CG,OL73CK,EAAR,SK63CG,OL73Cc,EAAjB,SK63CG,OL73CuB,EAA1B,SK63CG,OL73CgC,EAAnC,SAAwC,CK63CrC,OL73C0C,EAA7C,MAAP,C;;cAGP,kBK03CiB,OL13CjB,iB;UACI,WKy3Ca,OLz3CA,E;UACb,WKw3Ca,OLx3CA,E;UACV,kBAAO,MKu3CG,OLv3CK,KAAR,SKu3CG,OLv3CiB,KAApB,SKu3CG,OLv3C6B,KAAhC,SKu3CG,OLv3CyC,KAA5C,SKu3CG,OLv3CqD,EAAxD,SKu3CG,OLv3C8D,EAAxE,C;;cAIP,kBKm3CiB,OLn3CjB,S;UACI,SAAS,uCAAU,G;UACnB,SAAS,uCAAU,G;UAEnB,UK+2Ca,OL/2CC,EAAJ,GK+2CG,OL/2CS,M;UACtB,UK82Ca,OL92CC,EAAJ,GK82CG,OL92CS,M;UACtB,UAAU,KK62CG,OL72CM,M;UACnB,UAAU,KK42CG,OL52CM,M;UACnB,YAAY,MAAM,GAAN,GAAY,MAAM,G;UAI1B,IAFC,QAEG,QAAJ,C;YAEI,WKq2CK,OLr2CQ,M;YACb,WKo2CK,OLp2CQ,M;YACV,kBAAO,MKm2CL,OLn2Ca,MAAR,SKm2CL,OLn2C0B,MAA5B,C;;gBAGF,YAAa,OAAb,C;YAMI,QAAI,YAAY,S;YAApB,II+JqB,MAAW,KAAI,CAAJ,CJ/J5B,IAA8B,OAA9B,IK01CA,OL11C6C,OAAJ,KAAc,GAA3D,C;cACD,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"}