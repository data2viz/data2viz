{"version":3,"file":"d2v-scale-js.js","sources":["../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Time.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Band.kt","kotlin/math.kt","runtime/arrayUtils.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Continuous.kt","collections/Collections.kt","util/Preconditions.kt","../../../../../../../../../../dummy.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Log.kt","generated/_Collections.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Ordinal.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Power.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Quantile.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Quantize.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Scale.kt","util/Standard.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Sequential.kt","../../../../../d2v-scale-common/src/main/kotlin/io/data2viz/scale/Threshold.kt","kotlin/Comparator.kt"],"sourcesContent":["package io.data2viz.scale\n\nimport io.data2viz.interpolate.Interpolator\nimport io.data2viz.interpolate.UnInterpolator\nimport io.data2viz.math.Percent\nimport io.data2viz.math.pct\nimport io.data2viz.math.tickStep\nimport io.data2viz.time.*\n\nval dateComparator = Comparator<Date> { a, b -> if (a.millisecondsBetween(b) > 0) -1 else if (a.millisecondsBetween(b) < 0) 1 else 0 }\n\nprivate data class TickInterval(\n        val interval: Interval,\n        val step: Int,\n        val duration: Long\n)\n\nprivate val tickIntervals = listOf(\n        TickInterval(timeSecond, 1, durationSecond),\n        TickInterval(timeSecond, 5, 5 * durationSecond),\n        TickInterval(timeSecond, 15, 15 * durationSecond),\n        TickInterval(timeSecond, 30, 30 * durationSecond),\n        TickInterval(timeMinute, 1, durationMinute),\n        TickInterval(timeMinute, 5, 5 * durationMinute),\n        TickInterval(timeMinute, 15, 15 * durationMinute),\n        TickInterval(timeMinute, 30, 30 * durationMinute),\n        TickInterval(timeHour, 1, durationHour),\n        TickInterval(timeHour, 3, 3 * durationHour),\n        TickInterval(timeHour, 6, 6 * durationHour),\n        TickInterval(timeHour, 12, 12 * durationHour),\n        TickInterval(timeDay, 1, durationDay),\n        TickInterval(timeDay, 2, 2 * durationDay),\n        TickInterval(timeSunday, 1, durationWeek),\n        TickInterval(timeMonth, 1, durationMonth),\n        TickInterval(timeMonth, 3, 3 * durationMonth),\n        TickInterval(timeYear, 1, durationYear)\n)\n\n/**\n * Time scales are a variant of linear scales that have a temporal domain: domain values are dates rather than numbers,\n * and invert returns a date.\n * Time scales implement ticks based on calendar intervals, taking the pain out of generating axes for temporal domains.\n */\nclass TimeScale<R> internal constructor(interpolateRange: (R, R) -> Interpolator<R>,\n                   uninterpolateRange: ((R, R) -> UnInterpolator<R>)? = null,\n                   rangeComparator: Comparator<R>? = null)\n    : ContinuousScale<Date, R>(interpolateRange, uninterpolateRange, rangeComparator),\n        NiceableScale<Date>,\n        Tickable<Date> {\n\n    init {\n        _domain.clear()\n        _domain.addAll(listOf(date(2000, 1, 1), date(2000, 1, 2)))\n    }\n\n    override fun uninterpolateDomain(from: Date, to: Date): UnInterpolator<Date> {\n        return { date ->\n            if (from.millisecondsBetween(to) != 0L)\n                Percent((from.millisecondsBetween(date)) / (from.millisecondsBetween(to)).toDouble())\n            else 0.pct\n        }\n    }\n\n    override fun interpolateDomain(from: Date, to: Date): Interpolator<Date> {\n        val diff = from.millisecondsBetween(to)\n        return { percent ->\n            val date: Date = date(from)\n            val milliseconds = percent.value.toLong() * diff\n            date.plusMilliseconds(milliseconds)\n            date\n        }\n    }\n\n    override fun domainComparator(): Comparator<Date> = dateComparator\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values. This method typically modifies\n     * the scale\u2019s domain, and may only extend the bounds to the nearest round value. See continuous.nice for more.\n     *\n     * An optional tick count argument allows greater control over the step size used to extend the bounds,\n     * guaranteeing that the returned ticks will exactly cover the domain.\n     *\n     * Alternatively, a time interval may be specified to explicitly set the ticks.\n     * If an interval is specified, an optional step may also be specified to skip some ticks.\n     * For example, time.nice(d3.timeSecond, 10) will extend the domain to an even ten seconds (0, 10, 20, etc.).\n     * See time.ticks and interval.every for further detail.\n     *\n     * Nicing is useful if the domain is computed from data, say using extent, and may be irregular.\n     * For example, for a domain of [2009-07-13T00:02, 2009-07-13T23:48],\n     * the nice domain is [2009-07-13, 2009-07-14].\n     * If the domain has more than two values, nicing the domain only affects the first and last value.\n     */\n    override fun nice(count: Int) {\n        val start = _domain.first()\n        val end = _domain.last()\n        val interval: Interval = tickInterval(count, start, end)\n        niceDomain(end, start, interval)\n        rescale()\n    }\n\n    private fun tickInterval(count: Int, start: Date, end: Date): Interval {\n        val target = start.millisecondsBetween(end) / count\n        val intervalIndex = bisectRight(tickIntervals.map { it.duration }, target, naturalOrder())\n        val step: Int?\n        var interval: Interval = timeYear\n        if (intervalIndex == tickIntervals.size) {\n            step = tickStep(start.getTime() / durationYear, end.getTime() / durationYear, count).toInt()\n        } else if (intervalIndex > 0) {\n            val l = target.toDouble() / tickIntervals[intervalIndex - 1].duration\n            val l1 = tickIntervals[intervalIndex].duration / target.toDouble()\n            val tickInterval = tickIntervals[if (l < l1) intervalIndex - 1 else intervalIndex]\n            step = tickInterval.step\n            interval = tickInterval.interval\n        } else {\n            step = tickStep(start.getTime(), end.getTime(), count).toInt()\n            interval = timeMillisecond\n        }\n        if (step > 0) interval = interval.every(step)\n        return interval\n    }\n\n    private fun niceDomain(end: Date, start: Date, interval: Interval) {\n        var first = 0\n        var last = _domain.size - 1\n\n        if (end.isBefore(start)) {\n            first = domain.size - 1\n            last = 0\n        }\n\n        val x0 = _domain[first]\n        val x1 = _domain[last]\n\n        _domain[first] = interval.floor(x0)\n        _domain[last] = interval.ceil(x1)\n    }\n\n    /**\n     * Returns representative dates from the scale\u2019s domain.\n     * The returned tick values are uniformly-spaced (mostly), have sensible values (such as every day at midnight),\n     * and are guaranteed to be within the extent of the domain.\n     * Ticks are often used to display reference lines, or tick marks, in conjunction with the visualized data.\n     *\n     * An optional count may be specified to affect how many ticks are generated.\n     * If count is not specified, it defaults to 10. The specified count is only a hint; the scale may return more\n     * or fewer values depending on the domain.\n     *\n     * The following time intervals are considered for automatic ticks:\n     * 1-, 5-, 15- and 30-second.\n     * 1-, 5-, 15- and 30-minute.\n     * 1-, 3-, 6- and 12-hour.\n     * 1- and 2-day.\n     * 1-week.\n     * 1- and 3-month.\n     * 1-year.\n     */\n    override fun ticks(count: Int): List<Date> {\n        var first = 0\n        var last = _domain.size - 1\n\n        var start = _domain[first]\n        var end = _domain[last]\n\n        if (start.millisecondsBetween(end) == 0L) return listOf()\n\n        val reversed = end.isBefore(start)\n        if (reversed) {\n            first = _domain.size - 1\n            last = 0\n            start = _domain[first]\n            end = _domain[last]\n        }\n\n        val endPlus = date(end)\n        endPlus.plusMilliseconds(1)\n\n        val tickInterval = tickInterval(count, start, end)\n        val ticks = tickInterval.range(start, endPlus)\n\n        return if (reversed) ticks.reversed() else ticks\n    }\n}\n\n","package io.data2viz.scale\n\nimport kotlin.math.floor\nimport kotlin.math.max\n\n\nabstract class BandedScale<D>(private val indexableDomain: IndexableDomain<D> = IndexableDomain()) :\n    Scale<D, Double>,\n    DiscreteDomain<D> by indexableDomain,\n    Tickable<D>,\n    StrictlyContinuousRange<D, Double> {\n\n    private val unknown = Double.NaN\n\n    protected var _paddingInner: Double = 0.0\n    protected var _paddingOuter: Double = 0.0\n\n    abstract var padding: Double\n\n    override var domain: List<D>\n        get() = indexableDomain._domain\n        set(value) {\n            indexableDomain.domain = value\n            rescale()\n        }\n    override var range: StrictlyContinuous<Double> = intervalOf(0.0, 1.0)\n        get() = field\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    var round: Boolean = false\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    var align: Double = 0.5\n        set(value) {\n            field = value.coerceIn(.0..1.0)\n            rescale()\n        }\n\n    var step: Double = 1.0\n        private set\n\n    var bandwidth: Double = 1.0\n        private set\n\n    private var ordinalRange: MutableList<Double> = ArrayList()\n\n    override operator fun invoke(domainValue: D): Double {\n        val i: Int = indexableDomain.index[domainValue] ?: return unknown\n        return if (ordinalRange.isEmpty()) unknown else ordinalRange[i]\n    }\n\n    override fun ticks(count: Int): List<D> = domain\n\n    protected fun rescale() {\n        val n = indexableDomain._domain.size\n        val reverse = range.end < range.start\n        var start = if (reverse) range.end else range.start\n        val stop = if (reverse) range.start else range.end\n        step = (stop - start) / max(1.0, n - _paddingInner + _paddingOuter * 2)\n        if (round)\n            step = floor(step)\n\n        start += (stop - start - step * (n - _paddingInner)) * align\n        bandwidth = step * (1 - _paddingInner)\n        if (round) {\n            start = kotlin.math.round(start)\n            bandwidth = kotlin.math.round(bandwidth)\n        }\n\n        val values: Array<Double> = Array(n, { start + step * it })\n        if (reverse) values.reverse()\n        ordinalRange.clear()\n        ordinalRange.addAll(values)\n    }\n}\n\n/**\n * Represents domain as band (for barchart for example).\n *\n * BandScale.invoke(domain) returns the coordinate of the start of each band.\n *\n *\n * [padding]\n *\n * [paddingInner] representents the size between\n *\n * Band scales are like ordinal scales except the output range is continuous and numeric.\n * Discrete output values are automatically computed by the scale by dividing the continuous range into uniform bands.\n * Band scales are typically used for bar charts with an ordinal or categorical dimension.\n * The unknown value of a band scale is always NaN: they do not allow implicit domain construction.\n */\nclass BandScale<D> internal constructor() : BandedScale<D>() {\n\n    override var padding: Double\n        get() = _paddingInner\n        set(value) {\n            _paddingInner = value\n            _paddingOuter = value\n            rescale()\n        }\n\n    var paddingInner\n        get() = _paddingInner\n        set(value) {\n            _paddingInner = value.coerceIn(.0..1.0)\n            rescale()\n        }\n\n    var paddingOuter\n        get() = _paddingOuter\n        set(value) {\n            _paddingOuter = value.coerceIn(.0..1.0)\n            rescale()\n        }\n}\n\n/**\n * Point scales are a variant of band scales with the bandwidth fixed to zero.\n * Point scales are typically used for scatterplots with an ordinal or categorical dimension.\n * The unknown value of a point scale is always NaN: they do not allow implicit domain construction.\n */\nclass PointScale<D> : BandedScale<D>() {\n\n    /**\n     * Sets the outer padding to the specified value which must be in the range [0, 1].\n     * Returns the current outer padding which defaults to 0.\n     * The outer padding determines the ratio of the range that is reserved for blank space before the first\n     * point and after the last point. Equivalent to band.paddingOuter.\n     */\n    override var padding: Double\n        get() = _paddingOuter\n        set(value) {\n            _paddingOuter = value\n            rescale()\n        }\n\n    init {\n        _paddingInner = 1.0\n        rescale()\n    }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n\n\n\n// ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","package io.data2viz.scale\n\nimport io.data2viz.interpolate.Interpolator\nimport io.data2viz.interpolate.UnInterpolator\nimport io.data2viz.math.tickStep\nimport io.data2viz.interpolate.interpolateNumber\nimport io.data2viz.interpolate.uninterpolateNumber\nimport io.data2viz.math.*\nimport kotlin.math.ceil\nimport kotlin.math.floor\nimport kotlin.math.min\n\n\n// uninterpolate  [value A .. value B] --> [0 .. 1]\n// interpolate [0 .. 1] --> [value A .. value B]\n\n\nopen class LinearScale<R>\n    internal constructor(\n        interpolateRange: (R, R) -> Interpolator<R>,\n        uninterpolateRange: ((R, R) -> UnInterpolator<R>)? = null,\n        rangeComparator: Comparator<R>? = null) :\n        ContinuousScale<Double, R>(interpolateRange, uninterpolateRange, rangeComparator),\n        Tickable<Double>,\n        NiceableScale<Double> {\n\n    val comparator = naturalOrder<Double>()\n\n    override fun interpolateDomain(from: Double, to: Double): Interpolator<Double> = interpolateNumber(from, to)\n    override fun uninterpolateDomain(from: Double, to: Double): UnInterpolator<Double> = uninterpolateNumber(from, to)\n    override fun domainComparator(): Comparator<Double> = comparator\n\n    operator fun invoke(domainValue: Int): R {\n        return this(domainValue.toDouble())\n    }\n\n    init {\n        _domain.clear()\n        _domain.addAll(listOf(.0, 1.0))\n    }\n\n    /**\n     * Extends the domain so that it starts and ends on nice round values.\n     * This method typically modifies the scale\u2019s domain, and may only extend the bounds to the nearest round value.\n     * An optional tick count argument allows greater control over the step size used to extend the bounds,\n     * guaranteeing that the returned ticks will exactly cover the domain. Nicing is useful if the domain is computed\n     * from data, say using extent, and may be irregular. For example, for a domain of [0.201479\u2026, 0.996679\u2026],\n     * a nice domain might be [0.2, 1.0]. If the domain has more than two values, nicing the domain only affects\n     * the first and last value. See also d3-array\u2019s tickStep.\n     *\n     * Nicing a scale only modifies the current domain; it does not automatically nice domains that are\n     * subsequently set using continuous.domain. You must re-nice the scale af  ter setting the new domain, if desired.\n     */\n    override fun nice(count: Int) {\n        val last = _domain.size - 1\n        var step = tickStep(_domain[0], _domain[last], count)\n        val start = floor(_domain[0] / step) * step\n        val stop = ceil(_domain[last] / step) * step\n\n        if (step != .0) {\n            step = tickStep(start, stop, count)\n            _domain[0] = floor(start / step) * step\n            _domain[last] = ceil(stop / step) * step\n            rescale()\n        }\n    }\n\n    override fun ticks(count: Int): List<Double> {\n        return io.data2viz.math.ticks(_domain.first(), _domain.last(), count)\n    }\n}\n\n/**\n * Continuous scales map a continuous, quantitative input domain to a continuous output range.\n *\n * If the range is also numeric, the mapping may be inverted. TODO so it's not invertable by default -> should not implement Invertable\n *\n * A continuous scale is not constructed directly; instead, try a linear, power, log,\n * identity, time or sequential color scale.\n */\nabstract class ContinuousScale<D, R>(\n        val interpolateRange: (R, R) -> Interpolator<R>,\n        val uninterpolateRange: ((R, R) -> UnInterpolator<R>)? = null,\n        val rangeComparator: Comparator<R>? = null) :\n        ContinuousDomain<D>,\n        ContinuousRangeScale<D, R>,\n        ClampableScale,\n        InvertableScale<D, R> {\n\n    private var rangeToDomain: ((R) -> D)? = null\n    private var domainToRange: ((D) -> R)? = null\n\n    protected val _domain: MutableList<D> = arrayListOf()\n    protected val _range: MutableList<R> = arrayListOf()\n\n    override var clamp: Boolean = false\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    // copy the value (no binding intended)\n    override var domain: List<D>\n        get() = _domain.toList()\n        set(value) {\n            _domain.clear()\n            _domain.addAll(value)\n            rescale()\n        }\n\n    // copy the value (no binding intended)\n    override var range: List<R>\n        get() = _range.toList()\n        set(value) {\n            _range.clear()\n            _range.addAll(value)\n            rescale()\n        }\n\n    abstract fun interpolateDomain(from: D, to: D): Interpolator<D>\n    abstract fun uninterpolateDomain(from: D, to: D): UnInterpolator<D>\n    abstract fun domainComparator(): Comparator<D>\n\n\n    override operator fun invoke(domainValue: D): R {\n        if (domainToRange == null) {\n            check(_domain.size == _range.size) { \"Domains (in) and Ranges (out) must have the same size.\" }\n            val uninterpolateFunc = if (clamp) uninterpolateClamp(::uninterpolateDomain) else ::uninterpolateDomain\n            domainToRange =\n                    if (_domain.size > 2) polymap(uninterpolateFunc)\n                    else bimap(uninterpolateFunc)\n        }\n\n        return domainToRange?.invoke(domainValue) ?: throw IllegalStateException()\n    }\n\n    // TODO : wrong : clamping is done on interpolateRange function...\n    override fun invert(rangeValue: R): D {\n        checkNotNull(uninterpolateRange) { \"No de-interpolation function for range has been found for this scale. Invert operation is impossible.\" }\n\n        if (rangeToDomain == null) {\n            check(_domain.size == _range.size) { \"Domains (in) and Ranges (out) must have the same size.\" }\n            val interpolateFunc = if (clamp) interpolateClamp(::interpolateDomain) else ::interpolateDomain\n            rangeToDomain =\n                    if (_domain.size > 2 || _range.size > 2) polymapInvert(interpolateFunc, uninterpolateRange!!)\n                    else bimapInvert(interpolateFunc, uninterpolateRange!!)\n        }\n\n        return rangeToDomain?.invoke(rangeValue) ?: throw IllegalStateException()\n    }\n\n    protected fun rescale() {\n        rangeToDomain = null\n        domainToRange = null\n    }\n\n    private fun uninterpolateClamp(uninterpolateFunction: (D, D) -> UnInterpolator<D>): (D, D) -> UnInterpolator<D> {\n        return fun(a: D, b: D): UnInterpolator<D> {\n            val d = uninterpolateFunction(a, b)\n            return fun(value: D) = d(value).coerceToDefault()\n        }\n    }\n\n    private fun interpolateClamp(interpolateFunction: (D, D) -> Interpolator<D>): (D, D) -> Interpolator<D> {\n        return fun(a: D, b: D): Interpolator<D> {\n            val r = interpolateFunction(a, b)\n            return fun(value: Percent) = r(value.coerceToDefault())\n        }\n    }\n\n    private fun bimap(deinterpolateDomain: (D, D) -> UnInterpolator<D>): (D) -> R {\n\n        val d0 = _domain[0]\n        val d1 = _domain[1]\n        val r0 = _range[0]\n        val r1 = _range[1]\n\n        val r: Interpolator<R>\n        val d: UnInterpolator<D>\n\n        if (domainComparator().compare(d1, d0) < 0) {\n            d = deinterpolateDomain(d1, d0)\n            r = interpolateRange(r1, r0)\n        } else {\n            d = deinterpolateDomain(d0, d1)\n            r = interpolateRange(r0, r1)\n        }\n\n        return { x: D -> r(d(x)) }\n    }\n\n    private fun bimapInvert(reinterpolateDomain: (D, D) -> Interpolator<D>,\n                            deinterpolateRange: (R, R) -> UnInterpolator<R>): (R) -> D {\n\n        checkNotNull(rangeComparator) { \"No RangeComparator has been found for this scale. Invert operation is impossible.\" }\n\n        val d0 = _domain[0]\n        val d1 = _domain[1]\n        val r0 = _range[0]\n        val r1 = _range[1]\n\n        val r: UnInterpolator<R>\n        val d: Interpolator<D>\n\n        if (rangeComparator.compare(r1, r0) < 0) {\n            d = reinterpolateDomain(d1, d0)\n            r = deinterpolateRange(r1, r0)\n        } else {\n            d = reinterpolateDomain(d0, d1)\n            r = deinterpolateRange(r0, r1)\n        }\n\n        return { x: R -> d(r(x)) }\n    }\n\n    private fun polymap(uninterpolateDomain: (D, D) -> UnInterpolator<D>): (D) -> R {\n\n        val d0 = _domain.first()\n        val d1 = _domain.last()\n        val domainReversed = domainComparator().compare(d1, d0) < 0\n        val domainValues = if (domainReversed) _domain.reversed() else _domain\n        val rangeValues = if (domainReversed) _range.reversed() else _range\n\n        val size = min(_domain.size, _range.size) - 1\n        val domainInterpolators = Array(size) { uninterpolateDomain(domainValues[it], domainValues[it + 1]) }\n        val rangeInterpolators = Array(size) { interpolateRange(rangeValues[it], rangeValues[it + 1]) }\n\n        return { x ->\n            val index = bisectRight(_domain, x, domainComparator(), 1, size) - 1\n            rangeInterpolators[index](domainInterpolators[index](x))\n        }\n    }\n\n    private fun polymapInvert(interpolateDomain: (D, D) -> Interpolator<D>,\n                              uninterpolateRange: (R, R) -> UnInterpolator<R>): (R) -> D {\n\n        // TODO <R> instanceOf Comparable ??\n        checkNotNull(rangeComparator) { \"No RangeComparator has been found for this scale. Invert operation is impossible.\" }\n\n        val r0 = _range.first()\n        val r1 = _range.last()\n        val rangeReversed = rangeComparator.compare(r1, r0) < 0\n        val domainValues = if (rangeReversed) _domain.reversed() else _domain\n        val rangeValues = if (rangeReversed) _range.reversed() else _range\n\n        val size = min(_domain.size, _range.size) - 1\n        val domainInterpolators = Array(size) { interpolateDomain(domainValues[it], domainValues[it + 1]) }\n        val rangeInterpolators = Array(size) { uninterpolateRange(rangeValues[it], rangeValues[it + 1]) }\n\n        return { y ->\n            val index = bisectRight(rangeValues, y, rangeComparator, 1, size) - 1\n            domainInterpolators[index](rangeInterpolators[index](y))\n        }\n    }\n}\n\n\n// TODO move to array module\n/**\n * Returns the insertion point for x in array to maintain sorted order.\n * The arguments lo and hi may be used to specify a subset of the array which should be considered;\n * by default the entire array is used. If x is already present in array, the insertion point will be\n * after (to the right of) any existing entries of x in array.\n * The returned insertion point i partitions the array into two halves so that all v <= x for v in array.slice(lo, i)\n * for the left side and all v > x for v in array.slice(i, hi) for the right side.\n */\nfun <T> bisectRight(list: List<T>, x: T, comparator: Comparator<T>, low: Int = 0, high: Int = list.size): Int {\n    var lo = low\n    var hi = high\n    while (lo < hi) {\n        val mid = (lo + hi) / 2\n        if (comparator.compare(list[mid], x) > 0)\n            hi = mid\n        else\n            lo = mid + 1\n    }\n    return lo\n}\n\nfun <T> bisectLeft(list: List<T>, x: T, comparator: Comparator<T>, low: Int = 0, high: Int = list.size): Int {\n    var lo = low\n    var hi = high\n    while (lo < hi) {\n        val mid = (lo + hi) / 2\n        if (comparator.compare(list[mid], x) < 0)\n            lo = mid + 1\n        else\n            hi = mid\n    }\n    return lo\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n",null,"package io.data2viz.scale\n\nimport io.data2viz.interpolate.Interpolator\nimport io.data2viz.interpolate.UnInterpolator\nimport io.data2viz.math.*\nimport kotlin.math.*\n\n/**\n * Log scales are similar to linear scales, except a logarithmic transform is applied to the input domain value\n * before the output range value is computed.\n * The mapping to the range value y can be expressed as a function of the domain value x: y = m log(x) + b.\n */\ninternal class LogScale\n    internal constructor(base: Double = 10.0, interpolateRange: (Double, Double) -> Interpolator<Double>,\n                       uninterpolateRange: ((Double, Double) -> UnInterpolator<Double>)? = null,\n                       rangeComparator: Comparator<Double>? = null)\n    : LinearScale<Double>(interpolateRange, uninterpolateRange, rangeComparator) {\n\n    var base: Double = base\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    /**\n     * As log(0) = -\u221e, a log scale domain must be strictly-positive or strictly-negative;\n     * the domain must not include or cross zero. A log scale with a positive domain has a well-defined\n     * behavior for positive values, and a log scale with a negative domain has a well-defined behavior for\n     * negative values. (For a negative domain, input and output values are implicitly multiplied by -1.)\n     * The behavior of the scale is undefined if you pass a negative value to a log scale with a positive\n     * domain or vice versa.\n     */\n    override var domain: List<Double>\n        get() = _domain\n        set(value) {\n            if (value.contains(.0)) throw IllegalArgumentException(\"The domain interval must not contain 0, as log(0) = -\u221e.\")\n            val totalPositives = value.filter { it > 0}.size\n            val totalNegatives = value.filter { it > 0}.size\n            if ((totalPositives > 0 && totalPositives < value.size)\n                    || (totalNegatives > 0 && totalNegatives < value.size))\n                throw IllegalArgumentException(\"The domain interval must contain only positive or negative elements.\")\n\n            // copy the value (no binding intended)\n            _domain.clear()\n            _domain.addAll(value)\n            rescale()\n        }\n\n    override fun uninterpolateDomain(from: Double, to: Double): UnInterpolator<Double> {\n        val diff = ln(to / from)\n        return if (diff != .0 && diff != Double.NaN) { t -> Percent(ln(t / from) / diff) }\n        else { _ -> 0.pct }\n    }\n\n    override fun interpolateDomain(from: Double, to: Double): Interpolator<Double> {\n        return if (from < 0) { t -> -(-to.pow(t.value) * -from.pow(1 - t.value)) }\n        else { t -> to.pow(t.value) * from.pow(1 - t.value) }\n    }\n\n    private fun niceLogScale(values: List<Double>, floor: (Double) -> Double, ceil: (Double) -> Double): List<Double> {\n        val reversed = values.last() < values.first()\n        val first = if(reversed) values.size - 1 else 0\n        val last  = if(reversed) 0 else values.size - 1\n\n        val newDomain = values.toMutableList()\n        newDomain[first] = floor(values[first])\n        newDomain[last] = ceil(values[last])\n        return newDomain\n    }\n\n    init {\n        _domain.clear()\n        _domain.addAll(arrayListOf(1.0, 10.0))\n    }\n\n    override fun nice(count: Int) {\n        domain = niceLogScale(domain, { x -> base.pow(floor(log(x, base))) }, { x -> base.pow(ceil(log(x, base))) })\n    }\n\n    override fun ticks(count: Int): List<Double> {\n        var domainStart = _domain.first()\n        var domainEnd = _domain.last()\n        val domainReversed = domainEnd < domainStart\n\n        if (domainReversed) {\n            domainStart = _domain.last()\n            domainEnd = _domain.first()\n        }\n\n        var i = log(domainStart, base)\n        var j = log(domainEnd, base)\n        var tickList = arrayListOf<Double>()\n\n        val test = !((base % 1 == .0) || (base % 1 == Double.NaN))\n\n        if (test && (j - i < count)) {\n            i = round(i) - 1\n            j = round(j) + 1\n            if (domainStart > 0) {\n                while (i < j) {\n                    val p = base.pow(i)\n                    for (k in 1 until base.toInt()) {\n                        val t = p * k\n                        if (t < domainStart) continue\n                        if (t > domainEnd) break\n                        tickList.add(t)\n                    }\n                    ++i\n                }\n            } else {\n                while (i < j) {\n                    val p = base.pow(i)\n                    for (k in (base - 1.0).toInt() until 0) {\n                        val t = p * k\n                        if (t < domainStart) continue\n                        if (t > domainEnd) break\n                        tickList.add(t)\n                    }\n                    ++i\n                }\n            }\n        } else {\n            tickList = io.data2viz.math.ticks(i, j, min((j - i).toInt(), count)).map({ base.pow(it) }) as ArrayList<Double>\n        }\n\n        return if (domainReversed) tickList.reversed() else tickList\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package io.data2viz.scale\n\n\nclass IndexableDomain<D> : DiscreteDomain<D> {\n\n    internal val index: MutableMap<D, Int> = HashMap()\n    internal val _domain: MutableList<D> = arrayListOf()\n\n    /**\n     * The first element in domain will be mapped to the first element in the range, the second domain value to\n     * the second range value, and so on.\n     *\n     * Domain values are stored internally in a map from stringified value to index; the resulting index is then used\n     * to retrieve a value from the range. Thus, an ordinal scale\u2019s values must be coercible to a string,\n     * and the stringified version of the domain value uniquely identifies the corresponding range value.\n     *\n     * Setting the domain on an ordinal scale is optional if the unknown value is implicit (the default).\n     * In this case, the domain will be inferred implicitly from usage by assigning each unique value passed\n     * to the scale a new value from the range.\n     *\n     * Note that an explicit domain is recommended to ensure deterministic behavior, as inferring the domain\n     * from usage will be dependent on ordering.\n     */\n    override var domain: List<D>\n        get() = _domain.toList()\n        set(value) {\n            _domain.clear()\n            index.clear()\n            value.forEach {\n                if (!index.containsKey(it)) {\n                    _domain.add(it)\n                    index.put(it, _domain.size - 1)\n                }\n            }\n        }\n}\n\n/**\n * Unlike continuous scales, ordinal scales have a discrete domain and range.\n * For example, an ordinal scale might map a set of named categories to a set of colors, or determine the\n * horizontal positions of columns in a column chart.\n */\nopen class OrdinalScale<D, R> internal constructor(\n    range: List<R> = listOf(),\n    val indexableDomain: IndexableDomain<D> = IndexableDomain()\n) : Scale<D, R>, DiscreteDomain<D> by indexableDomain {\n\n    protected val _range: MutableList<R> = arrayListOf()\n\n    init {\n        _range.addAll(range.toList())\n    }\n\n\n    /**\n     * If range is specified, sets the range of the ordinal scale to the specified array of values.\n     * The first element in the domain will be mapped to the first element in range, the second domain value to\n     * the second range value, and so on.\n     * If there are fewer elements in the range than in the domain, the scale will reuse values from the start\n     * of the range.\n     */\n    var range: List<R>\n        get() = _range.toList()\n        set(value) {\n            require(value.isNotEmpty(), { \"Range can't be empty.\" })\n            _range.clear()\n            _range.addAll(value.toList())\n        }\n\n\n    /**\n     * The behavior when asking for a rangeValue with a given non-existant domainValue :\n     * If unknown is null : add domainValue to the domain, then return a rangeValue (= scale implicit).\n     * If unknown is not null : return unknown.\n     */\n    // TODO : change behavior\n    private var _unknown: R? = null\n\n\n    var unknown: R?\n        get() = _unknown\n        set(value) {\n            _unknown = value\n        }\n\n    override operator fun invoke(domainValue: D): R {\n        if (_unknown == null && !indexableDomain.index.containsKey(domainValue)) {\n            indexableDomain._domain.add(domainValue)\n            indexableDomain.index.put(domainValue, indexableDomain._domain.size - 1)\n        }\n\n        val index = indexableDomain.index[domainValue] ?: return _unknown ?: throw IllegalStateException()\n        return when {\n            _range.isEmpty() -> _unknown ?: throw IllegalStateException()\n            else -> _range[index % _range.size]\n        }\n    }\n\n}\n","package io.data2viz.scale\n\nimport io.data2viz.interpolate.*\nimport io.data2viz.math.*\nimport kotlin.math.pow\n\n/**\n * Power scales are similar to linear scales, except an exponential transform is applied to the input domain\n * value before the output range value is computed.\n * Each range value y can be expressed as a function of the domain value x: y = mx^k + b, where k is the exponent value.\n * Power scales also support negative domain values, in which case the input value and the resulting output\n * value are multiplied by -1.\n */\nclass PowerScale<R>\n    internal constructor(exponent: Double = 1.0, interpolateRange: (R, R) -> Interpolator<R>,\n                    uninterpolateRange: ((R, R) -> UnInterpolator<R>)? = null,\n                    rangeComparator: Comparator<R>? = null)\n    : LinearScale<R>(interpolateRange, uninterpolateRange, rangeComparator) {\n\n    var exponent: Double = exponent\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    override fun uninterpolateDomain(from: Double, to: Double): UnInterpolator<Double> {\n        val dFrom = raise(from, exponent)\n        val dTo = raise(to, exponent) - dFrom\n\n        return if (dTo == .0 || dTo == Double.NaN) { _ -> 0.pct }\n        else { t -> Percent((raise(t, exponent) - dFrom) / dTo) }\n    }\n\n    override fun interpolateDomain(from: Double, to: Double): Interpolator<Double> {\n        val ra = raise(from, exponent)\n        val rb = raise(to, exponent) - ra\n        return { t -> raise(ra + rb * t.value, 1.0 / exponent) }\n    }\n\n    private fun raise(x: Double, exponent: Double): Double {\n        val pow = x.pow(exponent)\n        return if (x < 0.0) -pow else pow\n    }\n}\n\n","package io.data2viz.scale\n\nimport kotlin.math.floor\nimport kotlin.math.max\n\n\n\n/**\n * Quantile scales map a sampled input domain to a discrete range.\n * The domain is considered continuous and thus the scale will accept any reasonable input value;\n * however, the domain is specified as a discrete set of sample values. The number of values in (the cardinality of)\n * the output range determines the number of quantiles that will be computed from the domain.\n * To compute the quantiles, the domain is sorted, and treated as a population of discrete values;\n */\nclass QuantileScale<R> internal constructor() : Scale<Double, R>,DiscreteDomain<Double>,  DiscreteRange<R> {\n\n        \n    private var thresholds: MutableList<Double> = arrayListOf()\n\n    /**\n     * Returns the quantile thresholds.\n     * If the range contains n discrete values, the returned array will contain n - 1 thresholds.\n     * Values less than the first threshold are considered in the first quantile; values greater than or equal\n     * to the first threshold but less than the second threshold are in the second quantile, and so on.\n     * Internally, the thresholds array is used with bisect to find the output quantile associated with the given input value.\n     */\n    val quantiles\n        get() = thresholds.toList()\n\n    /**\n     * If' domain is specified, sets the domain of the quantile scale to the specified set of discrete numeric values.\n     * The array must not be empty, and must contain at least one numeric value; NaN, null and undefined values\n     * are ignored and not considered part of the sample population.\n     * If the elements in the given array are not numbers, they will be coerced to numbers.\n     * A copy of the input array is sorted and stored internally.\n     */\n    override var domain: List<Double> = listOf()\n        get() = field.toList()\n        set(value) {\n            val filteredValue = value.filter { !it.isNaN() }.sorted()\n            require(filteredValue.isNotEmpty(), { \"Domain can't be empty.\" })\n            field = filteredValue\n            rescale()\n        }\n\n    /**\n     * If range is specified, sets the discrete values in the range.\n     * The array must not be empty, and may contain any type of value.\n     * The number of values in (the cardinality, or length, of) the range array determines the number of\n     * quantiles that are computed.\n     * For example, to compute quartiles, range must be an array of four elements such as [0, 1, 2, 3].\n     */\n    override var range: List<R> = listOf()\n        get() = field.toList()\n        set(value) {\n            require(value.isNotEmpty(), { \"Range can't be empty.\" })\n            field = value.toList()\n            rescale()\n        }\n\n    private fun rescale() {\n        // don't compute until we'th got a non-empty range and domain\n        if (domain.isEmpty() || range.isEmpty()) return\n\n        var i = 0\n        val n = max(1, range.size)\n        thresholds = arrayListOf()\n        while (++i < n) {\n            thresholds.add(i - 1, quantile(domain, i / n.toDouble()))\n        }\n    }\n\n    fun invertExtent(rangeValue: R): List<Double> {\n        check(domain.isNotEmpty(), { \"Can't compute a Quantile Scale with an empty Domain\" })\n        check(range.isNotEmpty(), { \"Can't compute a Quantile Scale with an empty Range\" })\n        val index = range.indexOf(rangeValue)\n        return when (index) {\n            -1 -> listOf(Double.NaN, Double.NaN)\n            else -> listOf(if (index > 0) thresholds[index - 1] else domain.first(),\n                    if (index < thresholds.size) thresholds[index] else domain.last())\n        }\n    }\n\n    override fun invoke(domainValue: Double): R {\n        require(!domainValue.isNaN(), { \"domainValue can't be NaN\" })\n        check(domain.isNotEmpty(), { \"Can't compute a Quantile Scale with an empty Domain\" })\n        check(range.isNotEmpty(), { \"Can't compute a Quantile Scale with an empty Range\" })\n        return range[bisectRight(thresholds, domainValue, naturalOrder())]\n    }\n}\n\n// TODO move to array module\nfun quantile(values: List<Double>, p: Double, f: (Double, Int, List<Double>) -> Double = { x, _, _ -> x }): Double {\n    require(values.isNotEmpty(), { \"Values must not be empty.\" })\n\n    val size = values.size\n    if (p <= 0.0 || size < 2)\n        return f(values[0], size - 1 - 1, values)\n\n    val h = (size - 1) * p\n    val i = floor(h).toInt()\n    val a = f(values[i], i, values)\n    val b = f(values[i + 1], i + 1, values)\n    return a + (b - a) * (h - i)\n}\n","package io.data2viz.scale\n\n/**\n * Quantize scales are similar to linear scales, except they use a discrete rather than continuous range.\n *\n * The continuous input domain is divided into uniform segments based on the number of values\n * in (i.e., the cardinality of) the output range.\n * Each range value y can be expressed as a quantized linear function of the domain value x: y = m round(x) + b.\n */\nclass QuantizeScale<R> internal constructor() : Scale<Double, R>, StrictlyContinuousDomain<Double>, DiscreteRange<R> {\n\n\n    private val quantizedDomain:ArrayList<Double> = arrayListOf(.5)\n\n    // copy the value (no binding intended)\n    override var range: List<R> = listOf()\n        get() = field.toList()\n        set(value) {\n            field = value.toList()\n            rescale()\n        }\n\n    override var domain: StrictlyContinuous<Double> = intervalOf(0.0, 1.0)\n        get() = field\n        set(value) {\n            field = value\n            rescale()\n        }\n\n    private fun rescale() {\n        quantizedDomain.clear()\n\n        val size = range.size - 1\n        for(index in 0 until size) {\n            val element = ((index + 1) * domain.end - (index - size) * domain.start) / (size + 1)\n            quantizedDomain.add(element)\n        }\n    }\n\n\n    override fun invoke(domainValue: Double): R {\n        return range[bisectRight(quantizedDomain, domainValue, naturalOrder(), 0, range.size - 1)]\n    }\n\n    fun invertExtent(rangeValue: R): List<Double> {\n        val i = range.indexOf(rangeValue)\n        val size = range.size - 1\n        return when {\n            i < 0 -> listOf(Double.NaN, Double.NaN)\n            i < 1 -> listOf(domain.start, quantizedDomain.first())\n            i >= size -> listOf(quantizedDomain[size - 1], domain.end)\n            else -> listOf(quantizedDomain[i - 1], quantizedDomain[i])\n        }\n    }\n}\n\n\n","package io.data2viz.scale\n\nimport io.data2viz.color.Color\nimport io.data2viz.color.EncodedColors\nimport io.data2viz.geom.Point\nimport io.data2viz.interpolate.*\n\n/**\n * Generic signature of scales.\n *\n * A scale can map a domain object dimension D to a representation value.\n *\n * Then at runtime, one can ask an R object for a specific value of domain.\n * The rules defining the returns of R from D depends a lot on the type and\n * implementation of the Scale.\n *\n * a Domain object -> Range object\n */\ninterface Scale<D, out R> {\n    operator fun invoke(domainValue: D): R\n}\n\ninterface ContinuousDomain<D> {\n    var domain: List<D>\n}\n\ninterface DiscreteDomain<D> {\n    var domain: List<D>\n}\n\ninterface StrictlyContinuousDomain<D> {\n    var domain: StrictlyContinuous<D>\n}\n\ninterface ContinuousRangeScale<D, R> : Scale<D, R>, FirstLastRange<D, R> {\n    var range: List<R>\n    override fun start() = range.first()\n    override fun end() = range.last()\n}\n\ninterface DiscreteRange<R> {\n    var range: List<R>\n}\n\ninterface StrictlyContinuousRange<D, R> : FirstLastRange<D, R> {\n    var range: StrictlyContinuous<R>\n    override fun start() = range.start\n    override fun end() = range.end\n}\n\ninterface FirstLastRange<D, R> : Scale<D, R> {\n    fun start(): R\n    fun end(): R\n}\n\n/**\n * A stricly continuous dimension is only defined by its start and end.\n * There is not intermediary value.\n */\ndata class StrictlyContinuous<D>(val start: D, val end: D)\n\nfun <D> intervalOf(start: D, end: D) = StrictlyContinuous(start, end)\nfun <D> intervalOf(vararg values: D) = StrictlyContinuous(values.first(), values.last())\n\n\n/**\n * Indicates a scale for which the resulting R\n */\ninterface ClampableScale {\n    val clamp: Boolean\n}\n\ninterface NiceableScale<D> : ContinuousDomain<D> {\n    fun nice(count: Int = 10)\n}\n\ninterface InvertableScale<D, R> : Scale<D, R> {\n    fun invert(rangeValue: R): D\n}\n\n/**\n * Can provide ticks from Domain D.\n */\ninterface Tickable<D> {\n    fun ticks(count: Int = 10): List<D>\n}\n\n/**\n * Access the data2viz collection of scales.\n * To create a color scale use ScalesChomatic instead.\n * Available factories:\n *\n * Scales\n *      Continuous      (continuous domain to continuous range)\n *          -> linear\n *          -> log\n *          -> time\n *          -> ...\n *      Quantized       (continuous domain to discrete range)\n *          -> threshold\n *          -> quantize\n *          -> quantile\n *      Discrete        (discrete domain)\n *          -> ordinal\n *          -> band\n *          -> point\n */\nobject Scales {\n\n    object Continuous {\n\n\n        /**\n         * Identity scales are a special case of linear scales where the domain and range are identical;\n         * the scale and its invert method are thus the identity function. These scales are occasionally useful when\n         * working with pixel coordinates, say in conjunction with an axis or brush.\n         */\n        fun identity() = LinearScale(::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply {\n            domain = listOf(.0, 1.0)\n            range = listOf(.0, 1.0)\n        }\n\n        fun linear(init: LinearScale<Double>.() -> Unit = {}) =\n            LinearScale(::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun linearRound(init: LinearScale<Double>.() -> Unit = {}) =\n            LinearScale(::interpolateRound, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun log(\n            base: Double = 10.0,\n            init: ContinuousScale<Double, Double>.() -> Unit = {}\n        ): ContinuousScale<Double, Double> =\n            LogScale(base, ::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        /**\n         * TODO Test\n         */\n        fun logRound(base: Double = 10.0): ContinuousScale<Double, Double> =\n            LogScale(base, ::interpolateRound, ::uninterpolateNumber, naturalOrder())\n\n        fun vector(init: LinearScale<Point>.() -> Unit = {}) =\n            LinearScale(::interpolatePoint, ::uninterpolatePointOnX, PointComparatorX()).apply(init)\n\n        fun pow(exponent: Double = 1.0, init: PowerScale<Double>.() -> Unit = {}) =\n            PowerScale(exponent, ::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun powRound(exponent: Double = 1.0, init: PowerScale<Double>.() -> Unit = {}) =\n            PowerScale(exponent, ::interpolateRound, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n\n        fun sqrt(init: PowerScale<Double>.() -> Unit = {}) =\n            PowerScale(.5, ::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun sqrtRound(init: PowerScale<Double>.() -> Unit = {}) =\n            PowerScale(.5, ::interpolateRound, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun time(init: TimeScale<Double>.() -> Unit = {}) =\n            TimeScale(::interpolateNumber, ::uninterpolateNumber, naturalOrder()).apply(init)\n\n        fun sequential(interpolator: Interpolator<Double>) = SequentialScale(interpolator)\n    }\n\n    object Quantized {\n        fun <R> quantile(init: QuantileScale<R>.() -> Unit = {}): QuantileScale<R> = QuantileScale<R>().apply(init)\n        fun <R> quantize(init: QuantizeScale<R>.() -> Unit = {}): QuantizeScale<R> = QuantizeScale<R>().apply(init)\n        fun <R> threshold(init: ThresholdScale<R>.() -> Unit = {}): ThresholdScale<R> = ThresholdScale<R>().apply(init)\n    }\n\n    object Discrete {\n        fun <D> point(init: PointScale<D>.() -> Unit = {}) = PointScale<D>().apply(init)\n        fun <D> band(init: BandScale<D>.() -> Unit = {}) = BandScale<D>().apply(init)\n        fun <D, R> ordinal(init: OrdinalScale<D, R>.() -> Unit = {}) = OrdinalScale<D, R>().apply(init)\n    }\n}\n\n/**\n * Access the data2viz collection of chromatic scales.\n * To create a non-color scale use Scales instead.\n * Available factories:\n *\n * ScalesChromatic\n *      Continuous              (continuous color scales with pre-configured interpolators)\n *          -> linearRGB\n *          -> linearLAB\n *          -> linearHSL\n *          -> ...\n *      Sequential              (continuous color scales with pre-configured interpolators and color scheme)\n *          SingleHue               (will scale over a single hue ie. white -> blue)\n *              -> blues\n *              -> greens\n *              -> ...\n *          MultiHue                (convergent scales with multiple hues ie. blue -> green)\n *              -> viridis\n *              -> plasma\n *              -> blue_green\n *              -> ...\n *          Diverging               (divergent scales with multiple hues ie. blue -> white -> red for temperature)\n *              -> pink_green\n *              -> red_blue\n *              -> ...\n *          Cyclical                (these color scales cycle: start color = end color)\n *              -> rainbow\n *              -> sinebow\n *      Discrete                (contrasted color scheme for discrete domain scales)\n *          -> category10\n *          -> accent8\n *          -> paired12\n *          -> ...\n */\nobject ScalesChromatic {\n\n    object Continuous {\n        fun linearRGB(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::rgbLinearInterpolator).apply(init)\n        fun defaultRGB(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::rgbDefaultInterpolator).apply(init)\n        fun linearLAB(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::labInterpolator).apply(init)\n        fun linearHCL(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::hclInterpolator).apply(init)\n        fun linearHCLLong(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::hclLongInterpolator).apply(init)\n        fun linearHSL(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::hslInterpolator).apply(init)\n        fun linearHSLLong(init: LinearScale<Color>.() -> Unit = {}) = LinearScale(::hslLongInterpolator).apply(init)\n    }\n\n    // TODO these scales should also be available as \"ordinal scales\"\n    object Sequential {\n\n        object SingleHue {\n            fun blues(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.blues.last().colors)).apply(init)\n\n            fun greens(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.greens.last().colors)).apply(init)\n\n            fun greys(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.greys.last().colors)).apply(init)\n\n            fun oranges(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.oranges.last().colors)).apply(init)\n\n            fun purples(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.purples.last().colors)).apply(init)\n\n            fun reds(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.reds.last().colors)).apply(init)\n        }\n\n        // TODO warm, cool, cubehelix\n        // TODO YlOrBr, YlOrRd\n        object MultiHue {\n            fun viridis(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.viridis.colors)).apply(init)\n\n            fun magma(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.magma.colors)).apply(init)\n\n            fun inferno(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.inferno.colors)).apply(init)\n\n            fun plasma(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.plasma.colors)).apply(init)\n\n            fun blue_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.BuGN.last().colors)).apply(init)\n\n            fun blue_purple(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.BuPu.last().colors)).apply(init)\n\n            fun green_blue(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.GnBu.last().colors)).apply(init)\n\n            fun orange_red(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.OrRd.last().colors)).apply(init)\n\n            fun purple_blue(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PuBu.last().colors)).apply(init)\n\n            fun purple_blue_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PuBuGn.last().colors)).apply(init)\n\n            fun purple_red(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PuRd.last().colors)).apply(init)\n\n            fun red_purple(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.RdPu.last().colors)).apply(init)\n\n            fun yellow_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.YlGn.last().colors)).apply(init)\n\n            fun yellow_green_blue(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.YlGnbU.last().colors)).apply(init)\n\n            fun yellow_green_brown(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.YlGnBr.last().colors)).apply(init)\n\n            fun yellow_green_red(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.YlGnRd.last().colors)).apply(init)\n        }\n\n        object Diverging {\n            fun brown_blueGreen(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.BrBG.last().colors)).apply(init)\n\n            fun pink_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PiYG.last().colors)).apply(init)\n\n            fun purple_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PRGn.last().colors)).apply(init)\n\n            fun purple_orange(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.PuOR.last().colors)).apply(init)\n\n            fun red_blue(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.RdBU.last().colors)).apply(init)\n\n            fun red_grey(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.RdGY.last().colors)).apply(init)\n\n            fun red_yelow_blue(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.RdYlBu.last().colors)).apply(init)\n\n            fun red_yellow_green(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.RdYlGn.last().colors)).apply(init)\n\n            fun spectral(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbBasisInterpolator(EncodedColors.spectral.last().colors)).apply(init)\n        }\n\n        // TODO rainbow\n        object Cyclical {\n            fun sineBow(init: SequentialScale<Color>.() -> Unit = {}) =\n                SequentialScale(rgbSineBowInterpolator()).apply(init)\n        }\n    }\n\n    object Discrete {\n        fun <D> accent8(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.accents.colors).apply(init)\n\n        fun <D> dark8(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.dark2.colors).apply(init)\n\n        fun <D> paired12(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.paired.colors).apply(init)\n\n        fun <D> pastel9(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.pastel1.colors).apply(init)\n\n        fun <D> pastel8(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.pastel2.colors).apply(init)\n\n        fun <D> vivid9(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.set1.colors).apply(init)\n\n        fun <D> vivid8(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.set2.colors).apply(init)\n\n        fun <D> pale12(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.set3.colors).apply(init)\n\n        fun <D> category10(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.category10.colors).apply(init)\n\n        fun <D> categoryA20(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.category20.colors).apply(init)\n\n        fun <D> categoryB20(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.category20b.colors).apply(init)\n\n        fun <D> categoryC20(init: OrdinalScale<D, Color>.() -> Unit = {}) =\n            OrdinalScale<D, Color>(EncodedColors.category20c.colors).apply(init)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package io.data2viz.scale\n\nimport io.data2viz.interpolate.Interpolator\nimport io.data2viz.interpolate.uninterpolateNumber\n\n\n/**\n * Sequential scales are similar to continuous scales in that they map a continuous numeric input domain to a\n * continuous output range. However, unlike continuous scales, the output range of a sequential scale is fixed\n * by its interpolator and not configurable.\n *\n * These scales do not expose invert, range, rangeRound and interpolate methods.\n */\nclass SequentialScale<R>\ninternal constructor(var interpolator: Interpolator<R>) : Tickable<Double>, ClampableScale,\n    StrictlyContinuousDomain<Double> {\n\n    override var domain: StrictlyContinuous<Double> = intervalOf(0.0, 1.0)\n\n    override var clamp: Boolean = false\n\n    operator fun invoke(domainValue: Double): R {\n        var uninterpolatedDomain = uninterpolateNumber(domain.start, domain.end)(domainValue)\n        if (clamp) uninterpolatedDomain = uninterpolatedDomain.coerceToDefault()\n        return interpolator(uninterpolatedDomain)\n    }\n\n    override fun ticks(count: Int) = io.data2viz.math.ticks(domain.start, domain.end, count)\n}\n\n","package io.data2viz.scale\n\n/**\n * Threshold scales are similar to quantize scales, except they allow you to map arbitrary subsets of the\n * domain to discrete values in the range.\n * The input domain is still continuous, and divided into slices based on a set of threshold values.\n */\nclass ThresholdScale<R> internal constructor() : Scale<Double, R>, DiscreteRange<R>, DiscreteDomain<Double> {\n\n\n    var _domain: List<Double> = listOf(.5)\n    var _range: List<R> = listOf()\n\n    /**\n     * Sets the scale\u2019s range to the specified array of values.\n     * If the number of values in the scale\u2019s domain is N, the number of values in the scale\u2019s range must be N+1.\n     */\n    override var range: List<R>\n        get() = _range.toList()\n        set(value) {\n            _range = value.toList()\n        }\n\n    /**\n     * Sets the scale\u2019s domain to the specified array of values.\n     * The values must be in sorted ascending order, or the behavior of the scale is undefined.\n     * The values are typically numbers, but any naturally ordered values (such as strings) will work; a threshold\n     * scale can be used to encode any type that is ordered.\n     * If the number of values in the scale\u2019s range is N+1, the number of values in the scale\u2019s domain must be N.\n     */\n    override var domain: List<Double>\n        get() = _domain.toList()\n        set(value) {\n            require(value.sorted() == value, { \"The domain must be sorted in ascending order.\" })\n            _domain = value.toList()\n        }\n\n\n    /**\n     * Given a value in the input domain, returns the corresponding value in the output range.\n     */\n    override fun invoke(domainValue: Double): R {\n        check(_range.size == _domain.size + 1,\n            { \"The range size (actual: ${_range.size}) must be 1 more than the domain size (actual: ${_domain.size}).\" })\n        return _range[bisectRight(_domain, domainValue, naturalOrder<Double>(), 0, _domain.size)]\n    }\n\n    /**\n     * Returns the extent of values in the domain [x0, x1] for the corresponding value in the range,\n     * representing the inverse mapping from range to domain.\n     * This method is useful for interaction, say to determine the value in the domain that corresponds to the\n     * pixel location under the mouse.\n     */\n    fun invertExtent(rangeValue: R): List<Double> {\n        check(_range.size == _domain.size + 1,\n            { \"The range size (actual: ${_range.size}) must be 1 more than the domain size (actual: ${_domain.size}).\" })\n        val i = _range.indexOf(rangeValue)\n        val size = _range.size - 1\n        return when {\n            i < 0 || i > size -> listOf(Double.NaN, Double.NaN)\n            i == 0 -> listOf(Double.NaN, _domain.first())\n            i == size -> listOf(domain.last(), Double.NaN)\n            else -> listOf(_domain[i - 1], _domain[i])\n        }\n    }\n}\n\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual interface Comparator<T> {\n    @JsName(\"compare\")\n    actual fun compare(a: T, b: T): Int\n}\n\npublic actual inline fun <T> Comparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> = object : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparison(a, b)\n}\n"],"names":[],"mappings":"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AA,OAAe,I;IACf,oB;MAAA,OAAmD,4B;IAEwB,gBAA3E,aAAS,IAAT,4D;aPnIZ,6B;IOmI2B,CAAf,+D;aPnIZ,+B;IOmIgD,CAApC,GAA2D,cAA3D,C;IAAiF,IC1DzF,W;ID0DQ,OCzDD,S;EDyDC,C;;IAKS,oB;MAAA,OAAe,I;IACxB,oBAAS,IAAT,2D;aPzIZ,4B;IOyI2B,CAAf,+D;aPzIZ,+B;IOyI+C,CAAnC,GAA0D,cAA1D,C;EAAA,C;;IAE8C,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,+B;IACgC,gBAA7E,yE;aP5IZ,4B;IO4IwB,CAAZ,iE;aP5IZ,iC;IO4I4C,CAAhC,GAAyD,sBAAzD,C;IAAmF,ICnE3F,W;IDmEQ,OClED,S;EDkEC,C;;IAEmE,W;EAAA,C;;IAA/D,wB;MAAA,WAAmB,G;IAAK,oB;MAAA,OAAsC,4B;IACe,gBAAjF,eAAW,QAAX,4D;aP/IZ,6B;IO+IiC,CAArB,+D;aP/IZ,+B;IO+IsD,CAA1C,GAAiE,cAAjE,C;IAAuF,ICtE/F,W;IDsEQ,OCrED,S;EDqEC,C;;IAEwE,W;EAAA,C;;IAA/D,wB;MAAA,WAAmB,G;IAAK,oB;MAAA,OAAsC,iC;IACS,gBAAhF,eAAW,QAAX,2D;aPlJZ,4B;IOkJiC,CAArB,+D;aPlJZ,+B;IOkJqD,CAAzC,GAAgE,cAAhE,C;IAAsF,ICzE9F,W;IDyEQ,OCxED,S;EDwEC,C;;IAG4C,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,6B;IACgC,gBAA3E,eAAW,GAAX,4D;aPtJZ,6B;IOsJ2B,CAAf,+D;aPtJZ,+B;IOsJgD,CAApC,GAA2D,cAA3D,C;IAAiF,IC7EzF,W;ID6EQ,OC5ED,S;ED4EC,C;;IAEiD,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,kC;IAC0B,gBAA1E,eAAW,GAAX,2D;aPzJZ,4B;IOyJ2B,CAAf,+D;aPzJZ,+B;IOyJ+C,CAAnC,GAA0D,cAA1D,C;IAAgF,IChFxF,W;IDgFQ,OC/ED,S;ED+EC,C;;IAE2C,W;EAAA,C;;IAAtC,oB;MAAA,OAAqC,6B;IAC4B,gBAAtE,wE;aP5JZ,6B;IO4JsB,CAAV,+D;aP5JZ,+B;IO4J2C,CAA/B,GAAsD,cAAtD,C;IAA4E,ICnFpF,W;IDmFQ,OClFD,S;EDkFC,C;;IAEiD,2BAAgB,YAAhB,C;EAAA,C;;;;;;;;IAlDzD,wC;MAAA,uB;;IAAA,iC;EAAA,C;;IAqDA,gC;EAAA,C;;IAC0D,W;EAAA,C;;IAArC,oB;MAAA,OAAoC,gC;IAA2C,gBAAnB,mB;IAAyB,ICzF1G,W;IDyFiF,OCxF1E,S;EDwF0E,C;;IACvB,W;EAAA,C;;IAArC,oB;MAAA,OAAoC,gC;IAA2C,gBAAnB,mB;IAAyB,IC1F1G,W;ID0FiF,OCzF1E,S;EDyF0E,C;;IACrB,W;EAAA,C;;IAAtC,oB;MAAA,OAAqC,iC;IAA6C,gBAApB,oB;IAA0B,IC3F9G,W;ID2FoF,OC1F7E,S;ED0F6E,C;;;;;;;;IAHpF,uC;MAAA,sB;;IAAA,gC;EAAA,C;;IAMA,+B;EAAA,C;;IACoD,W;EAAA,C;;IAAlC,oB;MAAA,OAAiC,4B;IAAsB,gBAAhB,gB;IAAsB,IC/F/E,W;ID+FyD,OC9FlD,S;ED8FkD,C;;IACP,W;EAAA,C;;IAAjC,oB;MAAA,OAAgC,2B;IAAqB,gBAAf,e;IAAqB,IChG5E,W;IDgGuD,OC/FhD,S;ED+FgD,C;;IACO,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,8B;IAA2B,gBAArB,kB;IAA2B,ICjG9F,W;IDiGmE,OChG5D,S;EDgG4D,C;;;;;;;;IAHnE,sC;MAAA,qB;;IAAA,+B;EAAA,C;;;;;;;;IAjFJ,6B;MAAA,Y;;IAAA,sB;EAAA,C;;IAwFA,+B;EAAA,C;;IAoCI,0C;EAAA,C;;IACyD,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,2C;IAA2C,gBAArC,8E;aPnNlE,iC;IOmN8E,CAAZ,E;IAA2C,IC1IzG,W;ID0I8D,OCzIvD,S;EDyIuD,C;;IACJ,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,4C;IAA4C,gBAAtC,+E;aPpNnE,kC;IOoN+E,CAAZ,E;IAA4C,IC3I3G,W;ID2I+D,OC1IxD,S;ED0IwD,C;;IACN,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,2C;IAAqC,gBAA/B,wE;aPrNlE,2B;IOqN8E,CAAZ,E;IAAqC,IC5InG,W;ID4I8D,OC3IvD,S;ED2IuD,C;;IACL,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,2C;IAAqC,gBAA/B,wE;aPtNlE,2B;IOsN8E,CAAZ,E;IAAqC,IC7InG,W;ID6I8D,OC5IvD,S;ED4IuD,C;;IACD,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,+C;IAAyC,gBAAnC,4E;aPvNtE,+B;IOuNkF,CAAZ,E;IAAyC,IC9I3G,W;ID8IkE,OC7I3D,S;ED6I2D,C;;IACT,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,2C;IAAqC,gBAA/B,wE;aPxNlE,2B;IOwN8E,CAAZ,E;IAAqC,IC/InG,W;ID+I8D,OC9IvD,S;ED8IuD,C;;IACD,W;EAAA,C;;IAAvC,oB;MAAA,OAAsC,+C;IAAyC,gBAAnC,4E;aPzNtE,+B;IOyNkF,CAAZ,E;IAAyC,IChJ3G,W;IDgJkE,OC/I3D,S;ED+I2D,C;;;;;;;;IAPlE,iD;MAAA,gC;;IAAA,0C;EAAA,C;;IAUA,0C;EAAA,C;;IAGI,oD;EAAA,C;;IACyD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,iD;IACyB,gBAAzE,oBAAgB,qBAAyC,KAApB,uBAAc,MAAM,CAAO,OAAhD,CAAhB,C;IAA+E,ICxJ3F,W;IDwJY,OCvJL,S;EDuJK,C;;IAEkD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,kD;IACyB,gBAA1E,oBAAgB,qBAA0C,KAArB,uBAAc,OAAO,CAAO,OAAjD,CAAhB,C;IAAgF,IC3J5F,W;ID2JY,OC1JL,S;ED0JK,C;;IAEiD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,iD;IACyB,gBAAzE,oBAAgB,qBAAyC,KAApB,uBAAc,MAAM,CAAO,OAAhD,CAAhB,C;IAA+E,IC9J3F,W;ID8JY,OC7JL,S;ED6JK,C;;IAEmD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,mD;IACyB,gBAA3E,oBAAgB,qBAA2C,KAAtB,uBAAc,QAAQ,CAAO,OAAlD,CAAhB,C;IAAiF,ICjK7F,W;IDiKY,OChKL,S;EDgKK,C;;IAEmD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,mD;IA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,OAAO,CAAO,OAAjD,CAAhB,C;IAAgF,ICrP5F,W;IDqPY,OCpPL,S;EDoPK,C;;IAEoD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,oD;IACyB,gBAA5E,oBAAgB,qBAA4C,KAAvB,uBAAc,SAAS,CAAO,OAAnD,CAAhB,C;IAAkF,ICxP9F,W;IDwPY,OCvPL,S;EDuPK,C;;;;;;;;IA1BR,2D;MAAA,0C;;IAAA,oD;EAAA,C;;IA6BA,mD;EAAA,C;;IAE2D,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,kD;IACR,gBAA1C,oBAAgB,wBAAhB,C;IAAgD,IC9P5D,W;ID8PY,OC7PL,S;ED6PK,C;;;;;;;;IAHR,0D;MAAA,yC;;IAAA,mD;EAAA,C;;;;;;;;IAxGJ,iD;MAAA,gC;;IAAA,0C;EAAA,C;;IA+GA,wC;EAAA,C;;IAC+D,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,uC;IACD,gBAArD,iBAAuB,uBAAc,QAAQ,OAA7C,C;IAA2D,ICpQnE,W;IDoQQ,OCnQD,S;EDmQC,C;;IAEqD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,qC;IACD,gBAAnD,iBAAuB,uBAAc,MAAM,OAA3C,C;IAAyD,ICvQjE,W;IDuQQ,OCtQD,S;EDsQC,C;;IAEwD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,wC;IACH,gBAApD,iBAAuB,uBAAc,OAAO,OAA5C,C;IAA0D,IC1QlE,W;ID0QQ,OCzQD,S;EDyQC,C;;IAEuD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,uC;IACD,gBAArD,iBAAuB,uBAAc,QAAQ,OAA7C,C;IAA2D,IC7QnE,W;ID6QQ,OC5QD,S;ED4QC,C;;IAEuD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,uC;IACD,gBAArD,iBAAuB,uBAAc,QAAQ,OAA7C,C;IAA2D,IChRnE,W;IDgRQ,OC/QD,S;ED+QC,C;;IAEsD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,sC;IACH,gBAAlD,iBAAuB,uBAAc,KAAK,OAA1C,C;IAAwD,ICnRhE,W;IDmRQ,OClRD,S;EDkRC,C;;IAEsD,W;EAAA,C;;IAA3C,oB;MAAA,OAA0C,sC;IACH,gBAAl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"}