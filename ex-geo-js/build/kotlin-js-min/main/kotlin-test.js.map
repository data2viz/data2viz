{"version":3,"file":"kotlin-test.js","sources":["./Assertions.kt","./DefaultAsserter.kt","./Utils.kt","./src/main/kotlin/JsTestApi.kt","./src/main/kotlin/kotlin/test/Annotations.kt","./src/main/kotlin/kotlin/test/DefaultJsAsserter.kt","./src/main/kotlin/kotlin/test/JsImpl.kt","./src/main/kotlin/kotlin/test/TestApi.kt","./src/main/kotlin/kotlin/test/adapters/BareAdapter.kt","./src/main/kotlin/kotlin/test/adapters/Externals.kt","./kotlin/jsTypeOf.kt","./src/main/kotlin/kotlin/test/adapters/JasmineLikeAdapter.kt","./src/main/kotlin/kotlin/test/adapters/QUnitAdapter.kt","./dummy.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * A number of helper methods for writing unit tests.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"AssertionsKt\")\n@file:Suppress(\"INVISIBLE_MEMBER\", \"INVISIBLE_REFERENCE\")\n\npackage kotlin.test\n\nimport kotlin.contracts.*\nimport kotlin.internal.*\nimport kotlin.reflect.KClass\n\n/**\n * Current adapter providing assertion implementations\n */\nval asserter: Asserter\n    get() = _asserter ?: lookupAsserter()\n\n/** Used to override current asserter internally */\ninternal var _asserter: Asserter? = null\n\n/** Asserts that the given [block] returns `true`. */\nfun assertTrue(message: String? = null, block: () -> Boolean): Unit = assertTrue(block(), message)\n\n/** Asserts that the expression is `true` with an optional [message]. */\nfun assertTrue(actual: Boolean, message: String? = null) {\n    contract { returns() implies actual }\n    return asserter.assertTrue(message ?: \"Expected value to be true.\", actual)\n}\n\n/** Asserts that the given [block] returns `false`. */\nfun assertFalse(message: String? = null, block: () -> Boolean): Unit = assertFalse(block(), message)\n\n/** Asserts that the expression is `false` with an optional [message]. */\nfun assertFalse(actual: Boolean, message: String? = null) {\n    contract { returns() implies (!actual) }\n    return asserter.assertTrue(message ?: \"Expected value to be false.\", !actual)\n}\n\n/** Asserts that the [expected] value is equal to the [actual] value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertEquals(expected: T, actual: T, message: String? = null) {\n    asserter.assertEquals(message, expected, actual)\n}\n\n/** Asserts that the [actual] value is not equal to the illegal value, with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotEquals(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotEquals(message, illegal, actual)\n}\n\n/** Asserts that [expected] is the same instance as [actual], with an optional [message]. */\nfun <@OnlyInputTypes T> assertSame(expected: T, actual: T, message: String? = null) {\n    asserter.assertSame(message, expected, actual)\n}\n\n/** Asserts that [actual] is not the same instance as [illegal], with an optional [message]. */\nfun <@OnlyInputTypes T> assertNotSame(illegal: T, actual: T, message: String? = null) {\n    asserter.assertNotSame(message, illegal, actual)\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message]. */\nfun <T : Any> assertNotNull(actual: T?, message: String? = null): T {\n    contract { returns() implies (actual != null) }\n    asserter.assertNotNull(message, actual)\n    return actual!!\n}\n\n/** Asserts that the [actual] value is not `null`, with an optional [message] and a function [block] to process the not-null value. */\nfun <T : Any, R> assertNotNull(actual: T?, message: String? = null, block: (T) -> R) {\n    contract { returns() implies (actual != null) }\n    asserter.assertNotNull(message, actual)\n    if (actual != null) {\n        block(actual)\n    }\n}\n\n/** Asserts that the [actual] value is `null`, with an optional [message]. */\nfun assertNull(actual: Any?, message: String? = null) {\n    asserter.assertNull(message, actual)\n}\n\n/** Marks a test as having failed if this point in the execution path is reached, with an optional [message]. */\nfun fail(message: String? = null): Nothing {\n    asserter.fail(message)\n}\n\n/** Asserts that given function [block] returns the given [expected] value. */\nfun <@OnlyInputTypes T> expect(expected: T, block: () -> T) {\n    assertEquals(expected, block())\n}\n\n/** Asserts that given function [block] returns the given [expected] value and use the given [message] if it fails. */\nfun <@OnlyInputTypes T> expect(expected: T, message: String?, block: () -> T) {\n    assertEquals(expected, block(), message)\n}\n\n/** Asserts that given function [block] fails by throwing an exception. */\nfun assertFails(block: () -> Unit): Throwable = assertFails(null, block)\n\n/**\n * Asserts that given function [block] fails by throwing an exception.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n */\n@SinceKotlin(\"1.1\")\nfun assertFails(message: String?, block: () -> Unit): Throwable {\n    try {\n        block()\n    } catch (e: Throwable) {\n        assertEquals(e.message, e.message) // success path assertion for qunit\n        return e\n    }\n    asserter.fail(messagePrefix(message) + \"Expected an exception to be thrown, but was completed successfully.\")\n}\n\n/** Asserts that a [block] fails with a specific exception of type [T] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n */\n@InlineOnly\ninline fun <reified T : Throwable> assertFailsWith(message: String? = null, noinline block: () -> Unit): T =\n    assertFailsWith(T::class, message, block)\n\n/** Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown. */\nfun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, block: () -> Unit): T = assertFailsWith(exceptionClass, null, block)\n\n\n/**\n * Abstracts the logic for performing assertions. Specific implementations of [Asserter] can use JUnit\n * or TestNG assertion facilities.\n */\ninterface Asserter {\n    /**\n     * Fails the current test with the specified message.\n     *\n     * @param message the message to report.\n     */\n    fun fail(message: String?): Nothing\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param lazyMessage the function to return a message to report if the assertion fails.\n     */\n    fun assertTrue(lazyMessage: () -> String?, actual: Boolean): Unit {\n        if (!actual) {\n            fail(lazyMessage())\n        }\n    }\n\n    /**\n     * Asserts that the specified value is `true`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertTrue(message: String?, actual: Boolean): Unit {\n        assertTrue({ message }, actual)\n    }\n\n    /**\n     * Asserts that the specified values are equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertEquals(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual>.\" }, actual == expected)\n    }\n\n    /**\n     * Asserts that the specified values are not equal.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotEquals(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Illegal value: <$actual>.\" }, actual != illegal)\n    }\n\n    /**\n     * Asserts that the specified values are the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertSame(message: String?, expected: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected <$expected>, actual <$actual> is not same.\" }, actual === expected)\n    }\n\n    /**\n     * Asserts that the specified values are not the same instance.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotSame(message: String?, illegal: Any?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected not same as <$actual>.\" }, actual !== illegal)\n    }\n\n    /**\n     * Asserts that the specified value is `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be null, but was: <$actual>.\" }, actual == null)\n    }\n\n    /**\n     * Asserts that the specified value is not `null`.\n     *\n     * @param message the message to report if the assertion fails.\n     */\n    fun assertNotNull(message: String?, actual: Any?): Unit {\n        assertTrue({ messagePrefix(message) + \"Expected value to be not null.\" }, actual != null)\n    }\n\n}\n\n/**\n * Checks applicability and provides Asserter instance\n */\ninterface AsserterContributor {\n    /**\n     * Provides [Asserter] instance or `null` depends on the current context.\n     *\n     * @return asserter instance or null if it is not applicable now\n     */\n    fun contribute(): Asserter?\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Default [Asserter] implementation to avoid dependency on JUnit or TestNG.\n */\n// TODO: make object in 1.2\nclass DefaultAsserter : Asserter {\n    override fun fail(message: String?): Nothing {\n        if (message == null)\n            throw AssertionError()\n        else\n            throw AssertionError(message)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\ninternal fun messagePrefix(message: String?) = if (message == null) \"\" else \"$message. \"\ninternal expect fun lookupAsserter(): Asserter\n\n@PublishedApi // required to get stable name as it's called from box tests\ninternal fun overrideAsserter(value: Asserter?): Asserter? {\n    // TODO: Replace with return _asserter.also { _asserter = value } after KT-17540 is fixed\n    val previous = _asserter\n    _asserter = value\n    return previous\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\nimport kotlin.test.*\n\n/**\n * Functions in this file are exposed in the root package to simplify their use from JavaScript.\n * For example: require('kotlin-test').setAdapter({ /* Your custom [FrameworkAdapter] here */ });\n */\n\n/**\n * Overrides current framework adapter with a provided instance of [FrameworkAdapter]. Use in order to support custom test frameworks.\n *\n * Also some string arguments are supported. Use \"qunit\" to set the adapter to [QUnit](https://qunitjs.com/), \"mocha\" for\n * [Mocha](https://mochajs.org/), \"jest\" for [Jest](https://facebook.github.io/jest/),\n * \"jasmine\" for [Jasmine](https://github.com/jasmine/jasmine), and \"auto\" to detect one of those frameworks automatically.\n *\n * If this function is not called, the test framework will be detected automatically (as if \"auto\" was passed).\n *\n */\n@JsName(\"setAdapter\")\ninternal fun setAdapter(adapter: dynamic) = kotlin.test.setAdapter(adapter)","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Marks a function as a test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class Test\n\n/**\n * Marks a test or a suite as ignored.\n */\n@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)\npublic actual annotation class Ignore\n\n/**\n * Marks a function to be invoked before each test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class BeforeTest\n\n/**\n * Marks a function to be invoked after each test.\n */\n@Target(AnnotationTarget.FUNCTION)\npublic actual annotation class AfterTest\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\n/**\n * Describes the result of an assertion execution.\n */\npublic external interface AssertionResult {\n    val result: Boolean\n    val expected: Any?\n    val actual: Any?\n    val lazyMessage: () -> String?\n}\n\ninternal var assertHook: (AssertionResult) -> Unit = { _ -> }\n\ninternal object DefaultJsAsserter : Asserter {\n    private var e: Any? = undefined\n    private var a: Any? = undefined\n\n    override fun assertEquals(message: String?, expected: Any?, actual: Any?) {\n        e = expected\n        a = actual\n        super.assertEquals(message, expected, actual)\n    }\n\n    override fun assertNotEquals(message: String?, illegal: Any?, actual: Any?) {\n        e = illegal\n        a = actual\n        super.assertNotEquals(message, illegal, actual)\n    }\n\n    override fun assertSame(message: String?, expected: Any?, actual: Any?) {\n        e = expected\n        a = actual\n        super.assertSame(message, expected, actual)\n    }\n\n    override fun assertNotSame(message: String?, illegal: Any?, actual: Any?) {\n        e = illegal\n        a = actual\n        super.assertNotSame(message, illegal, actual)\n    }\n\n    override fun assertNull(message: String?, actual: Any?) {\n        a = actual\n        super.assertNull(message, actual)\n    }\n\n    override fun assertNotNull(message: String?, actual: Any?) {\n        a = actual\n        super.assertNotNull(message, actual)\n    }\n\n    override fun assertTrue(lazyMessage: () -> String?, actual: Boolean) {\n        if (!actual) {\n            failWithMessage(lazyMessage)\n        } else {\n            invokeHook(true, lazyMessage)\n        }\n    }\n\n    override fun assertTrue(message: String?, actual: Boolean) {\n        assertTrue({ message }, actual)\n    }\n\n    override fun fail(message: String?): Nothing {\n        failWithMessage { message }\n    }\n\n    private fun failWithMessage(lazyMessage: () -> String?): Nothing {\n        val message = lazyMessage()\n        invokeHook(false) { message }\n        if (message == null)\n            throw AssertionError()\n        else\n            throw AssertionError(message)\n    }\n\n    private fun invokeHook(result: Boolean, lazyMessage: () -> String?) {\n        try {\n            assertHook(object : AssertionResult {\n                override val result: Boolean = result\n                override val expected: Any? = e\n                override val actual: Any? = a\n                override val lazyMessage: () -> String? = lazyMessage\n            })\n        } finally {\n            e = undefined\n            a = undefined\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.reflect.KClass\n\n/**\n * Comments out a block of test code until it is implemented while keeping a link to the code\n * to implement in your unit test output\n */\nactual fun todo(block: () -> Unit) {\n    // println(\"TODO at \" + (Exception() as java.lang.Throwable).getStackTrace()?.get(1) + \" for \" + block)\n    println(\"TODO at \" + block)\n}\n\n\n/**\n * Asserts that a [block] fails with a specific exception of type [exceptionClass] being thrown.\n *\n * If the assertion fails, the specified [message] is used unless it is null as a prefix for the failure message.\n */\nactual fun <T : Throwable> assertFailsWith(exceptionClass: KClass<T>, message: String?, block: () -> Unit): T {\n    val exception = assertFails(message, block)\n    @Suppress(\"INVISIBLE_MEMBER\")\n    assertTrue(exceptionClass.isInstance(exception), messagePrefix(message) + \"Expected an exception of $exceptionClass to be thrown, but was $exception\")\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return exception as T\n}\n\n\n/**\n * Provides the JS implementation of asserter\n */\ninternal actual fun lookupAsserter(): Asserter = DefaultJsAsserter","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test\n\nimport kotlin.test.adapters.*\n\n/**\n * Overrides current framework adapter with a provided instance of [FrameworkAdapter]. Use in order to support custom test frameworks.\n *\n * Also some string arguments are supported. Use \"qunit\" to set the adapter to [QUnit](https://qunitjs.com/), \"mocha\" for\n * [Mocha](https://mochajs.org/), \"jest\" for [Jest](https://facebook.github.io/jest/),\n * \"jasmine\" for [Jasmine](https://github.com/jasmine/jasmine), and \"auto\" to detect one of those frameworks automatically.\n *\n * If this function is not called, the test framework will be detected automatically (as if \"auto\" was passed).\n *\n */\ninternal fun setAdapter(adapter: dynamic) {\n    if (js(\"typeof adapter === 'string'\")) {\n        NAME_TO_ADAPTER[adapter]?.let {\n            setAdapter(it.invoke())\n        } ?: throw IllegalArgumentException(\"Unsupported test framework adapter: '$adapter'\")\n    } else {\n        currentAdapter = adapter\n    }\n}\n\n/**\n * Use in order to define which action should be taken by the test framework on the [AssertionResult].\n */\ninternal fun setAssertHook(hook: (AssertionResult) -> Unit) {\n    assertHook = hook\n}\n\n\n/**\n * The functions below are used by the compiler to describe the tests structure, e.g.\n *\n * suite('a suite', false, function() {\n *   suite('a subsuite', false, function() {\n *     test('a test', false, function() {...});\n *     test('an ignored/pending test', true, function() {...});\n *   });\n *   suite('an ignored/pending test', true, function() {...});\n * });\n */\n\n@JsName(\"suite\")\ninternal fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n    adapter().suite(name, ignored, suiteFn)\n}\n\n@JsName(\"test\")\ninternal fun test(name: String, ignored: Boolean, testFn: () -> Unit) {\n    adapter().test(name, ignored, testFn)\n}\n\ninternal var currentAdapter: FrameworkAdapter? = null\n\ninternal fun adapter(): FrameworkAdapter {\n    val result = currentAdapter ?: detectAdapter()\n    currentAdapter = result\n    return result\n}\n\n\ninternal fun detectAdapter() = when {\n    isQUnit() -> QUnitAdapter()\n    isJasmine() -> JasmineLikeAdapter()\n    else -> BareAdapter()\n}\n\ninternal val NAME_TO_ADAPTER: Map<String, () -> FrameworkAdapter> = mapOf(\n    \"qunit\" to ::QUnitAdapter,\n    \"jasmine\" to ::JasmineLikeAdapter,\n    \"mocha\" to ::JasmineLikeAdapter,\n    \"jest\" to ::JasmineLikeAdapter,\n    \"auto\" to ::detectAdapter\n)","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\n\n/**\n * A fallback adapter for the case when no framework is detected.\n */\ninternal open class BareAdapter : FrameworkAdapter {\n\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        if (!ignored) {\n            suiteFn()\n        }\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Unit) {\n        if (!ignored) {\n            testFn()\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\n/**\n * The [QUnit](http://qunitjs.com/) API\n */\ninternal external object QUnit {\n    fun module(name: String, suiteFn: () -> Unit): Unit\n    fun test(name: String, testFn: (dynamic) -> Unit): Unit\n    fun skip(name: String, testFn: (dynamic) -> Unit): Unit\n}\n\n/*\n * Jasmine/Mocha/Jest API\n */\n\ninternal external fun describe(name: String, fn: () -> Unit)\ninternal external fun xdescribe(name: String, fn: () -> Unit)\ninternal external fun it(name: String, fn: () -> Unit)\ninternal external fun xit(name: String, fn: () -> Unit)\n\ninternal fun isQUnit() = jsTypeOf(QUnit) !== \"undefined\"\n\ninternal fun isJasmine() = js(\"typeof describe === 'function' && typeof it === 'function'\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Function corresponding to JavaScript's `typeof` operator\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"UNUSED_PARAMETER\")\npublic inline fun jsTypeOf(a: Any?): String = js(\"typeof a\")\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\n\n/**\n * [Jasmine](https://github.com/jasmine/jasmine) adapter.\n * Also used for [Mocha](https://mochajs.org/) and [Jest](https://facebook.github.io/jest/).\n */\ninternal class JasmineLikeAdapter : FrameworkAdapter {\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        if (ignored) {\n            xdescribe(name, suiteFn)\n        } else {\n            describe(name, suiteFn)\n        }\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Unit) {\n        if (ignored) {\n            xit(name, testFn)\n        } else {\n            it(name, testFn)\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.test.adapters\n\nimport kotlin.test.FrameworkAdapter\nimport kotlin.test.assertHook\nimport kotlin.test.assertTrue\n\n/**\n * [QUnit](http://qunitjs.com/) adapter\n */\ninternal class QUnitAdapter : FrameworkAdapter {\n    var ignoredSuite = false;\n\n    override fun suite(name: String, ignored: Boolean, suiteFn: () -> Unit) {\n        val prevIgnore = ignoredSuite\n        ignoredSuite = ignoredSuite or ignored\n        QUnit.module(name, suiteFn)\n        ignoredSuite = prevIgnore\n    }\n\n    override fun test(name: String, ignored: Boolean, testFn: () -> Unit) {\n        if (ignored or ignoredSuite) {\n            QUnit.skip(name, wrapTest(testFn))\n        } else {\n            QUnit.test(name, wrapTest(testFn))\n        }\n    }\n\n    private fun wrapTest(testFn: () -> Unit): (dynamic) -> Unit = { assert ->\n        var assertionsHappened = false\n        assertHook = { testResult ->\n            assertionsHappened = true\n            assert.ok(testResult.result, testResult.lazyMessage())\n        }\n        testFn()\n        if (!assertionsHappened) {\n            assertTrue(true, \"A test with no assertions is considered successful\")\n        }\n    }\n}",null],"names":[],"mappings":"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"}