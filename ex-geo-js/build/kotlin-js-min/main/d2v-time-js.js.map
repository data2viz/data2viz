{"version":3,"file":"d2v-time-js.js","sources":["../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/DateCommon.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Interval.kt","collections/Collections.kt","util/Preconditions.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Day.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Hour.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Millisecond.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Minute.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Month.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Second.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Weekday.kt","../../../../../d2v-time-common/src/main/kotlin/io/data2viz/time/Year.kt","../../../../src/main/kotlin/io/data2viz/time/Date.kt","../../../../src/main/kotlin/io/data2viz/time/js/Date.kt"],"sourcesContent":["package io.data2viz.time\n\nval durationSecond = 1000L\nval durationMinute = 60000L\nval durationHour = 3600000L\nval durationDay = 86400000L\nval durationWeek = 604800000L        // (day * 7)\nval durationMonth = 2592000000L      // (day * 30)\nval durationYear = 31536000000L      // (day * 365)\n\nfun date(\n        year: Int = 0,\n        month: Int = 1,\n        day: Int = 1,\n        hour: Int = 0,\n        minute: Int = 0,\n        second: Int = 0,\n        millisecond: Int = 0): Date {\n    return Date(year, month, day, hour, minute, second, millisecond)\n}\n\nfun date(date: Date): Date {\n    return Date(date.year(), date.month(), date.dayOfMonth(), date.hour(), date.minute(), date.second(), date.millisecond())\n}\n\nfun date(): Date {\n    return Date(currentYear(), currentMonth(), currentDay(), currentHour(), currentMinute(), currentSecond(), 0)\n}\n\nfun currentYear(): Int = Date().year()\nfun currentMonth():Int = Date().month() \nfun currentDay():Int = Date().dayOfMonth() \nfun currentHour():Int = Date().hour() \nfun currentMinute():Int = Date().minute() \nfun currentSecond():Int = Date().second() \n\n/**\n * A date-time without a time-zone in the ISO-8601 calendar system,\n * such as {@code 2007-12-03T10:15:30}.\n */\nexpect class Date {\n\n    constructor()\n    constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Int)\n    constructor(date: Date)\n\n    override fun toString(): String\n\n    fun isBefore(otherDate: Date): Boolean\n    fun millisecondsBetween(otherDate: Date): Long\n    fun daysBetween(otherDate: Date): Long\n    fun hoursBetween(otherDate: Date): Long\n\n    fun getTimezoneOffset(): Int\n\n    fun plusMilliseconds(milliseconds: Long)\n    //    fun plusSeconds(seconds:Long)\n//    fun plusMinutes(minutes:Long)\n    fun plusHours(hours: Long)\n\n    fun plusDays(days: Long)\n    fun plusMonths(months: Long)\n    fun plusYears(years: Long)\n\n    fun minusMilliseconds(milliseconds: Int): Date\n\n    fun setMillisecond(millisecond: Int)\n    fun setSecond(second: Int)\n    fun setMinute(minute: Int)\n    fun setHour(hour: Int)\n    fun setDayOfMonth(day: Int)\n    fun setMonth(month: Int)\n    fun setFullYear(year: Int)\n\n    fun millisecond(): Int\n    fun second(): Int\n    fun minute(): Int\n    fun hour(): Int\n    fun dayOfWeek(): Int\n    fun dayOfMonth(): Int\n    fun dayOfYear(): Int\n    fun month(): Int\n    fun year(): Int\n\n    /**\n     * Returns milliseconds from 1970-1-1 00:00\n     */\n    fun getTime(): Double\n\n//    operator fun minus(otherDate:Date): Date\n\n//    fun getTime(): Long\n\n//    fun getUTCHours(): Int\n\n//    fun setUTCMinutes(minutes:Int, seconds:Int): Long\n//    fun setUTCHours(hours:Int, minutes:Int?, seconds:Int?): Long\n}\n\noperator fun Date.compareTo(other: Date): Int {\n    val time = getTime()\n    val otherTime = other.getTime()\n\n    return when {\n        time < otherTime -> -1\n        time > otherTime -> 1\n        else -> 0\n    }\n}\n\n/*expect class Date {\n\n    public constructor()\n    public constructor(milliseconds: Long)\n    public constructor(year: Int, month: Int)\n    public constructor(year: Int, month: Int, day: Int)\n    public constructor(year: Int, month: Int, day: Int, hour: Int)\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int)\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int)\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Int)\n\n    public fun getTime(): Long\n    public fun getUTCHours(): Int\n\n    public fun setUTCMinutes(minutes:Int, seconds:Int): Long\n    public fun setUTCHours(hours:Int, minutes:Int?, seconds:Int?): Long\n}*/\n\n//expect class Date() {\n\n//    public constructor(milliseconds: Number)\n//    public constructor(dateString: String)\n//    public constructor(year: Int, month: Int)\n//    public constructor(year: Int, month: Int, day: Int)\n//    public constructor(year: Int, month: Int, day: Int, hour: Int)\n//    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int)\n//    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int)\n//    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Number)\n\n//    public fun getDate(): Long\n/*public fun getDay(): Int\npublic fun getFullYear(): Int\npublic fun getHours(): Int\npublic fun getMilliseconds(): Int\npublic fun getMinutes(): Int\npublic fun getMonth(): Int\npublic fun getSeconds(): Int\npublic fun getTime(): Double\npublic fun getTimezoneOffset(): Int\npublic fun getUTCDate(): Int\npublic fun getUTCDay(): Int\npublic fun getUTCFullYear(): Int\npublic fun getUTCHours(): Int\npublic fun getUTCMilliseconds(): Int\npublic fun getUTCMinutes(): Int\npublic fun getUTCMonth(): Int\npublic fun getUTCSeconds(): Int\npublic fun toDateString(): String\npublic fun toISOString(): String*/\n\n/*public fun toJSON(): Json\npublic fun toLocaleDateString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\npublic fun toLocaleDateString(locales: String, options: LocaleOptions = definedExternally): String\npublic fun toLocaleString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\npublic fun toLocaleString(locales: String, options: LocaleOptions = definedExternally): String\npublic fun toLocaleTimeString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\npublic fun toLocaleTimeString(locales: String, options: LocaleOptions = definedExternally): String*/\n\n//    public fun toTimeString(): String\n//    public fun toUTCString(): String\n\n/*public companion object {\n    public fun now(): Double\n    public fun parse(dateString: String): Double\n    public fun UTC(year: Int, month: Int): Double\n    public fun UTC(year: Int, month: Int, day: Int): Double\n    public fun UTC(year: Int, month: Int, day: Int, hour: Int): Double\n    public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int): Double\n    public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int): Double\n    public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Number): Double\n}*/\n\n/*public interface LocaleOptions {\n    public var localeMatcher: String?\n    public var timeZone: String?\n    public var hour12: Boolean?\n    public var formatMatcher: String?\n    public var weekday: String?\n    public var era: String?\n    public var year: String?\n    public var month: String?\n    public var day: String?\n    public var hour: String?\n    public var minute: String?\n    public var second: String?\n    public var timeZoneName: String?\n}*/\n//}","package io.data2viz.time\n\n//var t0 = Date()\n//var t1 = Date()\n\n// TODO use Int instead of Long ?\n/**\n * Constructs a new custom interval given the specified floor and offset functions and an optional count function.\n *\n * The floor function takes a single date as an argument and rounds it down to the nearest interval boundary.\n *\n * The offset function takes a date and an integer step as arguments and advances the specified date by\n * the specified number of boundaries; the step may be positive, negative or zero.\n *\n * The optional count function takes a start date and an end date, already floored to the current interval, and\n * returns the number of boundaries between the start (exclusive) and end (inclusive).\n * If a count function is not specified, the returned interval does not allow interval.count or interval.every methods.\n * Note: due to an internal optimization, the specified count function must not invoke interval.count on other time intervals.\n *\n * The optional field function takes a date, already floored to the current interval, and returns the field value\n * of the specified date, corresponding to the number of boundaries between this date (exclusive) and the latest\n * previous parent boundary.\n * For example, for the timeDay interval, this returns the number of days since the start of the month.\n * If a field function is not specified, it defaults to counting the number of interval boundaries since the UNIX\n * epoch of January 1, 1970 UTC. The field function defines the behavior of interval.every.\n */\nopen class Interval(private val floori: (Date) -> Date,\n                    private val offseti: (Date, Long) -> Date,\n                    private val counti: ((Date, Date) -> Int)? = null,\n                    private val field: ((Date) -> Int)? = null) {\n\n    /**\n     * Alias for interval.floor. For example, d2v.timeYear(date) and d2v.timeYear.floor(date) are equivalent.\n     */\n    /*fun interval(date: Date): Date {\n        return floori(date)\n    }*/\n\n    /**\n     * Returns a new date representing the latest interval boundary date before or equal to date.\n     * For example, d2v.timeDay.floor(date) typically returns 12:00 AM local time on the given date.\n     * This method is idempotent: if the specified date is already floored to the current interval, a new date\n     * with an identical time is returned.\n     * Furthermore, the returned date is the minimum expressible value of the associated interval,\n     * such that interval.floor(interval.floor(date) - 1) returns the preceeding interval boundary date.\n     */\n    fun floor(date: Date): Date = floori(Date(date))\n\n    /**\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\n     * For example, d2v.timeDay.ceil(date) typically returns 12:00 AM local time on the date following the given date.\n     * This method is idempotent: if the specified date is already ceilinged to the current interval,\n     * a new date with an identical time is returned.\n     * Furthermore, the returned date is the maximum expressible value of the associated interval,\n     * such that interval.ceil(interval.ceil(date) + 1) returns the following interval boundary date.\n     */\n    fun ceil(date: Date): Date {\n        var newDate = Date(date.minusMilliseconds(1))\n        newDate = floori(newDate)\n        newDate = offseti(newDate, 1)\n        newDate = floori(newDate)\n        return newDate\n    }\n\n    /**\n     * Returns a new date representing the closest interval boundary date to date.\n     * For example, d2v.timeDay.round(date) typically returns 12:00 AM local time on the given date if it\n     * is on or before noon, and 12:00 AM of the following day if it is after noon.\n     * This method is idempotent: if the specified date is already rounded to the current interval,\n     * a new date with an identical time is returned.\n     */\n    fun round(date: Date): Date {\n        val d0 = floor(date)\n        val d1 = ceil(date)\n        val millisecondsBetween1 = d0.millisecondsBetween(date)\n        val millisecondsBetween2 = date.millisecondsBetween(d1)\n        return if (millisecondsBetween1 < millisecondsBetween2) d0 else d1\n    }\n\n    /**\n     * Returns a new date equal to date plus step intervals.\n     * If step is not specified it defaults to 1.\n     * If step is negative, then the returned date will be before the specified date;\n     * if step is zero, then a copy of the specified date is returned.\n     * This method does not round the specified date to the interval.\n     * For example, if date is today at 5:34 PM, then d2v.timeDay.offset(date, 1) returns 5:34 PM tomorrow\n     * (even if daylight saving changes!).\n     */\n    fun offset(date: Date, step: Long = 1): Date {\n        return offseti(Date(date), step)\n    }\n\n    /**\n     * Returns every an array of dates representing every interval boundary after or equal to start (inclusive)\n     * and before stop (exclusive).\n     * If step is specified > 1 then every stepth boundary will be returned; for example, for the d2v.timeDay\n     * interval a step of 2 will return every other day.\n     * The first date in the returned array is the earliest boundary after or equal to start; subsequent dates are\n     * offset by step intervals and floored.\n     * Thus, two overlapping ranges may be consistent.\n     */\n    fun range(start: Date, stop: Date, step: Long = 1): List<Date> {\n        val range = arrayListOf<Date>()\n        var current = ceil(start)\n        if (step > 0) {\n            while (current.isBefore(stop)) {\n                range.add(current)\n                current = floori(offseti(Date(current), step))\n            }\n        }\n        return range.toList()\n    }\n\n    /**\n     * Returns a new interval that is a filtered subset of this interval using the specified test function.\n     * The test function is passed a date and should return true if and only if the specified date should be\n     * considered part of the interval.\n     * The returned filtered interval does not support interval.count.\n     * See also interval.every.\n     */\n    fun filter(test: (Date) -> Boolean): Interval {\n        return Interval(\n                fun(date: Date): Date {\n                    var newDate = date\n                    floori(newDate)\n                    while (!test(newDate)) {\n                        newDate = newDate.minusMilliseconds(1)\n                        floori(newDate)\n                    }\n                    return newDate\n                },\n                fun(date: Date, step: Long): Date {\n                    var newStep = step - 1\n                    while (newStep >= 0) {\n                        newStep--\n                        offseti(date, 1)\n                        while (!test(date)) {\n                            offseti(date, 1)\n                        }\n                    }\n                    return date\n                }\n        )\n    }\n\n    /**\n     * interval.filter = function(test) {\n    return newInterval(function(date) {\n    if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);\n    }, function(date, step) {\n    if (date >= date) while (--step >= 0) while (offseti(date, 1), !test(date)) {} // eslint-disable-line no-empty\n    });\n    };\n     */\n\n    /**\n     * Returns a filtered view of this interval representing every stepth date.\n     * The meaning of step is dependent on this interval\u2019s parent interval as defined by the field function.\n     * For example, timeMinute.every(15) returns an interval representing every fifteen minutes,\n     * starting on the hour: :00, :15, :30, :45, etc.\n     * Note that for some intervals, the resulting dates may not be uniformly-spaced; timeDay\u2019s parent interval is\n     * timeMonth, and thus the interval number resets at the start of each month.\n     * If step is not valid, raise exception. If step is one, returns this interval.\n     */\n    fun every(step: Int): Interval {\n        checkNotNull(counti, { \"The given Count function must not be null.\" })\n        require(step > 0, { \" The given Step parameter must be greater than zero.\" })\n        if (step == 1) return this\n        return if (field != null) {\n            filter { d -> field.invoke(d) % step == 0; }\n        } else {\n            filter { d -> count(date(1970, 1, 1), d) % step == 0; }\n        }\n    }\n\n    /**\n     * Returns the number of interval boundaries after start (exclusive) and before or equal to end (inclusive).\n     * Note that this behavior is slightly different than interval.range because its purpose is to return the\n     * zero-based number of the specified end date relative to the specified start date.\n     */\n    fun count(start: Date, stop: Date): Int {\n        checkNotNull(counti, { \"The given Count function must not be null.\" })\n        val from = floor(start)\n        val to = floor(stop)\n        return counti.invoke(from, to)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","package io.data2viz.time\n\nclass Day : Interval(\n        fun (date:Date): Date {\n            date.setHour(0)\n            date.setMinute(0)\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusDays(step)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return start.daysBetween(end).toInt()\n        },\n        fun (date:Date): Int {\n            return date.dayOfMonth() - 1\n        }\n)\n\nval timeDay = Day()","package io.data2viz.time\n\nclass Hour : Interval(\n        fun (date:Date): Date {\n            date.setMinute(0)\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusHours(step)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return start.hoursBetween(end).toInt()\n        },\n        fun (date:Date): Int {\n            return date.hour()\n        }\n)\n\nval timeHour = Hour()","package io.data2viz.time\n\nclass Millisecond : Interval(\n        fun (date:Date): Date {\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusMilliseconds(step)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return (start.millisecondsBetween(end)).toInt()\n        },\n        fun (date:Date): Int {\n            return date.millisecond()\n        }\n)\n\nval timeMillisecond = Millisecond()","package io.data2viz.time\n\nclass Minute : Interval(\n        fun (date:Date): Date {\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusMilliseconds(step * durationMinute)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return (start.millisecondsBetween(end) / durationMinute).toInt()\n        },\n        fun (date:Date): Int {\n            return date.minute()\n        }\n)\n\nval timeMinute = Minute()","package io.data2viz.time\n\nclass Month : Interval(\n        fun (date:Date): Date {\n            date.setDayOfMonth(1)\n            date.setHour(0)\n            date.setMinute(0)\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusMonths(step)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return (end.year() - start.year()) * 12 + (end.month() - start.month())\n        },\n        fun (date:Date): Int {\n            return date.month() - 1\n        }\n)\n\n\nval timeMonth = Month()","package io.data2viz.time\n\nclass Second : Interval(\n        fun (date:Date): Date {\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusMilliseconds(step * durationSecond)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return (start.millisecondsBetween(end) / durationSecond).toInt()\n        },\n        fun (date:Date): Int {\n            return date.second()\n        }\n)\n\nval timeSecond = Second()","package io.data2viz.time\n\nclass Weekday(day: Int) : Interval(\n        fun(date: Date): Date {\n            val dayofMonth = (date.dayOfMonth() - (date.dayOfWeek() + 7 - day) % 7) + 1\n            if (dayofMonth >= 1) {\n                date.setDayOfMonth(dayofMonth)\n            } else {\n                date.plusDays(dayofMonth.toLong() - 2)\n            }\n            date.setHour(0)\n            date.setMinute(0)\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun(date: Date, step: Long): Date {\n            date.plusDays(7 * step)\n            return date\n        },\n        fun(start: Date, end: Date): Int {\n            return start.daysBetween(end).toInt() / 7\n        }\n)\n\n// TODO TESTS seems to be a bug as timeSunday returns \"mondays\"\n\n// The value follows the ISO-8601 standard, from 1 (Monday) to 7 (Sunday).\nval timeMonday = Weekday(1)\nval timeTuesday = Weekday(2)\nval timeWednesday = Weekday(3)\nval timeThursday = Weekday(4)\nval timeFriday = Weekday(5)\nval timeSaturday = Weekday(6)\nval timeSunday = Weekday(7)\n","package io.data2viz.time\n\nclass Year : Interval(\n        fun (date:Date): Date {\n            date.setMonth(1)\n            date.setDayOfMonth(1)\n            date.setHour(0)\n            date.setMinute(0)\n            date.setSecond(0)\n            date.setMillisecond(0)\n            return date\n        },\n        fun (date:Date, step:Long): Date {\n            date.plusYears(step)\n            return date\n        },\n        fun (start:Date, end:Date): Int {\n            return end.year() - start.year()\n        },\n        fun (date:Date): Int {\n            return date.year()\n        }\n)\n\n\nval timeYear = Year()","package io.data2viz.time\n\ntypealias JsDate = io.data2viz.time.js.Date\n\nactual class Date {\n\n    private var date: JsDate\n\n    actual constructor() {\n        date = JsDate()\n    }\n\n    actual constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Int) {\n        if (year in 0..99) {\n            date = JsDate(-1, month - 1, day, hour, minute, second, millisecond)\n            date.setFullYear(year)\n        } else date = JsDate(year, month - 1, day, hour, minute, second, millisecond)\n    }\n\n    private constructor(date: JsDate) {\n        this.date = JsDate(date.getTime())\n    }\n\n    actual constructor(date: Date) {\n        this.date = JsDate(date.date.getTime())\n    }\n\n    actual override fun toString(): String = date.toString()\n\n    actual fun minusMilliseconds(milliseconds: Int): Date {\n        return Date(JsDate(date.getTime() - 1))\n    }\n\n    actual fun isBefore(otherDate: Date): Boolean {\n        return date.getTime() < otherDate.date.getTime()\n    }\n\n    actual fun millisecondsBetween(otherDate: Date): Long {\n        return (otherDate.date.getTime() - date.getTime()).toLong()\n    }\n\n    actual fun daysBetween(otherDate: Date): Long {\n        return (millisecondsBetween(otherDate) - ((otherDate.getTimezoneOffset() - date.getTimezoneOffset()) * durationMinute)) / durationDay\n    }\n\n    actual fun hoursBetween(otherDate: Date): Long {\n        return (millisecondsBetween(otherDate) - ((otherDate.getTimezoneOffset() - date.getTimezoneOffset()) * durationMinute)) / durationHour\n    }\n\n    actual fun getTimezoneOffset(): Int = date.getTimezoneOffset()\n\n    actual fun plusMilliseconds(milliseconds: Long) {\n        date = JsDate(date.getTime() + milliseconds)\n    }\n\n    //    actual fun plusSeconds(seconds:Long)\n//    actual fun plusMinutes(minutes:Long)\n    actual fun plusHours(hours: Long) {\n        date = JsDate(date.getTime() + (hours * durationHour))\n    }\n\n    actual fun plusDays(days: Long) {\n        date = JsDate(date.getTime() + (days * durationDay))\n    }\n\n    actual fun plusMonths(months: Long) {\n        val m = ((date.getMonth() + months) % 12).toInt()\n        val y = ((date.getMonth() + months) / 12).toInt()\n        date.setFullYear(date.getFullYear() + y)\n        date.setMonth(m)\n    }\n\n    actual fun plusYears(years: Long) {\n        date.setFullYear(date.getFullYear() + years.toInt())\n    }\n\n    actual fun setMillisecond(millisecond: Int) {\n        date.setMilliseconds(millisecond)\n    }\n\n    actual fun setSecond(second: Int) {\n        date.setSeconds(second)\n    }\n\n    actual fun setMinute(minute: Int) {\n        date.setMinutes(minute)\n    }\n\n    actual fun setHour(hour: Int) {\n        date.setHours(hour)\n    }\n\n    actual fun setDayOfMonth(day: Int) {\n        date.setDate(day)\n    }\n\n    actual fun setMonth(month: Int) {\n        date.setMonth(month - 1)\n    }\n\n    actual fun setFullYear(year: Int) {\n        date.setFullYear(year)\n    }\n\n    actual fun millisecond(): Int = date.getMilliseconds()\n    actual fun second(): Int = date.getSeconds()\n    actual fun minute(): Int = date.getMinutes()\n    actual fun hour(): Int = date.getHours()\n    actual fun dayOfWeek(): Int = date.getDay()\n    actual fun dayOfMonth(): Int = date.getDate()\n    actual fun dayOfYear(): Int = 1 + timeDay.count(timeYear.floor(this), this)\n    actual fun month(): Int = date.getMonth() + 1\n    actual fun year(): Int = date.getFullYear()\n\n    actual fun getTime(): Double = date.getTime()\n\n//    actual operator fun minus(otherDate:Date): Date\n\n//    actual public fun getTime(): Long\n//    actual public fun getUTCHours(): Int\n\n//    actual public fun setUTCMinutes(minutes:Int, seconds:Int): Long\n//    actual public fun setUTCHours(hours:Int, minutes:Int?, seconds:Int?): Long\n}\n","package io.data2viz.time.js\n\n/**\n * Exposes the [Date API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) to Kotlin.\n */\npublic external class Date() {\n    public constructor(milliseconds: Number)\n\n    public constructor(dateString: String)\n\n    public constructor(year: Int, month: Int)\n\n    public constructor(year: Int, month: Int, day: Int)\n\n    public constructor(year: Int, month: Int, day: Int, hour: Int)\n\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int)\n\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int)\n\n    public constructor(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Number)\n\n    public fun setDate(dayofMonth:Int): Int\n    public fun getDate(): Int\n\n    public fun getDay(): Int\n\n    public fun setFullYear(fullYear:Int): Int\n    public fun getFullYear(): Int\n\n    public fun getHours(): Int\n    public fun setHours(hours:Int): Int\n\n    public fun getMilliseconds(): Int\n    public fun setMilliseconds(milliseconds:Int): Int\n\n    public fun getMinutes(): Int\n    public fun setMinutes(minutes:Int): Int\n\n    public fun setMonth(months:Int): Int\n    public fun getMonth(): Int\n\n    public fun getSeconds(): Int\n    public fun setSeconds(seconds:Int): Int\n\n    public fun getTime(): Double\n\n    public fun getTimezoneOffset(): Int\n\n    public fun getUTCDate(): Int\n\n    public fun getUTCDay(): Int\n\n    public fun getUTCFullYear(): Int\n\n    public fun getUTCHours(): Int\n\n    public fun getUTCMilliseconds(): Int\n\n    public fun getUTCMinutes(): Int\n\n    public fun getUTCMonth(): Int\n\n    public fun getUTCSeconds(): Int\n\n    public fun toDateString(): String\n\n    public fun toISOString(): String\n\n//    public fun toJSON(): Json\n\n    public fun toLocaleDateString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\n\n    public fun toLocaleDateString(locales: String, options: LocaleOptions = definedExternally): String\n\n    public fun toLocaleString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\n\n    public fun toLocaleString(locales: String, options: LocaleOptions = definedExternally): String\n\n    public fun toLocaleTimeString(locales: Array<String> = definedExternally, options: LocaleOptions = definedExternally): String\n\n    public fun toLocaleTimeString(locales: String, options: LocaleOptions = definedExternally): String\n\n    public fun toTimeString(): String\n\n    public fun toUTCString(): String\n\n    public companion object {\n        public fun now(): Double\n\n        public fun parse(dateString: String): Double\n\n        public fun UTC(year: Int, month: Int): Double\n\n        public fun UTC(year: Int, month: Int, day: Int): Double\n\n        public fun UTC(year: Int, month: Int, day: Int, hour: Int): Double\n\n        public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int): Double\n\n        public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int): Double\n\n        public fun UTC(year: Int, month: Int, day: Int, hour: Int, minute: Int, second: Int, millisecond: Number): Double\n    }\n\n    public interface LocaleOptions {\n        public var localeMatcher: String?\n\n        public var timeZone: String?\n\n        public var hour12: Boolean?\n\n        public var formatMatcher: String?\n\n        public var weekday: String?\n\n        public var era: String?\n\n        public var year: String?\n\n        public var month: String?\n\n        public var day: String?\n\n        public var hour: String?\n\n        public var minute: String?\n\n        public var second: String?\n\n        public var timeZoneName: String?\n    }\n}\n\npublic inline fun dateLocaleOptions(init: Date.LocaleOptions.() -> Unit): Date.LocaleOptions {\n    val result = js(\"new Object()\").unsafeCast<Date.LocaleOptions>()\n    init(result)\n    return result\n}"],"names":[],"mappings":"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"}