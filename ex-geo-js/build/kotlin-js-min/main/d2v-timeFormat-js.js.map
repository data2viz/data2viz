{"version":3,"file":"d2v-timeFormat-js.js","sources":["../../../../../d2v-timeFormat-common/src/main/kotlin/io/data2viz/timeFormat/Locale.kt","../../../../../../../../../../dummy.kt","collections/Maps.kt","collections/Collections.kt","kotlin/string.kt","generated/_Strings.kt","generated/_Collections.kt","../../../../../d2v-timeFormat-common/src/main/kotlin/io/data2viz/timeFormat/Locales.kt"],"sourcesContent":["package io.data2viz.timeFormat\n\nimport io.data2viz.time.*\nimport kotlin.math.abs\n\n// return {y: y, m: 0, d: 1, H: 0, M: 0, S: 0, L: 0};\ndata class ParseDate(\n        var year: Int? = null,\n        var month: Int? = null,\n        var day: Int? = null,\n        var hour: Int? = null,\n        var minute: Int? = null,\n        var second: Int? = null,\n        var millisecond: Int? = null,\n        var period: Int? = null,\n        var weekDay: Int? = null,\n        var weekNumberMonday: Int? = null,\n        var weekNumberSunday: Int? = null,\n        var zone: Int? = null\n)\n\nprivate fun date(d: ParseDate): Date {\n    val date = date(d.year ?: 0, d.month ?: 1, 1, d.hour ?: 0, d.minute ?: 0, d.second ?: 0, d.millisecond ?: 0)\n\n    // add days (cause day value may be a number of days <= 0 or > 31)\n    if (d.day != null) date.plusDays(d.day!!.toLong() - 1)\n\n    return date\n}\n\n/*var utcFormats = {\n    \"a\": formatUTCShortWeekday,\n    \"A\": formatUTCWeekday,\n    \"b\": formatUTCShortMonth,\n    \"B\": formatUTCMonth,\n    \"c\": null,\n    \"d\": formatUTCDayOfMonth,\n    \"e\": formatUTCDayOfMonth,\n    \"H\": formatUTCHour24,\n    \"I\": formatUTCHour12,\n    \"j\": formatUTCDayOfYear,\n    \"L\": formatUTCMilliseconds,\n    \"m\": formatUTCMonthNumber,\n    \"M\": formatUTCMinutes,\n    \"p\": formatUTCPeriod,\n    \"S\": formatUTCSeconds,\n    \"U\": formatUTCWeekNumberSunday,\n    \"w\": formatUTCWeekdayNumber,\n    \"W\": formatUTCWeekNumberMonday,\n    \"x\": null,\n    \"X\": null,\n    \"y\": formatUTCYear,\n    \"Y\": formatUTCFullYear,\n    \"Z\": formatUTCZone,\n    \"%\": formatLiteralPercent\n}*/\n\nval defaultLocale = Locale()\nfun autoFormat() = defaultLocale.autoFormat()\nfun format(specifier: String) = defaultLocale.format(specifier)\nfun parse(specifier: String) = defaultLocale.parse(specifier)\n\nclass Locale(timeLocale: TimeLocale = Locales.defaultLocale()) {\n    val locale_dateTime = timeLocale.dateTime\n    val locale_date = timeLocale.date\n    val locale_time = timeLocale.time\n    val locale_periods = timeLocale.periods\n    val locale_weekdays = timeLocale.days\n    val locale_shortWeekdays = timeLocale.shortDays\n    val locale_months = timeLocale.months\n    val locale_shortMonths = timeLocale.shortMonths\n\n    val periodRe = formatRe(locale_periods)\n    val periodLookup = formatLookup(locale_periods)\n    val weekdayRe = formatRe(locale_weekdays)\n    val weekdayLookup = formatLookup(locale_weekdays)\n    val shortWeekdayRe = formatRe(locale_shortWeekdays)\n    val shortWeekdayLookup = formatLookup(locale_shortWeekdays)\n    val monthRe = formatRe(locale_months)\n    val monthLookup = formatLookup(locale_months)\n    val shortMonthRe = formatRe(locale_shortMonths)\n    val shortMonthLookup = formatLookup(locale_shortMonths)\n\n    val formats = mutableMapOf<Char, ((Date, String) -> String)?>(\n            Pair('a', ::formatShortWeekday),\n            Pair('A', ::formatWeekday),\n            Pair('b', ::formatShortMonth),\n            Pair('B', ::formatMonth),\n            Pair('c', null),\n            Pair('d', ::formatDayOfMonth),\n            Pair('e', ::formatDayOfMonth),\n            Pair('H', ::formatHour24),\n            Pair('I', ::formatHour12),\n            Pair('j', ::formatDayOfYear),\n            Pair('L', ::formatMilliseconds),\n            Pair('m', ::formatMonthNumber),\n            Pair('M', ::formatMinutes),\n            Pair('p', ::formatPeriod),\n            Pair('S', ::formatSeconds),\n            Pair('U', ::formatWeekNumberSunday),\n            Pair('w', ::formatWeekdayNumber),\n            Pair('W', ::formatWeekNumberMonday),\n            Pair('x', null),\n            Pair('X', null),\n            Pair('y', ::formatYear),\n            Pair('Y', ::formatFullYear),\n            Pair('Z', ::formatZone),\n            Pair('%', ::formatLiteralPercent)\n    )\n\n    val parses = mutableMapOf<Char, ((ParseDate, String, Int) -> Int)?>(\n            Pair('a', ::parseShortWeekday),\n            Pair('A', ::parseWeekday),\n            Pair('b', ::parseShortMonth),\n            Pair('B', ::parseMonth),\n            Pair('c', ::parseLocaleDateTime),\n            Pair('d', ::parseDayOfMonth),\n            Pair('e', ::parseDayOfMonth),\n            Pair('H', ::parseHour24),\n            Pair('I', ::parseHour24),\n            Pair('j', ::parseDayOfYear),\n            Pair('L', ::parseMilliseconds),\n            Pair('m', ::parseMonthNumber),\n            Pair('M', ::parseMinutes),\n            Pair('p', ::parsePeriod),\n            Pair('S', ::parseSeconds),\n            Pair('U', ::parseWeekNumberSunday),\n            Pair('w', ::parseWeekdayNumber),\n            Pair('W', ::parseWeekNumberMonday),\n            Pair('x', ::parseLocaleDate),\n            Pair('X', ::parseLocaleTime),\n            Pair('y', ::parseYear),\n            Pair('Y', ::parseFullYear),\n//            Pair('Z', ::parseZone),\n            Pair('%', ::parseLiteralPercent)\n    )\n\n    val dateTimeFormat = format(locale_dateTime)\n    val dateFormat = format(locale_date)\n    val timeFormat = format(locale_time)\n\n    init {\n        formats['c'] = fun(date: Date, _: String): String { return dateTimeFormat(date) }\n        formats['x'] = fun(date: Date, _: String): String { return dateFormat(date) }\n        formats['X'] = fun(date: Date, _: String): String { return timeFormat(date) }\n    }\n\n    fun autoFormat(): (Date) -> String {\n        val formatMillisecond = format(\".%L\")\n        val formatSecond = format(\":%S\")\n        val formatMinute = format(\"%I:%M\")\n        val formatHour = format(\"%I %p\")\n//        val formatDay = format(\"%a %d\")\n        val formatWeek = format(\"%b %d\")\n        val formatMonth = format(\"%B\")\n        val formatYear = format(\"%Y\")\n\n        return fun(date: Date): String {\n            val formatter =\n                    if (timeYear.floor(date).month() < date.month()) formatMonth else {\n                        if (timeMonth.floor(date).dayOfYear() < date.dayOfMonth()) formatWeek else {\n//                          if (timeSunday.floor(date).dayOfWeek() < date.dayOfWeek()) formatDay else {\n                            if (timeDay.floor(date).hour() < date.hour()) formatHour else {\n                                if (timeHour.floor(date).minute() < date.minute()) formatMinute else {\n                                    if (timeMinute.floor(date).second() < date.second()) formatSecond else {\n                                        if (timeSecond.floor(date).millisecond() < date.millisecond()) formatMillisecond else\n                                            formatYear\n                                    }\n                                }\n//                          }\n                            }\n                        }\n                    }\n            return formatter(date)\n        }\n    }\n\n    fun format(specifier: String): (Date) -> String {\n        return fun(date: Date): String {\n            val string = mutableListOf<String>()\n            var i = 0\n            var j = 0\n\n            while (i < specifier.length) {\n                if (specifier.get(i) == '%') {\n                    string.add(specifier.substring(j, i))\n                    i++\n                    var c = specifier.get(i)\n                    var pad = pads[c]\n                    if (pad != null) {\n                        i++\n                        c = specifier.get(i)\n                    } else {\n                        pad = if (c == 'e') \" \" else \"0\"\n                    }\n                    val format = formats[c]\n                    if (format != null) {\n                        string.add(format(date, pad))\n                    } else {\n                        string.add(c.toString())\n                    }\n                    j = i + 1\n                }\n                i++\n            }\n\n            string.add(specifier.substring(j, i))\n            return string.joinToString(\"\")\n        }\n    }\n\n    fun parse(specifier: String): (String) -> Date? {\n        return fun(dateString: String): Date? {\n            val d = newYear(1900)\n            val i = parseSpecifier(d, specifier, dateString, 0)\n            if (i != dateString.length) return null\n\n            // The am-pm flag is 0 for AM, and 1 for PM.\n            if (d.period != null) {\n                if (d.hour == null) d.hour = 0\n                d.hour = d.hour!! % 12 + (d.period!! * 12)\n            }\n\n            // Convert day-of-week and week-of-year to day-of-year.\n            // TODO change this to avoid managing it in date(parseDate) (days <= 0 or > 31...)\n            if (d.weekNumberMonday != null || d.weekNumberSunday != null) {\n                val preValue = if (d.weekNumberMonday != null) 1 else 0\n                if (d.weekDay == null) d.weekDay = preValue\n                val day = if (d.zone != null) {\n                    0//utcDate(newYear(d.y)).getUTCDay()\n                } else {\n                    date(newYear(d.year)).dayOfWeek()\n                }\n                d.month = 1\n                d.day = if (d.weekNumberMonday != null) {\n                    (d.weekDay!! + 6) % 7 + d.weekNumberMonday!! * 7 - (day + 5) % 7\n                } else {\n                    d.weekDay!! + d.weekNumberSunday!! * 7 - (day + 6) % 7\n                }\n            }\n\n            // If a time zone is specified, all fields are interpreted as UTC and then\n            // offset according to the specified time zone.\n            /*if (\"Z\" in d) {\n                d.hour += d.zone / 100 | 0\n                d.minute += d.zone % 100\n                return utcDate(d)\n            }*/\n\n            // Otherwise, all fields are in local time.\n            return date(d)\n        }\n    }\n/*\n    function parseSpecifier(d, specifier, string, j) {\n        var i = 0,\n        n = specifier.length,\n        m = string.length,\n        c,\n        parse;\n\n        while (i < n) {\n            if (j >= m) return -1;\n            c = specifier.charCodeAt(i++);\n            if (c === 37) {\n                c = specifier.charAt(i++);\n                parse = parses[c in pads ? specifier.charAt(i++) : c];\n                if (!parse || ((j = parse(d, string, j)) < 0)) return -1;\n            } else if (c != string.charCodeAt(j++)) {\n                return -1;\n            }\n        }\n\n        return j;\n    }*/\n\n    private fun parseSpecifier(d: ParseDate, specifier: String, dateString: String, index: Int): Int {\n        var i = 0\n        var newIndex = index\n\n        while (i < specifier.length) {\n            if (newIndex >= dateString.length) return -1\n            var c = specifier[i]\n            i++\n            if (c == '%') {\n                c = specifier[i]\n                i++\n                if (c in pads) {\n                    c = specifier[i]\n                    i++\n                }\n                val parse = parses[c]\n                if (parse == null) return -1\n                val parsedIndex = parse(d, dateString, newIndex)\n                if (parsedIndex < 0) return -1\n                newIndex = parse(d, dateString, newIndex)\n            } else {\n                if (c != dateString[newIndex]) {\n                    return -1\n                }\n                newIndex++\n            }\n        }\n\n        return newIndex\n    }\n\n    fun parsePeriod(d: ParseDate, string: String, i: Int): Int {\n        val n = periodRe.find(string.substring(i))\n        return if (n != null) {\n            val period = periodLookup[n.groupValues[0].filter { it != ' ' }.toLowerCase()]\n            d.period = if (period != null) period else 0\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseShortWeekday(d: ParseDate, string: String, i: Int): Int {\n        val n = shortWeekdayRe.find(string.substring(i))\n        return if (n != null) {\n            val weekDay = shortWeekdayLookup[n.groupValues[0].filter { it != ' ' }.toLowerCase()]\n            d.weekDay = if (weekDay != null) weekDay else 0\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseWeekday(d: ParseDate, string: String, i: Int): Int {\n        val n = weekdayRe.find(string.substring(i))\n        return if (n != null) {\n            val weekDay = weekdayLookup[n.groupValues[0].filter { it != ' ' }.toLowerCase()]\n            d.weekDay = if (weekDay != null) weekDay else 0\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseShortMonth(d: ParseDate, string: String, i: Int): Int {\n        val n = shortMonthRe.find(string.substring(i))\n        return if (n != null) {\n            val month = shortMonthLookup[n.groupValues[0].filter { it != ' ' }.toLowerCase()]\n            d.month = if (month != null) month + 1 else 0\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseMonth(d: ParseDate, string: String, i: Int): Int {\n        val n = monthRe.find(string.substring(i))\n        return if (n != null) {\n            val month = monthLookup[n.groupValues[0].filter { it != ' ' }.toLowerCase()]\n            d.month = if (month != null) month + 1 else 0\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseLocaleDateTime(d: ParseDate, string: String, i: Int): Int {\n        return parseSpecifier(d, locale_dateTime, string, i)\n    }\n\n    fun parseLocaleDate(d: ParseDate, string: String, i: Int): Int {\n        return parseSpecifier(d, locale_date, string, i)\n    }\n\n    fun parseLocaleTime(d: ParseDate, string: String, i: Int): Int {\n        return parseSpecifier(d, locale_time, string, i)\n    }\n\n    fun parseWeekdayNumber(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 1))\n        return if (n != null) {\n            d.weekDay = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseWeekNumberSunday(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i))\n        return if (n != null) {\n            d.weekNumberSunday = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseWeekNumberMonday(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i))\n        return if (n != null) {\n            d.weekNumberMonday = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseFullYear(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 4))\n        return if (n != null) {\n            d.year = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseYear(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.year = n.groupValues[0].toInt() + if (n.groupValues[0].toInt() > 68) 1900 else 2000\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    /*fun parseZone(d:ParseDate, string:String, i:Int):Int {\n        val n = Regex(\"/^(Z)|([+-]\\\\d\\\\d)(?:\\\\:?(\\\\d\\\\d))?/\").find(string.substring(i, i + 6))\n        return if (n != null) {\n            d.zone = if (n.groupValues[1] != null) 0 else -(n.groupValues[2].toInt() + (n.groupValues[3].toInt() || \"00\"))\n            i + n.groupValues[0].length\n        }\n        else -1\n    }*/\n\n    fun parseMonthNumber(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.month = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseDayOfMonth(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.day = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseDayOfYear(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 3))\n        return if (n != null) {\n            d.month = 0\n            d.day = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseHour24(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.hour = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseMinutes(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.minute = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseSeconds(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 2))\n        return if (n != null) {\n            d.second = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseMilliseconds(d: ParseDate, string: String, i: Int): Int {\n        val n = numberRe.find(string.substring(i, i + 3))\n        return if (n != null) {\n            d.millisecond = n.groupValues[0].filter { it != ' ' }.toInt()\n            i + n.groupValues[0].length\n        } else -1\n    }\n\n    fun parseLiteralPercent(d: ParseDate, string: String, i: Int): Int {\n        val percentRe = Regex(\"^%\")\n        val input = string.substring(i, i + 1)\n        val n = percentRe.find(input)\n        return if (n != null) i + n.groupValues[0].length else -1\n    }\n\n    fun formatShortWeekday(d: Date, p: String): String {\n        return locale_shortWeekdays[d.dayOfWeek() % 7]\n    }\n\n    fun formatWeekday(d: Date, p: String): String {\n        return locale_weekdays[d.dayOfWeek() % 7]\n    }\n\n    fun formatShortMonth(d: Date, p: String): String {\n        return locale_shortMonths[d.month() - 1]\n    }\n\n    fun formatMonth(d: Date, p: String): String {\n        return locale_months[d.month() - 1]\n    }\n\n    fun formatPeriod(d: Date, p: String): String {\n        return locale_periods[if (d.hour() >= 12) 1 else 0]\n    }\n\n    fun formatDayOfMonth(d: Date, p: String): String {\n        return pad(d.dayOfMonth(), p, 2)\n    }\n\n    fun formatHour24(d: Date, p: String): String {\n        return pad(d.hour(), p, 2)\n    }\n\n    fun formatHour12(d: Date, p: String): String {\n        val hour = d.hour() % 12\n        return pad(if (hour == 0) 12 else hour, p, 2)\n    }\n\n    // TODO JS version moved to date? (see comment)\n    fun formatDayOfYear(d: Date, p: String): String {\n        return pad(d.dayOfYear(), p, 3)\n    }\n\n    fun formatMilliseconds(d: Date, p: String): String {\n        return pad(d.millisecond(), p, 3)\n    }\n\n    fun formatMonthNumber(d: Date, p: String): String {\n        return pad(d.month(), p, 2)\n    }\n\n    fun formatMinutes(d: Date, p: String): String {\n        return pad(d.minute(), p, 2)\n    }\n\n    fun formatSeconds(d: Date, p: String): String {\n        return pad(d.second(), p, 2)\n    }\n\n    fun formatWeekNumberSunday(d: Date, p: String): String {\n        val start = timeYear.floor(d)\n        val value = timeSunday.count(start, d)\n        return pad(value, p, 2)\n    }\n\n    fun formatWeekdayNumber(d: Date, p: String): String {\n        return d.dayOfWeek().toString()\n    }\n\n    fun formatWeekNumberMonday(d: Date, p: String): String {\n        return pad(timeMonday.count(timeYear.floor(d), d), p, 2)\n    }\n\n    fun formatYear(d: Date, p: String): String {\n        return pad(d.year() % 100, p, 2)\n    }\n\n    fun formatFullYear(d: Date, p: String): String {\n        return pad(d.year() % 10000, p, 4)\n    }\n\n    fun formatZone(d: Date, p: String): String {\n        var z = d.getTimezoneOffset()\n        val sign = if (z > 0) \"-\" else \"+\"\n        z = abs(z)\n        return sign + pad(z / 60, \"0\", 2) + pad(z % 60, \"0\", 2)\n    }\n\n    fun formatLiteralPercent(d: Date, p: String): String {\n        return \"%\"\n    }\n\n/*fun formatUTCShortWeekday(d:Date): String {\n    return locale_shortWeekdays[d.getUTCDay()]\n}\n\nfun formatUTCWeekday(d:Date): String {\n    return locale_weekdays[d.getUTCDay()]\n}\n\nfun formatUTCShortMonth(d:Date): String {\n    return locale_shortMonths[d.getUTCMonth()]\n}\n\nfun formatUTCMonth(d:Date): String {\n    return locale_months[d.getUTCMonth()]\n}\n\nfun formatUTCPeriod(d:Date): String {\n    return locale_periods[+(d.getUTCHours() >= 12)]\n}*/\n}\n\n/*fun localDate(d) {\n    if (0 <= d.y && d.y < 100) {\n        var date = new Date (-1, d.m, d.d, d.H, d.M, d.S, d.L)\n        date.setFullYear(d.y)\n        return date\n    }\n    return Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L)\n}\n\nfun utcDate(d) {\n    if (0 <= d.y && d.y < 100) {\n        var date = new Date (Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L))\n        date.setUTCFullYear(d.y)\n        return date\n    }\n    return Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L))\n}*/\n\nfun newYear(y: Int?): ParseDate {\n    return ParseDate(y)\n}\n\n/// STRING MANIPULATIONS\n\nval pads = mapOf(Pair('-', \"\"), Pair('_', \" \"), Pair('0', \"0\"))\nval numberRe = Regex(\"^\\\\s*\\\\d+\") // note: ignores next directive\n\nfun pad(value: Int, fill: String, width: Int): String {\n    val sign = if (value < 0) \"-\" else \"\"\n    val string = abs(value).toString()\n    return sign + (0 until (width - string.length)).map { fill }.joinToString(\"\") + string\n}\n\nfun requote(s: String): String {\n    val requoteRe = \"/[\\\\\\\\^\\$\\\\*\\\\+\\\\?\\\\|\\\\[\\\\]\\\\(\\\\)\\\\.\\\\{\\\\}]/g\"\n    return s.replace(requoteRe, \"\\\\$&\")\n}\n\nfun formatRe(names: List<String>): Regex {\n    val joinToString = names.map { it -> requote(it) }.joinToString(\"|\")\n    return Regex(\"^(?:$joinToString)\", RegexOption.IGNORE_CASE)\n}\n\nfun formatLookup(names: List<String>): Map<String, Int> {\n    val map = mutableMapOf<String, Int>()\n    var i = -1\n    val n = names.size\n    while (++i < n) map.set(names[i].toLowerCase(), i)\n    return map.toMap()\n}",null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Calculate the initial capacity of a map, based on Guava's com.google.common.collect.Maps approach. This is equivalent\n * to the Collection constructor for HashSet, (c.size()/.75f) + 1, but provides further optimisations for very small or\n * very large sizes, allows support non-collection classes, and provides consistency for all map based class construction.\n */\n@PublishedApi\ninternal fun mapCapacity(expectedSize: Int): Int {\n    if (expectedSize < 3) {\n        return expectedSize + 1\n    }\n    if (expectedSize < INT_MAX_POWER_OF_TWO) {\n        return expectedSize + expectedSize / 3\n    }\n    return Int.MAX_VALUE // any large value\n}\n\nprivate const val INT_MAX_POWER_OF_TWO: Int = Int.MAX_VALUE / 2 + 1\n\n/** Returns `true` if this map is not empty. */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String(chars: CharArray): String {\n    return js(\"String.fromCharCode\").apply(null, chars)\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    return String(chars.copyOfRange(offset, offset + length))\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toUpperCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n *\n * @sample samples.text.Strings.toLowerCase\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        var start = 0\n        while (true) {\n            val end = minOf(start + 16, min)\n            var s1 = this.substring(start, end)\n            var s2 = other.substring(start, end)\n            if (s1 != s2) {\n                s1 = s1.toUpperCase()\n                s2 = s2.toUpperCase()\n                if (s1 != s2) {\n                    s1 = s1.toLowerCase()\n                    s2 = s2.toLowerCase()\n                    if (s1 != s2) {\n                        return s1.compareTo(s2)\n                    }\n                }\n            }\n            if (end == min) break\n            start = end\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAt(index: Int): Char {\n    return get(index)\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length)))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length)))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each character of the original char sequence.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the desired action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\npublic fun CharSequence.max(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\npublic fun CharSequence.min(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n */\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right to current accumulator value and each character.\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left to each character and current accumulator value.\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have less characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val result = ArrayList<R>((thisSize + step - 1) / step)\n    var index = 0\n    while (index < thisSize) {\n        val end = index + size\n        val coercedEnd = if (end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have less characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index -> transform(subSequence(index, (index + size).coerceAtMost(length))) }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","package io.data2viz.timeFormat\n\ndata class TimeLocale(\n        val dateTime: String,\n        val date: String,\n        val time: String,\n        val periods: List<String>,\n        val days: List<String>,\n        val shortDays: List<String>,\n        val months: List<String>,\n        val shortMonths: List<String>\n)\n\nclass Locales {\n    companion object {\n        fun locale(\n                dateTime: String = \"%x, %X\",\n                date: String = \"%-m/%-d/%Y\",\n                time: String = \"%-I:%M:%S %p\",\n                periods: List<String> = listOf(\"AM\", \"PM\"),\n                days: List<String> = listOf(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n                shortDays: List<String> = listOf(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),\n                months: List<String> = listOf(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"),\n                shortMonths: List<String> = listOf(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\")\n        ) = TimeLocale(dateTime, date, time, periods, days, shortDays, months, shortMonths)\n\n        fun defaultLocale() = locale()\n        fun ca_ES() = locale(\"%A, %e de %B de %Y, %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"diumenge\", \"dilluns\", \"dimarts\", \"dimecres\", \"dijous\", \"divendres\", \"dissabte\"),\n                listOf(\"dg.\", \"dl.\", \"dt.\", \"dc.\", \"dj.\", \"dv.\", \"ds.\"),\n                listOf(\"gener\", \"febrer\", \"mar\u00e7\", \"abril\", \"maig\", \"juny\", \"juliol\", \"agost\", \"setembre\", \"octubre\", \"novembre\", \"desembre\"),\n                listOf(\"gen.\", \"febr.\", \"mar\u00e7\", \"abr.\", \"maig\", \"juny\", \"jul.\", \"ag.\", \"set.\", \"oct.\", \"nov.\", \"des.\")\n        )\n\n        fun cs_CZ() = locale(\"%A,%e.%B %Y, %X\",\n                \"%-d.%-m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"ned\u011ble\", \"pond\u011bl\u00ed\", \"\u00fater\u00fd\", \"st\u0159eda\", \"\u010dvrtek\", \"p\u00e1tek\", \"sobota\"),\n                listOf(\"ne.\", \"po.\", \"\u00fat.\", \"st.\", \"\u010dt.\", \"p\u00e1.\", \"so.\"),\n                listOf(\"leden\", \"\u00fanor\", \"b\u0159ezen\", \"duben\", \"kv\u011bten\", \"\u010derven\", \"\u010dervenec\", \"srpen\", \"z\u00e1\u0159\u00ed\", \"\u0159\u00edjen\", \"listopad\", \"prosinec\"),\n                listOf(\"led\", \"\u00fano\", \"b\u0159ez\", \"dub\", \"kv\u011b\", \"\u010der\", \"\u010derv\", \"srp\", \"z\u00e1\u0159\", \"\u0159\u00edj\", \"list\", \"pros\")\n        )\n\n        fun de_CH() = locale(\"%A, der %e. %B %Y, %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"),\n                listOf(\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"),\n                listOf(\"Januar\", \"Februar\", \"M\u00e4rz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"),\n                listOf(\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\")\n        )\n\n        fun de_DE() = locale(\"%A, der %e. %B %Y, %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Sonntag\", \"Montag\", \"Dienstag\", \"Mittwoch\", \"Donnerstag\", \"Freitag\", \"Samstag\"),\n                listOf(\"So\", \"Mo\", \"Di\", \"Mi\", \"Do\", \"Fr\", \"Sa\"),\n                listOf(\"Januar\", \"Februar\", \"M\u00e4rz\", \"April\", \"Mai\", \"Juni\", \"Juli\", \"August\", \"September\", \"Oktober\", \"November\", \"Dezember\"),\n                listOf(\"Jan\", \"Feb\", \"Mrz\", \"Apr\", \"Mai\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dez\")\n        )\n\n        fun en_CA() = locale(\"%a %b %e %X %Y\",\n                \"%Y-%m-%d\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n                listOf(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),\n                listOf(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"),\n                listOf(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\")\n        )\n\n        fun en_GB() = locale(\"%a %e %b %X %Y\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n                listOf(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),\n                listOf(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"),\n                listOf(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\")\n        )\n\n        fun en_US() = locale(\"%x, %X\",\n                \"%-m/%-d/%Y\",\n                \"%-I:%M:%S %p\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n                listOf(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"),\n                listOf(\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"),\n                listOf(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\")\n        )\n\n        fun es_ES() = locale(\"%A, %e de %B de %Y, %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"domingo\", \"lunes\", \"martes\", \"mi\u00e9rcoles\", \"jueves\", \"viernes\", \"s\u00e1bado\"),\n                listOf(\"dom\", \"lun\", \"mar\", \"mi\u00e9\", \"jue\", \"vie\", \"s\u00e1b\"),\n                listOf(\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"),\n                listOf(\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\")\n        )\n\n        fun es_MX() = locale(\"%x, %X\",\n                \"%d/%m/%Y\",\n                \"%-I:%M:%S %p\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"domingo\", \"lunes\", \"martes\", \"mi\u00e9rcoles\", \"jueves\", \"viernes\", \"s\u00e1bado\"),\n                listOf(\"dom\", \"lun\", \"mar\", \"mi\u00e9\", \"jue\", \"vie\", \"s\u00e1b\"),\n                listOf(\"enero\", \"febrero\", \"marzo\", \"abril\", \"mayo\", \"junio\", \"julio\", \"agosto\", \"septiembre\", \"octubre\", \"noviembre\", \"diciembre\"),\n                listOf(\"ene\", \"feb\", \"mar\", \"abr\", \"may\", \"jun\", \"jul\", \"ago\", \"sep\", \"oct\", \"nov\", \"dic\")\n        )\n\n        fun fi_FI() = locale(\"%A, %-d. %Bta %Y klo %X\",\n                \"%-d.%-m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"a.m.\", \"p.m.\"),\n                listOf(\"sunnuntai\", \"maanantai\", \"tiistai\", \"keskiviikko\", \"torstai\", \"perjantai\", \"lauantai\"),\n                listOf(\"Su\", \"Ma\", \"Ti\", \"Ke\", \"To\", \"Pe\", \"La\"),\n                listOf(\"tammikuu\", \"helmikuu\", \"maaliskuu\", \"huhtikuu\", \"toukokuu\", \"kes\u00e4kuu\", \"hein\u00e4kuu\", \"elokuu\", \"syyskuu\", \"lokakuu\", \"marraskuu\", \"joulukuu\"),\n                listOf(\"Tammi\", \"Helmi\", \"Maalis\", \"Huhti\", \"Touko\", \"Kes\u00e4\", \"Hein\u00e4\", \"Elo\", \"Syys\", \"Loka\", \"Marras\", \"Joulu\")\n        )\n\n        fun fr_CA() = locale(\"%a %e %b %Y %X\",\n                \"%Y-%m-%d\",\n                \"%H:%M:%S\",\n                listOf(\"\", \"\"),\n                listOf(\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"),\n                listOf(\"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\"),\n                listOf(\"janvier\", \"f\u00e9vrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"ao\u00fbt\", \"septembre\", \"octobre\", \"novembre\", \"d\u00e9cembre\"),\n                listOf(\"jan\", \"f\u00e9v\", \"mar\", \"avr\", \"mai\", \"jui\", \"jul\", \"ao\u00fb\", \"sep\", \"oct\", \"nov\", \"d\u00e9c\")\n        )\n\n        fun fr_FR() = locale(\"%A, le %e %B %Y, %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\"),\n                listOf(\"dim.\", \"lun.\", \"mar.\", \"mer.\", \"jeu.\", \"ven.\", \"sam.\"),\n                listOf(\"janvier\", \"f\u00e9vrier\", \"mars\", \"avril\", \"mai\", \"juin\", \"juillet\", \"ao\u00fbt\", \"septembre\", \"octobre\", \"novembre\", \"d\u00e9cembre\"),\n                listOf(\"janv.\", \"f\u00e9vr.\", \"mars\", \"avr.\", \"mai\", \"juin\", \"juil.\", \"ao\u00fbt\", \"sept.\", \"oct.\", \"nov.\", \"d\u00e9c.\")\n        )\n\n        fun he_IL() = locale(\"%A, %e \u05d1%B %Y %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"\u05e8\u05d0\u05e9\u05d5\u05df\", \"\u05e9\u05e0\u05d9\", \"\u05e9\u05dc\u05d9\u05e9\u05d9\", \"\u05e8\u05d1\u05d9\u05e2\u05d9\", \"\u05d7\u05de\u05d9\u05e9\u05d9\", \"\u05e9\u05d9\u05e9\u05d9\", \"\u05e9\u05d1\u05ea\"),\n                listOf(\"\u05d0\u05f3\", \"\u05d1\u05f3\", \"\u05d2\u05f3\", \"\u05d3\u05f3\", \"\u05d4\u05f3\", \"\u05d5\u05f3\", \"\u05e9\u05f3\"),\n                listOf(\"\u05d9\u05e0\u05d5\u05d0\u05e8\", \"\u05e4\u05d1\u05e8\u05d5\u05d0\u05e8\", \"\u05de\u05e8\u05e5\", \"\u05d0\u05e4\u05e8\u05d9\u05dc\", \"\u05de\u05d0\u05d9\", \"\u05d9\u05d5\u05e0\u05d9\", \"\u05d9\u05d5\u05dc\u05d9\", \"\u05d0\u05d5\u05d2\u05d5\u05e1\u05d8\", \"\u05e1\u05e4\u05d8\u05de\u05d1\u05e8\", \"\u05d0\u05d5\u05e7\u05d8\u05d5\u05d1\u05e8\", \"\u05e0\u05d5\u05d1\u05de\u05d1\u05e8\", \"\u05d3\u05e6\u05de\u05d1\u05e8\"),\n                listOf(\"\u05d9\u05e0\u05d5\u05f3\", \"\u05e4\u05d1\u05e8\u05f3\", \"\u05de\u05e8\u05e5\", \"\u05d0\u05e4\u05e8\u05f3\", \"\u05de\u05d0\u05d9\", \"\u05d9\u05d5\u05e0\u05d9\", \"\u05d9\u05d5\u05dc\u05d9\", \"\u05d0\u05d5\u05d2\u05f3\", \"\u05e1\u05e4\u05d8\u05f3\", \"\u05d0\u05d5\u05e7\u05f3\", \"\u05e0\u05d5\u05d1\u05f3\", \"\u05d3\u05e6\u05de\u05f3\")\n        )\n\n        fun hu_HU() = locale(\"%Y. %B %-e., %A %X\",\n                \"%Y. %m. %d.\",\n                \"%H:%M:%S\",\n                listOf(\"de.\", \"du.\"),\n                listOf(\"vas\u00e1rnap\", \"h\u00e9tf\u0151\", \"kedd\", \"szerda\", \"cs\u00fct\u00f6rt\u00f6k\", \"p\u00e9ntek\", \"szombat\"),\n                listOf(\"V\", \"H\", \"K\", \"Sze\", \"Cs\", \"P\", \"Szo\"),\n                listOf(\"janu\u00e1r\", \"febru\u00e1r\", \"m\u00e1rcius\", \"\u00e1prilis\", \"m\u00e1jus\", \"j\u00fanius\", \"j\u00falius\", \"augusztus\", \"szeptember\", \"okt\u00f3ber\", \"november\", \"december\"),\n                listOf(\"jan.\", \"feb.\", \"m\u00e1r.\", \"\u00e1pr.\", \"m\u00e1j.\", \"j\u00fan.\", \"j\u00fal.\", \"aug.\", \"szept.\", \"okt.\", \"nov.\", \"dec.\")\n        )\n\n        fun it_IT() = locale(\"%A %e %B %Y, %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Domenica\", \"Luned\u00ec\", \"Marted\u00ec\", \"Mercoled\u00ec\", \"Gioved\u00ec\", \"Venerd\u00ec\", \"Sabato\"),\n                listOf(\"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\"),\n                listOf(\"Gennaio\", \"Febbraio\", \"Marzo\", \"Aprile\", \"Maggio\", \"Giugno\", \"Luglio\", \"Agosto\", \"Settembre\", \"Ottobre\", \"Novembre\", \"Dicembre\"),\n                listOf(\"Gen\", \"Feb\", \"Mar\", \"Apr\", \"Mag\", \"Giu\", \"Lug\", \"Ago\", \"Set\", \"Ott\", \"Nov\", \"Dic\")\n        )\n\n        fun ja_JP() = locale(\"%Y %b %e %a %X\",\n                \"%Y/%m/%d\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"\u65e5\u66dc\u65e5\", \"\u6708\u66dc\u65e5\", \"\u706b\u66dc\u65e5\", \"\u6c34\u66dc\u65e5\", \"\u6728\u66dc\u65e5\", \"\u91d1\u66dc\u65e5\", \"\u571f\u66dc\u65e5\"),\n                listOf(\"\u65e5\", \"\u6708\", \"\u706b\", \"\u6c34\", \"\u6728\", \"\u91d1\", \"\u571f\"),\n                listOf(\"\u7766\u6708\", \"\u5982\u6708\", \"\u5f25\u751f\", \"\u536f\u6708\", \"\u7690\u6708\", \"\u6c34\u7121\u6708\", \"\u6587\u6708\", \"\u8449\u6708\", \"\u9577\u6708\", \"\u795e\u7121\u6708\", \"\u971c\u6708\", \"\u5e2b\u8d70\"),\n                listOf(\"1\u6708\", \"2\u6708\", \"3\u6708\", \"4\u6708\", \"5\u6708\", \"6\u6708\", \"7\u6708\", \"8\u6708\", \"9\u6708\", \"10\u6708\", \"11\u6708\", \"12\u6708\")\n        )\n\n        fun ko_KR() = locale(\"%Y/%m/%d %a %X\",\n                \"%Y/%m/%d\",\n                \"%H:%M:%S\",\n                listOf(\"\uc624\uc804\", \"\uc624\ud6c4\"),\n                listOf(\"\uc77c\uc694\uc77c\", \"\uc6d4\uc694\uc77c\", \"\ud654\uc694\uc77c\", \"\uc218\uc694\uc77c\", \"\ubaa9\uc694\uc77c\", \"\uae08\uc694\uc77c\", \"\ud1a0\uc694\uc77c\"),\n                listOf(\"\uc77c\", \"\uc6d4\", \"\ud654\", \"\uc218\", \"\ubaa9\", \"\uae08\", \"\ud1a0\"),\n                listOf(\"1\uc6d4\", \"2\uc6d4\", \"3\uc6d4\", \"4\uc6d4\", \"5\uc6d4\", \"6\uc6d4\", \"7\uc6d4\", \"8\uc6d4\", \"9\uc6d4\", \"10\uc6d4\", \"11\uc6d4\", \"12\uc6d4\"),\n                listOf(\"1\uc6d4\", \"2\uc6d4\", \"3\uc6d4\", \"4\uc6d4\", \"5\uc6d4\", \"6\uc6d4\", \"7\uc6d4\", \"8\uc6d4\", \"9\uc6d4\", \"10\uc6d4\", \"11\uc6d4\", \"12\uc6d4\")\n        )\n\n        fun mk_MK() = locale(\"%A, %e %B %Y \u0433. %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"\u043d\u0435\u0434\u0435\u043b\u0430\", \"\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u043d\u0438\u043a\", \"\u0432\u0442\u043e\u0440\u043d\u0438\u043a\", \"\u0441\u0440\u0435\u0434\u0430\", \"\u0447\u0435\u0442\u0432\u0440\u0442\u043e\u043a\", \"\u043f\u0435\u0442\u043e\u043a\", \"\u0441\u0430\u0431\u043e\u0442\u0430\"),\n                listOf(\"\u043d\u0435\u0434\", \"\u043f\u043e\u043d\", \"\u0432\u0442\u043e\", \"\u0441\u0440\u0435\", \"\u0447\u0435\u0442\", \"\u043f\u0435\u0442\", \"\u0441\u0430\u0431\"),\n                listOf(\"\u0458\u0430\u043d\u0443\u0430\u0440\u0438\", \"\u0444\u0435\u0432\u0440\u0443\u0430\u0440\u0438\", \"\u043c\u0430\u0440\u0442\", \"\u0430\u043f\u0440\u0438\u043b\", \"\u043c\u0430\u0458\", \"\u0458\u0443\u043d\u0438\", \"\u0458\u0443\u043b\u0438\", \"\u0430\u0432\u0433\u0443\u0441\u0442\", \"\u0441\u0435\u043f\u0442\u0435\u043c\u0432\u0440\u0438\", \"\u043e\u043a\u0442\u043e\u043c\u0432\u0440\u0438\", \"\u043d\u043e\u0435\u043c\u0432\u0440\u0438\", \"\u0434\u0435\u043a\u0435\u043c\u0432\u0440\u0438\"),\n                listOf(\"\u0458\u0430\u043d\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", \"\u0430\u043f\u0440\", \"\u043c\u0430\u0458\", \"\u0458\u0443\u043d\", \"\u0458\u0443\u043b\", \"\u0430\u0432\u0433\", \"\u0441\u0435\u043f\", \"\u043e\u043a\u0442\", \"\u043d\u043e\u0435\", \"\u0434\u0435\u043a\")\n        )\n\n        fun nl_NL() = locale(\"%a %e %B %Y %T\",\n                \"%d-%m-%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"zondag\", \"maandag\", \"dinsdag\", \"woensdag\", \"donderdag\", \"vrijdag\", \"zaterdag\"),\n                listOf(\"zo\", \"ma\", \"di\", \"wo\", \"do\", \"vr\", \"za\"),\n                listOf(\"januari\", \"februari\", \"maart\", \"april\", \"mei\", \"juni\", \"juli\", \"augustus\", \"september\", \"oktober\", \"november\", \"december\"),\n                listOf(\"jan\", \"feb\", \"mrt\", \"apr\", \"mei\", \"jun\", \"jul\", \"aug\", \"sep\", \"okt\", \"nov\", \"dec\")\n        )\n\n        fun pl_PL() = locale(\"%A, %e %B %Y, %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Niedziela\", \"Poniedzia\u0142ek\", \"Wtorek\", \"\u015aroda\", \"Czwartek\", \"Pi\u0105tek\", \"Sobota\"),\n                listOf(\"Niedz.\", \"Pon.\", \"Wt.\", \"\u015ar.\", \"Czw.\", \"Pt.\", \"Sob.\"),\n                listOf(\"Stycze\u0144\", \"Luty\", \"Marzec\", \"Kwiecie\u0144\", \"Maj\", \"Czerwiec\", \"Lipiec\", \"Sierpie\u0144\", \"Wrzesie\u0144\", \"Pa\u017adziernik\", \"Listopad\", \"Grudzie\u0144\"),\n                listOf(\"Stycz.\", \"Luty\", \"Marz.\", \"Kwie.\", \"Maj\", \"Czerw.\", \"Lipc.\", \"Sierp.\", \"Wrz.\", \"Pa\u017adz.\", \"Listop.\", \"Grudz.\")\n        )\n\n        fun pt_BR() = locale(\"%A, %e de %B de %Y. %X\",\n                \"%d/%m/%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"Domingo\", \"Segunda\", \"Ter\u00e7a\", \"Quarta\", \"Quinta\", \"Sexta\", \"S\u00e1bado\"),\n                listOf(\"Dom\", \"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"S\u00e1b\"),\n                listOf(\"Janeiro\", \"Fevereiro\", \"Mar\u00e7o\", \"Abril\", \"Maio\", \"Junho\", \"Julho\", \"Agosto\", \"Setembro\", \"Outubro\", \"Novembro\", \"Dezembro\"),\n                listOf(\"Jan\", \"Fev\", \"Mar\", \"Abr\", \"Mai\", \"Jun\", \"Jul\", \"Ago\", \"Set\", \"Out\", \"Nov\", \"Dez\")\n        )\n\n        fun ru_RU() = locale(\"%A, %e %B %Y \u0433. %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"AM\", \"PM\"),\n                listOf(\"\u0432\u043e\u0441\u043a\u0440\u0435\u0441\u0435\u043d\u044c\u0435\", \"\u043f\u043e\u043d\u0435\u0434\u0435\u043b\u044c\u043d\u0438\u043a\", \"\u0432\u0442\u043e\u0440\u043d\u0438\u043a\", \"\u0441\u0440\u0435\u0434\u0430\", \"\u0447\u0435\u0442\u0432\u0435\u0440\u0433\", \"\u043f\u044f\u0442\u043d\u0438\u0446\u0430\", \"\u0441\u0443\u0431\u0431\u043e\u0442\u0430\"),\n                listOf(\"\u0432\u0441\", \"\u043f\u043d\", \"\u0432\u0442\", \"\u0441\u0440\", \"\u0447\u0442\", \"\u043f\u0442\", \"\u0441\u0431\"),\n                listOf(\"\u044f\u043d\u0432\u0430\u0440\u044f\", \"\u0444\u0435\u0432\u0440\u0430\u043b\u044f\", \"\u043c\u0430\u0440\u0442\u0430\", \"\u0430\u043f\u0440\u0435\u043b\u044f\", \"\u043c\u0430\u044f\", \"\u0438\u044e\u043d\u044f\", \"\u0438\u044e\u043b\u044f\", \"\u0430\u0432\u0433\u0443\u0441\u0442\u0430\", \"\u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044f\", \"\u043e\u043a\u0442\u044f\u0431\u0440\u044f\", \"\u043d\u043e\u044f\u0431\u0440\u044f\", \"\u0434\u0435\u043a\u0430\u0431\u0440\u044f\"),\n                listOf(\"\u044f\u043d\u0432\", \"\u0444\u0435\u0432\", \"\u043c\u0430\u0440\", \"\u0430\u043f\u0440\", \"\u043c\u0430\u0439\", \"\u0438\u044e\u043d\", \"\u0438\u044e\u043b\", \"\u0430\u0432\u0433\", \"\u0441\u0435\u043d\", \"\u043e\u043a\u0442\", \"\u043d\u043e\u044f\", \"\u0434\u0435\u043a\")\n        )\n\n        fun sv_SE() = locale(\"%A den %d %B %Y %X\",\n                \"%Y-%m-%d\",\n                \"%H:%M:%S\",\n                listOf(\"fm\", \"em\"),\n                listOf(\"S\u00f6ndag\", \"M\u00e5ndag\", \"Tisdag\", \"Onsdag\", \"Torsdag\", \"Fredag\", \"L\u00f6rdag\"),\n                listOf(\"S\u00f6n\", \"M\u00e5n\", \"Tis\", \"Ons\", \"Tor\", \"Fre\", \"L\u00f6r\"),\n                listOf(\"Januari\", \"Februari\", \"Mars\", \"April\", \"Maj\", \"Juni\", \"Juli\", \"Augusti\", \"September\", \"Oktober\", \"November\", \"December\"),\n                listOf(\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"Maj\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Okt\", \"Nov\", \"Dec\")\n        )\n\n        fun uk_UA() = locale(\"%A, %e %B %Y \u0440. %X\",\n                \"%d.%m.%Y\",\n                \"%H:%M:%S\",\n                listOf(\"\u0434\u043f\", \"\u043f\u043f\"),\n                listOf(\"\u043d\u0435\u0434\u0456\u043b\u044f\", \"\u043f\u043e\u043d\u0435\u0434\u0456\u043b\u043e\u043a\", \"\u0432\u0456\u0432\u0442\u043e\u0440\u043e\u043a\", \"\u0441\u0435\u0440\u0435\u0434\u0430\", \"\u0447\u0435\u0442\u0432\u0435\u0440\", \"\u043f'\u044f\u0442\u043d\u0438\u0446\u044f\", \"\u0441\u0443\u0431\u043e\u0442\u0430\"),\n                listOf(\"\u043d\u0434\", \"\u043f\u043d\", \"\u0432\u0442\", \"\u0441\u0440\", \"\u0447\u0442\", \"\u043f\u0442\", \"\u0441\u0431\"),\n                listOf(\"\u0441\u0456\u0447\u043d\u044f\", \"\u043b\u044e\u0442\u043e\u0433\u043e\", \"\u0431\u0435\u0440\u0435\u0437\u043d\u044f\", \"\u043a\u0432\u0456\u0442\u043d\u044f\", \"\u0442\u0440\u0430\u0432\u043d\u044f\", \"\u0447\u0435\u0440\u0432\u043d\u044f\", \"\u043b\u0438\u043f\u043d\u044f\", \"\u0441\u0435\u0440\u043f\u043d\u044f\", \"\u0432\u0435\u0440\u0435\u0441\u043d\u044f\", \"\u0436\u043e\u0432\u0442\u043d\u044f\", \"\u043b\u0438\u0441\u0442\u043e\u043f\u0430\u0434\u0430\", \"\u0433\u0440\u0443\u0434\u043d\u044f\"),\n                listOf(\"\u0441\u0456\u0447.\", \"\u043b\u044e\u0442.\", \"\u0431\u0435\u0440.\", \"\u043a\u0432\u0456\u0442.\", \"\u0442\u0440\u0430\u0432.\", \"\u0447\u0435\u0440\u0432.\", \"\u043b\u0438\u043f.\", \"\u0441\u0435\u0440\u043f.\", \"\u0432\u0435\u0440.\", \"\u0436\u043e\u0432\u0442.\", \"\u043b\u0438\u0441\u0442.\", \"\u0433\u0440\u0443\u0434.\")\n        )\n\n        fun zh_CN() = locale(\"%x %A %X\",\n                \"%Y\u5e74%-m\u6708%-d\u65e5\",\n                \"%H:%M:%S\",\n                listOf(\"\u4e0a\u5348\", \"\u4e0b\u5348\"),\n                listOf(\"\u661f\u671f\u65e5\", \"\u661f\u671f\u4e00\", \"\u661f\u671f\u4e8c\", \"\u661f\u671f\u4e09\", \"\u661f\u671f\u56db\", \"\u661f\u671f\u4e94\", \"\u661f\u671f\u516d\"),\n                listOf(\"\u5468\u65e5\", \"\u5468\u4e00\", \"\u5468\u4e8c\", \"\u5468\u4e09\", \"\u5468\u56db\", \"\u5468\u4e94\", \"\u5468\u516d\"),\n                listOf(\"\u4e00\u6708\", \"\u4e8c\u6708\", \"\u4e09\u6708\", \"\u56db\u6708\", \"\u4e94\u6708\", \"\u516d\u6708\", \"\u4e03\u6708\", \"\u516b\u6708\", \"\u4e5d\u6708\", \"\u5341\u6708\", \"\u5341\u4e00\u6708\", \"\u5341\u4e8c\u6708\"),\n                listOf(\"\u4e00\u6708\", \"\u4e8c\u6708\", \"\u4e09\u6708\", \"\u56db\u6708\", \"\u4e94\u6708\", \"\u516d\u6708\", \"\u4e03\u6708\", \"\u516b\u6708\", \"\u4e5d\u6708\", \"\u5341\u6708\", \"\u5341\u4e00\u6708\", \"\u5341\u4e8c\u6708\")\n        )\n    }\n}\n"],"names":[],"mappings":"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"}