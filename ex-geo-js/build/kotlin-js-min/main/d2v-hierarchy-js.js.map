{"version":3,"file":"d2v-hierarchy-js.js","sources":["collections/Collections.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/ClusterLayout.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/Hierarchy.kt","generated/_Collections.kt","../../../../../../../../../../dummy.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/PackLayout.kt","kotlin/math.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/PartitionLayout.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/TreeLayout.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/TreemapLayout.kt","util/Standard.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/pack/Enclose.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/pack/Siblings.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/treemap/Binary.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/treemap/Resquarify.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/treemap/SliceDice.kt","../../../../../d2v-hierarchy-common/src/main/kotlin/io/data2viz/hierarchy/treemap/Squarify.kt"],"sourcesContent":["/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.*\nimport kotlin.comparisons.compareValues\nimport kotlin.contracts.*\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function. The [init] function returns a list element given its index.\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which [comparison] function returns zero using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the provided [comparison],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that compares an element of the list with the element being searched.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","package io.data2viz.hierarchy\n\ndata class ClusterNode<D>(\n    val data: D,\n    var depth: Int,\n    var height: Int,\n    override var value: Double?,\n    override val children: MutableList<ClusterNode<D>> = mutableListOf(),\n    override var parent: ClusterNode<D>? = null,\n    var x: Double = .0,\n    var y: Double = .0\n): ParentValued<ClusterNode<D>>, Children<ClusterNode<D>>\n\nclass ClusterLayout {\n\n    var nodeSize = false\n    private var dx = 1.0\n    private var dy = 1.0\n\n    /**\n     * Lays out the specified root hierarchy, assigning the following properties on root and its descendants:\n     * node.x - the x-coordinate of the node\n     * node.y - the y-coordinate of the node\n     *\n     * The coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle\n     * and y as a radius to produce a radial layout.\n     * You may want to call root.sort before passing the hierarchy to the cluster layout.\n     *\n     * The cluster layout produces dendrograms: node-link diagrams that place leaf nodes of the tree at the same depth.\n     * Dendograms are typically less compact than tidy trees, but are useful when all the leaves should be at\n     * the same level, such as for hierarchical clustering or phylogenetic tree diagrams.\n     */\n    fun <D> cluster(root: Node<D>): ClusterNode<D> {\n\n        val rootCluster = makeCluster(root)\n\n        var previousNode: ClusterNode<D>? = null\n        var x = .0\n\n        // First walk, computing the initial x & y values\n        rootCluster.eachAfter({ node: ClusterNode<D> ->\n            val children = node.children\n            if (children.isNotEmpty()) {\n                node.x = children.sumByDouble { it.x } / children.size\n                node.y = children.maxBy { it.y }!!.y + 1\n            } else {\n                if (previousNode != null) {\n                    x += separation(node, previousNode!!)\n                    node.x = x\n                } else node.x = .0\n                node.y = .0\n                previousNode = node\n            }\n        })\n\n        val left = leafLeft(rootCluster)\n        val right = leafRight(rootCluster)\n        val x0 = left.x - separation(left, right) / 2\n        val x1 = right.x + separation(right, left) / 2\n\n        // Second walk, normalizing x & y to the desired size.\n        return if (nodeSize) {\n            rootCluster.eachAfter({ node: ClusterNode<D> ->\n                node.x = (node.x - rootCluster.x) * dx\n                node.y = (rootCluster.y - node.y) * dy\n            })\n        } else {\n            rootCluster.eachAfter({ node: ClusterNode<D> ->\n                node.x = (node.x - x0) / (x1 - x0) * dx\n                node.y = if (rootCluster.y == .0) .0 else (1 - (node.y / rootCluster.y)) * dy\n            })\n        }\n    }\n\n    fun size(width: Double, height: Double) {\n        nodeSize = false\n        dx = width\n        dy = height\n    }\n\n    fun nodeSize(width: Double, height: Double) {\n        nodeSize = true\n        dx = width\n        dy = height\n    }\n\n    private fun <D> makeCluster(root: Node<D>): ClusterNode<D> {\n        val rootCluster = ClusterNode(root.data, root.depth, root.height, root.value)\n        val nodes = mutableListOf(root)\n        val nodesC = mutableListOf(rootCluster)\n        while (nodes.isNotEmpty()) {\n            val node = nodes.removeAt(nodes.lastIndex)\n            val nodeC = nodesC.removeAt(nodesC.lastIndex)\n            node.children.forEach { child ->\n                val c = ClusterNode(child.data, child.depth, child.height, child.value)\n                c.parent = nodeC\n                nodeC.children.add(c)\n                nodes.add(child)\n                nodesC.add(c)\n            }\n        }\n        return rootCluster\n    }\n\n    private fun <D> leafLeft(node: ClusterNode<D>): ClusterNode<D> {\n        var children = node.children\n        var current: ClusterNode<D> = node\n        while (children.isNotEmpty()) {\n            current = children[0]\n            children = current.children\n        }\n        return current\n    }\n\n    private fun <D> leafRight(node: ClusterNode<D>): ClusterNode<D> {\n        var children = node.children\n        var current: ClusterNode<D> = node\n        while (children.isNotEmpty()) {\n            current = children[children.lastIndex]\n            children = current.children\n        }\n        return current\n    }\n}","package io.data2viz.hierarchy\n\ninterface Valued { var value: Double? }\ninterface Children<T> { val parent: ParentValued<T>? }\ninterface ParentValued<T>: Valued {val children: List<ParentValued<T>>}\n\ndata class Node<D>(\n    val data: D,\n    var depth: Int = 0,\n    var height: Int = 0,\n    override var value: Double? = null,\n    override val children: MutableList<Node<D>> = mutableListOf(),\n    override var parent: Node<D>? = null\n): ParentValued<Node<D>>, Children<Node<D>>\n\ndata class Link<D>(\n    val source: Node<D>?,\n    var target: Node<D>\n)\n\n/**\n * Constructs a root node from the specified hierarchical data. The specified data must be an object\n * representing the root node.\n * The specified children accessor function is invoked for each datum, starting with the root data, and must\n * return an array of data representing the children, or null if the current datum has no children.\n * The specified value accessor function is invoked for each datum, starting with the root data, and must return\n * a Double value representing the data. If value is not specified, it defaults to null (no value for nodes).\n * TODO : value\n */\nfun <D> hierarchy(data: D, children: (D) -> List<D>?, value: ((D) -> Double)? = null): Node<D> {\n    val root = Node(data)\n    val nodes = mutableListOf(root)\n\n    while (nodes.size > 0) {\n        val node = nodes.removeAt(nodes.lastIndex)\n        val childs = children(node.data)\n        if (childs != null) {\n            childs.forEach { c ->\n                val child = Node(c)\n                child.parent = node\n                child.depth = node.depth + 1\n                //if (value != null) child.value = value(c)\n                node.children.add(child)\n                nodes.add(child)\n            }\n        }\n    }\n    return root.eachBefore(::computeHeight)\n}\n\n/**\n * Computes the number of leaves under this node and assigns it to node.value, and similarly for every\n * descendant of node.\n * If this node is a leaf, its count is one.\n * Returns this node.\n * See also node.sum.\n */\nfun <D> Node<D>.count(): Node<D> {\n    return this.eachAfter(::nodeCount)\n}\n\n/**\n * TODO check behavior (especially non-negative value)\n * Evaluates the specified value function for this node and each descendant in post-order traversal,\n * and returns this node.\n * The node.value property of each node is set to the numeric value returned by the specified function plus\n * the combined value of all descendants. The function is passed the node\u2019s data, and must return a non-negative number.\n * The value accessor is evaluated for node and every descendant, including internal nodes; if you only want leaf\n * nodes to have internal value, then return zero for any node with children.\n */\nfun <D> Node<D>.sum(value: ((D) -> Double)? = null): Node<D> {\n    return this.eachAfter({ node: Node<D> ->\n        var sum = if (value != null) value(node.data) else .0\n        node.children.forEach { child -> if (child.value != null) sum += child.value!! }\n        node.value = sum\n    })\n}\n\n/**\n * Returns the array of ancestors nodes, starting with this node, then followed by each parent up to the root.\n */\nfun <D> Node<D>.ancestors(): List<Node<D>> {\n    val nodes: MutableList<Node<D>> = mutableListOf(this)\n    var node: Node<D>? = this\n    while (node != null\n    ) {\n        nodes.add(node)\n        node = node.parent\n    }\n    return nodes.toList()\n}\n\n/**\n * Returns the array of descendant nodes, starting with this node, then followed by each child in topological order.\n */\nfun <D> Node<D>.descendants(): List<Node<D>> {\n    val nodes: MutableList<Node<D>> = mutableListOf()\n    this.each({ node: Node<D> ->\n        nodes.add(node)\n    })\n    return nodes\n}\n\n/**\n * Returns the array of leaf nodes in traversal order; leaves are nodes with no children.\n */\nfun <D> Node<D>.leaves(): List<Node<D>> {\n    val leaves: MutableList<Node<D>> = mutableListOf()\n    this.eachBefore({ node: Node<D> ->\n        if (node.children.isEmpty()) leaves.add(node)\n    })\n    return leaves\n}\n\n/**\n * Returns an array of links for this node, where each link is an object that defines source and target properties.\n * The source of each link is the parent node, and the target is a child node.\n */\nfun <D> Node<D>.links(): List<Link<D>> {\n    val root = this\n    val links: MutableList<Link<D>> = mutableListOf()\n    root.each({ node: Node<D> ->\n        if (node != root) links.add(Link(node.parent, node))    // Don\u2019t include the root\u2019s parent, if any.\n    })\n    return links.toList()\n}\n\ninline fun <reified N: Children<D>, D> separation(nodeA: N, nodeB: N) = if (nodeA.parent == nodeB.parent) 1 else 2\n\n/**\n * Invokes the specified function for node and each descendant in breadth-first order, such that a given\n * node is only visited if all nodes of lesser depth have already been visited, as well as all preceeding\n * nodes of the same depth.\n * The specified function is passed the current node.\n */\ninline fun <reified N: ParentValued<D>, D> N.each(callback: (N) -> Unit): N {\n    val next = mutableListOf(this)\n    while (next.size > 0) {\n        val current = next.reversed().toMutableList()\n        next.clear()\n        val node = current.removeAt(current.lastIndex)\n        callback(node)\n        val children = node.children\n        if (children.isNotEmpty()) {\n            (children.lastIndex downTo 0).forEach {\n                next.add(children[it] as N)\n            }\n        }\n    }\n    return this\n}\n\n/**\n * Invokes the specified function for node and each descendant in pre-order traversal, such that a given node\n * is only visited after all of its ancestors have already been visited.\n * The specified function is passed the current node.\n */\ninline fun <reified N: ParentValued<D>, D> N.eachBefore(callback: (N) -> Unit): N {\n    val nodes = mutableListOf(this)\n    while (nodes.isNotEmpty()) {\n        val node = nodes.removeAt(nodes.lastIndex)\n        callback(node)\n        val children = node.children\n        if (children.isNotEmpty()) {\n            (children.lastIndex downTo 0).forEach {\n                nodes.add(children[it] as N)\n            }\n        }\n    }\n    return this\n}\n\n/**\n * Invokes the specified function for node and each descendant in post-order traversal, such that a given node\n * is only visited after all of its descendants have already been visited.\n * The specified function is passed the current node.\n */\ninline fun <reified N: ParentValued<D>, D> N.eachAfter(callback: (N) -> Unit): N {\n    val nodes = mutableListOf(this)\n    val next = mutableListOf<N>()\n    while (nodes.isNotEmpty()) {\n        val node = nodes.removeAt(nodes.lastIndex)\n        next.add(node)\n        val children = node.children\n        if (children.isNotEmpty()) {\n            children.forEach {\n                nodes.add(it as N)\n            }\n        }\n    }\n    next.reversed().forEach(callback)\n    return this\n}\n\nprivate fun <D> computeHeight(node: Node<D>) {\n    var n: Node<D> = node\n    var height = 0\n    n.height = height\n    height++\n\n    while (n.parent != null && n.parent!!.height < height) {\n        n.parent!!.height = height\n        n = n.parent!!\n        height++\n    }\n}\n\nprivate fun <D> nodeCount(node: Node<D>) {\n    var sum = .0\n    val children = node.children\n    if (children.isEmpty()) sum = 1.0\n    else {\n        children.forEach { if (it.value != null) sum += it.value!! }\n    }\n    node.value = sum\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license \n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.*\nimport kotlin.text.*\nimport kotlin.comparisons.*\nimport kotlin.random.*\n\n/**\n * Returns 1st *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count++ >= n) list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        if (count++ == n)\n            break\n        list.add(item)\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] of [IndexedValue] for each element of the original collection.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source collection.\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this set and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a mutable set containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the desired action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    if (max.isNaN()) return max\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    var maxValue = selector(maxElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    if (min.isNaN()) return min\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (e.isNaN()) return e\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    var minValue = selector(minElem)\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right to current accumulator value and each element.\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left to each element and current accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have less elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * The [elements] array may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.toHashSet()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * The [elements] collection may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * The [elements] sequence may be converted to a [HashSet] to speed up the operation, thus the elements are required to have\n * a correct and stable implementation of `hashCode()` that doesn't change between successive invocations.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.toHashSet()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<List<T>>((thisSize + step - 1) / step)\n        var index = 0\n        while (index < thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have less elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val result = ArrayList<R>((thisSize + step - 1) / step)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index < thisSize) {\n            window.move(index, (index + size).coerceAtMost(thisSize))\n            if (!partialWindows && window.size < size) break\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n",null,"package io.data2viz.hierarchy\n\nimport io.data2viz.hierarchy.pack.packEnclose\nimport kotlin.math.max\nimport kotlin.math.min\nimport kotlin.math.sqrt\n\ninterface CircleValues{\n    var x: Double\n    var y: Double\n    var r: Double\n}\n\ndata class PackNode<D>(\n    val data: D,\n    var depth: Int,\n    var height: Int,\n    override var value: Double?,\n    override val children: MutableList<PackNode<D>> = mutableListOf(),\n    override var parent: PackNode<D>? = null,\n    override var x: Double = .0,\n    override var y: Double = .0,\n    override var r: Double = .0,\n    var previous: PackNode<D>? = null,\n    var next: PackNode<D>? = null\n) : ParentValued<PackNode<D>>, Children<PackNode<D>>, CircleValues\n\nfun <D> packNode(node: PackNode<D>): PackNode<D> = PackNode(\n    node.data, node.depth, node.height, node.value, node.children, node.parent, node.x, node.y, node.r, node.previous, node.next\n)\n\n/**\n * Enclosure diagrams use containment (nesting) to represent a hierarchy.\n * The size of the leaf circles encodes a quantitative dimension of the data.\n * The enclosing circles show the approximate cumulative size of each subtree, but due to wasted space there is\n * some distortion; only the leaf nodes can be compared accurately. Although circle packing does not use space\n * as efficiently as a treemap, the \u201cwasted\u201d space more prominently reveals the hierarchical structure.\n */\nclass PackLayout<D> {\n\n    private val constantZero: (PackNode<D>) -> Double = { .0 }\n    private val defaultRadius: (PackNode<D>) -> Double = { sqrt(it.value!!) }\n\n    private var dx = 1.0\n    private var dy = 1.0\n\n    /**\n     * If radius is specified, sets the pack layout\u2019s radius accessor to the specified function.\n     * If the radius accessor is null, the radius of each leaf circle is derived from the leaf node.value\n     * (computed by node.sum); the radii are then scaled proportionally to fit the layout size.\n     * If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.\n     */\n    var radius: ((PackNode<D>) -> Double)? = null\n\n    /**\n     * If padding is specified, sets this pack layout\u2019s padding accessor to the specified function.\n     * When siblings are packed, tangent siblings will be separated by approximately the specified padding;\n     * the enclosing parent circle will also be separated from its children by approximately the specified padding.\n     *\n     * If an explicit radius is not specified (null), the padding is approximate because a two-pass algorithm is\n     * needed to fit within the layout size: the circles are first packed without padding; a scaling factor is computed\n     * and applied to the specified padding; and lastly the circles are re-packed with padding.\n     */\n    var padding: (PackNode<D>) -> Double = constantZero\n\n    /**\n     * Lays out the specified root hierarchy, assigning the following properties on root and its descendants:\n     * - node.x - the x-coordinate of the circle\u2019s center\n     * - node.y - the y-coordinate of the circle\u2019s center\n     * - node.r - the radius of the circle\n     *\n     * You must call root.sum before passing the hierarchy to the pack layout.\n     * You probably also want to call root.sort to order the hierarchy before computing the layout.\n     */\n    fun pack(root: Node<D>): PackNode<D> {\n\n        val rootPack = makePack(root)\n\n        rootPack.x = dx / 2\n        rootPack.y = dy / 2\n        if (radius != null) {\n            rootPack.eachBefore(radiusLeaf(radius!!))\n                .eachAfter(packChildren(padding, 0.5))\n                .eachBefore(translateChild(1.0))\n        } else {\n            rootPack.eachBefore(radiusLeaf(defaultRadius))\n                .eachAfter(packChildren(constantZero, 1.0))\n                .eachAfter(packChildren(padding, rootPack.r / min(dx, dy)))\n                .eachBefore(translateChild(min(dx, dy) / (2 * rootPack.r)))\n        }\n        return rootPack\n    }\n\n    fun size(width: Double, height: Double) {\n        dx = width\n        dy = height\n    }\n\n    /**\n     * If radius is specified, sets the pack layout\u2019s radius accessor to the specified function and returns this\n     * pack layout.\n     * If radius is not specified, returns the current radius accessor, which defaults to null.\n     * If the radius accessor is null, the radius of each leaf circle is derived\n     * from the leaf node.value (computed by node.sum); the radii are then scaled proportionally to fit the layout size.\n     * If the radius accessor is not null, the radius of each leaf circle is specified exactly by the function.\n     */\n    fun radius(radius: ((PackNode<D>) -> Double)?) {\n        this.radius = radius\n    }\n\n    /**\n     * If padding is specified, sets this pack layout\u2019s padding accessor to the specified number or function\n     * or returns this pack layout.\n     * If padding is not specified, returns the current padding accessor, which defaults to the constant zero.\n     * When siblings are packed, tangent siblings will be separated by approximately the specified padding;\n     * the enclosing parent circle will also be separated from its children by approximately the specified padding.\n     * If an explicit radius is not specified, the padding is approximate because a two-pass algorithm is needed\n     * to fit within the layout size: the circles are first packed without padding; a scaling factor is computed\n     * and applied to the specified padding; and lastly the circles are re-packed with padding.\n     */\n    fun padding(padding: (PackNode<D>) -> Double) {\n        this.padding = padding\n    }\n\n    // TODO check positive value ?\n    private fun radiusLeaf(radius: ((PackNode<D>) -> Double)): ((PackNode<D>) -> Unit) {\n        return { node: PackNode<D> ->\n            if (node.children.isEmpty()) {\n                node.r = max(.0, radius(node))\n            }\n        }\n    }\n\n    private fun <D> makePack(root: Node<D>): PackNode<D> {\n        val rootPack = PackNode(root.data, root.depth, root.height, root.value)\n        val nodes = mutableListOf(root)\n        val nodesP = mutableListOf(rootPack)\n        while (nodes.isNotEmpty()) {\n            val node = nodes.removeAt(nodes.lastIndex)\n            val nodeP = nodesP.removeAt(nodesP.lastIndex)\n            node.children.forEach { child ->\n                val c = PackNode(child.data, child.depth, child.height, child.value)\n                c.parent = nodeP\n                nodeP.children.add(c)\n                nodes.add(child)\n                nodesP.add(c)\n            }\n        }\n        return rootPack\n    }\n\n    private fun packChildren(padding: (PackNode<D>) -> Double, k: Double): ((PackNode<D>) -> Unit) {\n        return { node: PackNode<D> ->\n            if (node.children.isNotEmpty()) {\n                val children = node.children\n                val r = padding(node) * k\n\n                children.forEach { it.r += r }\n                val e = packEnclose(children)\n                children.forEach { it.r -= r }\n                node.r = e + r\n            }\n        }\n    }\n\n    private fun translateChild(k: Double): ((PackNode<D>) -> Unit) {\n        return { node: PackNode<D> ->\n            val parent = node.parent\n            node.r *= k\n            if (parent != null) {\n                node.x = parent.x + k * node.x\n                node.y = parent.y + k * node.y\n            }\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n@file:Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.Math as nativeMath\n\n\n// ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x).unsafeCast<Double>() // TODO: Remove unsafe cast after removing public js.math\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x).unsafeCast<Double>()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x).unsafeCast<Double>()\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.withSign(sign: Double): Double {\n    val thisSignBit = js(\"Kotlin\").doubleSignBit(this).unsafeCast<Int>()\n    val newSignBit = js(\"Kotlin\").doubleSignBit(sign).unsafeCast<Int>()\n    return if (thisSignBit == newSignBit) this else -this\n}\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).unsafeCast<Double>().toLong()\n}\n\n\n\n\n// ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n","package io.data2viz.hierarchy\n\nimport io.data2viz.hierarchy.treemap.treemapDice\n\n\nclass PartitionLayout {\n\n    var round = false\n    private var dx = 1.0\n    private var dy = 1.0\n    var padding = .0\n\n    /**\n     * The partition layout produces adjacency diagrams: a space-filling variant of a node-link tree diagram.\n     * Rather than drawing a link between parent and child in the hierarchy, nodes are drawn as solid areas\n     * (either arcs or rectangles), and their placement relative to other nodes reveals their position in the hierarchy.\n     * The size of the nodes encodes a quantitative dimension that would be difficult to show in a node-link diagram.\n     *\n     * Lays out the specified root hierarchy, assigning the following properties on root and its descendants:\n     *  - node.x0 - the left edge of the rectangle\n     *  - node.y0 - the top edge of the rectangle\n     *  - node.x1 - the right edge of the rectangle\n     *  - node.y1 - the bottom edge of the rectangle\n     *\n     *  You must call root.sum before passing the hierarchy to the partition layout.\n     *  You probably also want to call root.sort to order the hierarchy before computing the layout.\n     */\n    fun <D> partition(root: Node<D>): TreemapNode<D> {\n\n        // TODO check for sum called\n\n        val rootNode = makeTreemap(root)\n\n        val n = rootNode.height + 1\n        rootNode.x0 = padding\n        rootNode.y0 = padding\n        rootNode.x1 = dx\n        rootNode.y1 = dy / n\n        rootNode.eachBefore(positionNode(dy, n))\n\n        if (round) rootNode.eachBefore(::roundNode)\n\n        return rootNode\n    }\n\n    private fun <D> positionNode(dy: Double, n: Int):((TreemapNode<D>)->Unit) {\n        return { node:TreemapNode<D> ->\n            if (node.children.isNotEmpty()) {\n                treemapDice(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);\n            }\n            var x0 = node.x0\n            var y0 = node.y0\n            var x1 = node.x1 - padding\n            var y1 = node.y1 - padding\n            if (x1 < x0) {\n                x0 = (x0 + x1) / 2\n                x1 = x0\n            }\n            if (y1 < y0) {\n                y0 = (y0 + y1) / 2\n                y1 = y0\n            }\n            node.x0 = x0\n            node.y0 = y0\n            node.x1 = x1\n            node.y1 = y1\n        }\n    }\n\n    fun size(width: Double, height: Double) {\n        dx = width\n        dy = height\n    }\n\n    private fun <D> makeCluster(root: Node<D>): ClusterNode<D> {\n        val rootCluster = ClusterNode(root.data, root.depth, root.height, root.value)\n        val nodes = mutableListOf(root)\n        val nodesC = mutableListOf(rootCluster)\n        while (nodes.isNotEmpty()) {\n            val node = nodes.removeAt(nodes.lastIndex)\n            val nodeC = nodesC.removeAt(nodesC.lastIndex)\n            node.children.forEach { child ->\n                val c = ClusterNode(child.data, child.depth, child.height, child.value)\n                c.parent = nodeC\n                nodeC.children.add(c)\n                nodes.add(child)\n                nodesC.add(c)\n            }\n        }\n        return rootCluster\n    }\n}","package io.data2viz.hierarchy\n\ndata class TreeNode<D>(\n    val data: D?,\n    var depth: Int,\n    var height: Int,\n    override var value: Double?,\n    internal val index: Int = 0,\n    var x:Double = .0,\n    var y:Double = .0,\n    internal var A: TreeNode<D>? = null,             // default ancestor\n    internal var ancestor: TreeNode<D>? = null,      // ancestor\n    internal var z: Double = .0,                     // prelim (TODO : Int ?)\n    internal var m: Double = .0,                     // mod (TODO : Int ?)\n    internal var c: Double = .0,                     // change\n    internal var s: Double = .0,                     // shift\n    internal var t: TreeNode<D>? = null,             // thread\n    override val children: MutableList<TreeNode<D>> = mutableListOf(),\n    override var parent: TreeNode<D>? = null\n): ParentValued<TreeNode<D>>, Children<TreeNode<D>>\n\nclass TreeLayout<D> {\n\n    private var nodeSize = false\n    private var dx = 1.0\n    private var dy = 1.0\n\n    /**\n     * Lays out the specified root hierarchy, assigning the following properties on root and its descendants:\n     * node.x - the x-coordinate of the node\n     * node.y - the y-coordinate of the node\n     *\n     * The coordinates x and y represent an arbitrary coordinate system; for example, you can treat x as an angle\n     * and y as a radius to produce a radial layout.\n     * You may want to call root.sort before passing the hierarchy to the tree layout.\n     *\n     * The tree layout produces tidy node-link diagrams of trees using the Reingold\u2013Tilford \u201ctidy\u201d algorithm,\n     * improved to run in linear time by Buchheim et al. Tidy trees are typically more compact than dendograms.\n     */\n    fun <D> tree(root: Node<D>): TreeNode<D> {\n        val rootChild = makeTree(root)\n\n        // Compute the layout using Buchheim et al.\u2019s algorithm.\n        rootChild.eachAfter(this::firstWalk)\n        rootChild.parent!!.m = -rootChild.z\n        rootChild.eachBefore(this::secondWalk)\n\n        // If a fixed node size is specified, scale x and y.\n        if (nodeSize) rootChild.eachBefore(this::sizeNode)\n\n        // If a fixed tree size is specified, scale x and y based on the extent.\n        // Compute the left-most, right-most, and depth-most nodes for extents.\n        else {\n            var left = rootChild\n            var right = rootChild\n            var bottom = rootChild\n            rootChild.eachBefore({ node: TreeNode<D> ->\n                if (node.x < left.x) left = node\n                if (node.x > right.x) right = node\n                if (node.depth > bottom.depth) bottom = node\n            })\n            val s = if (left == right) 1.0 else separation(left, right) / 2.0\n            val tx = s - left.x\n            val kx = dx / (right.x + s + tx)\n            val ky = dy / if (bottom.depth == 0) 1.0 else bottom.depth.toDouble()\n            rootChild.eachBefore({ node: TreeNode<D> ->\n                node.x = (node.x + tx) * kx\n                node.y = node.depth * ky\n            })\n        }\n\n        return rootChild\n    }\n\n    fun size(width: Double, height: Double) {\n        nodeSize = false\n        dx = width\n        dy = height\n    }\n\n    fun nodeSize(width: Double, height: Double) {\n        nodeSize = true\n        dx = width\n        dy = height\n    }\n\n    /**\n     * Computes a preliminary x-coordinate for v. Before that, FIRST WALK is applied recursively to the children of v,\n     * as well as the function APPORTION.\n     * After spacing out the children by calling EXECUTE SHIFTS, the node v is placed to the midpoint\n     * of its outermost children.\n     */\n    private fun <D> firstWalk(v: TreeNode<D>) {\n        val children: MutableList<TreeNode<D>> = v.children\n        val siblings: MutableList<TreeNode<D>> = v.parent!!.children\n        val w: TreeNode<D>? = if (v.index != 0) siblings[v.index - 1] else null\n        if (children.isNotEmpty()) {\n            executeShifts(v)\n            val firstChild = children[0]\n            val lastChild = children[children.lastIndex]\n            val midpoint = (firstChild.z + lastChild.z) / 2.0\n            if (w != null) {\n                v.z = w.z + separation(v, w)\n                v.m = v.z - midpoint\n            } else {\n                v.z = midpoint\n            }\n        } else if (w != null) {\n            v.z = w.z + separation(v, w)\n        }\n        val parent = v.parent!!\n        val ancestor: TreeNode<D> = if (parent.A != null) parent.A!! else siblings[0]\n        parent.A = apportion(v, w, ancestor)\n    }\n\n    /**\n     * Computes all real x-coordinates by summing up the modifiers recursively.\n     */\n    private fun <D> secondWalk(v: TreeNode<D>) {\n        v.x = v.z + v.parent!!.m\n        v.m += v.parent!!.m\n    }\n\n    private fun <D> sizeNode(node: TreeNode<D>) {\n        node.x *= dx\n        node.y = node.depth * dy\n    }\n\n    /**\n     * The core of the algorithm. Here, a new subtree is combined with the previous subtrees.\n     * Threads are used to traverse the inside and outside contours of the left and right subtree up to the\n     * highest common level.\n     * The vertices used for the traversals are vi+, vi-, vo-, and vo+, where the superscript o means outside\n     * and i means inside, the subscript - means left subtree and + means right subtree.\n     * For summing up the modifiers along the contour, we use respective variables si+, si-, so-, and so+.\n     * Whenever two nodes of the inside contours conflict, we compute the left one of the greatest uncommon ancestors\n     * using the function ANCESTOR and call MOVE SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.\n     * Finally, we add a new thread (if necessary).\n     */\n\n    private fun <D> apportion(v: TreeNode<D>, w: TreeNode<D>?, ancestor: TreeNode<D>): TreeNode<D> {\n        var ancestorNew = ancestor\n        if (w != null) {\n            var vip: TreeNode<D>? = v\n            var vop: TreeNode<D>? = v\n            var vim: TreeNode<D>? = w\n            var vom: TreeNode<D>? = vip!!.parent!!.children[0]\n            var sip = vip.m\n            var sop = vop!!.m\n            var sim = vim!!.m\n            var som = vom!!.m\n            var shift: Double\n\n            vim = nextRight(vim)\n            vip = nextLeft(vip)\n            while (vim != null && vip != null) {\n                vom = nextLeft(vom!!)\n                vop = nextRight(vop!!)\n                vop!!.ancestor = v\n                shift = vim.z + sim - vip.z - sip + separation(vim, vip)\n                if (shift > 0) {\n                    moveSubtree(nextAncestor(vim, v, ancestorNew), v, shift)\n                    sip += shift\n                    sop += shift\n                }\n                sim += vim.m\n                sip += vip.m\n                if (vom != null) som += vom.m\n                if (vop != null) sop += vop.m\n\n                vim = nextRight(vim)\n                vip = nextLeft(vip)\n            }\n            if (vim != null && nextRight(vop!!) == null) {\n                vop.t = vim\n                vop.m += sim - sop\n            }\n            if (vip != null && nextLeft(vom!!) == null) {\n                vom.t = vip\n                vom.m += sip - som\n                ancestorNew = v\n            }\n        }\n        return ancestorNew\n    }\n\n    /**\n     * If vi-\u2019s ancestor is a sibling of v, returns vi-\u2019s ancestor. Otherwise, returns the specified (default) ancestor.\n     */\n    private fun <D> nextAncestor(vim: TreeNode<D>, v: TreeNode<D>, ancestor: TreeNode<D>): TreeNode<D> {\n        return if (vim.ancestor?.parent == v.parent) vim.ancestor!! else ancestor\n    }\n\n    /**\n     * Shifts the current subtree rooted at w+. This is done by increasing prelim(w+) and mod(w+) by shift.\n     */\n    private fun <D> moveSubtree(wm: TreeNode<D>, wp: TreeNode<D>, shift: Double) {\n        val change = shift / (wp.index - wm.index)\n        wp.c -= change\n        wp.s += shift\n        wm.c += change\n        wp.z += shift\n        wp.m += shift\n    }\n\n    /**\n     * This function is used to traverse the left contour of a subtree (or subforest).\n     * It returns the successor of v on this contour. This successor is either given by the leftmost child of v or by the thread of v.\n     * The function returns null if and only if v is on the highest level of its subtree.\n     */\n    private fun <D> nextLeft(v: TreeNode<D>): TreeNode<D>? {\n        return if (v.children.isNotEmpty()) (v.children[0]) else v.t\n    }\n\n    /**\n     * This function works analogously to nextLeft.\n     */\n    private fun <D> nextRight(v: TreeNode<D>): TreeNode<D>? {\n        return if (v.children.isNotEmpty()) (v.children[v.children.lastIndex]) else v.t\n    }\n\n    /**\n     * All other shifts, applied to the smaller subtrees between w- and w+, are performed by this function.\n     * To prepare the shifts, we have to adjust change(w+), shift(w+), and change(w-).\n     */\n    private fun <D> executeShifts(v: TreeNode<D>) {\n        var shift = .0\n        var change = .0\n        val children = v.children\n        var i = children.size\n        while (--i >= 0) {\n            val w = children[i]\n            w.z += shift\n            w.m += shift\n            change += w.c\n            shift += w.s + change\n        }\n    }\n\n    private fun <D> makeTree(root: Node<D>): TreeNode<D> {\n        val rootTree = TreeNode(root.data, root.depth, root.height, root.value)\n        rootTree.ancestor = rootTree\n        val nodes = mutableListOf(root)\n        val nodesT = mutableListOf(rootTree)\n\n        while (nodes.isNotEmpty()) {\n            val node = nodes.removeAt(nodes.lastIndex)\n            val nodeT = nodesT.removeAt(nodesT.lastIndex)\n            node.children.forEachIndexed {index, child ->\n                val c = TreeNode(child.data, child.depth, child.height, child.value, index)\n                c.ancestor = c\n                c.parent = nodeT\n                nodeT.children.add(c)\n                nodes.add(child)\n                nodesT.add(c)\n            }\n        }\n\n        val treeRoot = TreeNode<D>(null, 0, 0, null, 0)\n        treeRoot.ancestor = treeRoot\n        treeRoot.children.add(rootTree)\n        rootTree.parent = treeRoot\n\n        return rootTree\n    }\n}","package io.data2viz.hierarchy\n\nimport io.data2viz.hierarchy.treemap.treemapSquarify\nimport kotlin.math.roundToInt\n\ndata class Row<D>(\n    override var value: Double?,\n    val dice:Boolean,\n    override val children:List<TreemapNode<D>>\n) : ParentValued<TreemapNode<D>>\n\nclass TreemapNode<D>(\n    val data: D,\n    var depth: Int,\n    var height: Int,\n    override var value: Double?,                 // TODO differentiate value and SUM\n    override val children: MutableList<TreemapNode<D>> = mutableListOf(),\n    override var parent: TreemapNode<D>? = null,\n    var x0: Double = .0,\n    var y0: Double = .0,\n    var x1: Double = .0,\n    var y1: Double = .0\n): ParentValued<TreemapNode<D>>, Children<TreemapNode<D>>\n\ninternal fun roundNode(node: TreemapNode<*>) {\n    node.x0 = node.x0.roundToInt().toDouble()\n    node.y0 = node.y0.roundToInt().toDouble()\n    node.x1 = node.x1.roundToInt().toDouble()\n    node.y1 = node.y1.roundToInt().toDouble()\n}\n\ninternal fun <D> makeTreemap(root: Node<D>): TreemapNode<D> {\n    val rootTreemap = TreemapNode(root.data, root.depth, root.height, root.value)\n    val nodes = mutableListOf(root)\n    val nodesTM = mutableListOf(rootTreemap)\n    while (nodes.isNotEmpty()) {\n        val node = nodes.removeAt(nodes.lastIndex)\n        val nodeTM = nodesTM.removeAt(nodesTM.lastIndex)\n        node.children.forEach { child ->\n            val c = TreemapNode(child.data, child.depth, child.height, child.value)\n            c.parent = nodeTM\n            nodeTM.children.add(c)\n            nodes.add(child)\n            nodesTM.add(c)\n        }\n    }\n    return rootTreemap\n}\n\nclass TreemapLayout<D> {\n\n    private val constantZero: (TreemapNode<D>) -> Double = { .0 }\n\n    var tilingMethod: (ParentValued<TreemapNode<D>>, Double, Double, Double, Double) -> Any = {\n            parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double -> treemapSquarify(parent, x0, y0, x1, y1)\n    }\n    var round = false\n    var width = 1.0\n    var height = 1.0\n\n    private var paddingStack = mutableListOf(.0)\n    var paddingInner: (TreemapNode<D>) -> Double = constantZero\n    var paddingTop: (TreemapNode<D>) -> Double = constantZero\n    var paddingRight: (TreemapNode<D>) -> Double = constantZero\n    var paddingBottom: (TreemapNode<D>) -> Double = constantZero\n    var paddingLeft: (TreemapNode<D>) -> Double = constantZero\n    var paddingOuter: (TreemapNode<D>) -> Double = constantZero\n        set(value) {\n            paddingTop = value\n            paddingRight = value\n            paddingBottom = value\n            paddingLeft = value\n        }\n\n    /**\n     * Introduced by Ben Shneiderman in 1991, a treemap recursively subdivides area into rectangles according to\n     * each node\u2019s associated value.\n     * Treemap implementation supports an extensible tiling method: the default squarified method seeks to generate\n     * rectangles with a golden aspect ratio; this offers better readability and size estimation than slice-and-dice,\n     * which simply alternates between horizontal and vertical subdivision by depth.\n     *\n     * Lays out the specified root hierarchy, assigning the following properties on root and its descendants:\n     *\n     * - node.x0 - the left edge of the rectangle\n     * - node.y0 - the top edge of the rectangle\n     * - node.x1 - the right edge of the rectangle\n     * - node.y1 - the bottom edge of the rectangle\n     *\n     * You must call root.sum before passing the hierarchy to the treemap layout so each node as a positive value.\n     * // TODO force a call on root.sum ?\n     * You probably also want to call root.sort to order the hierarchy before computing the layout.\n     */\n    fun treemap(root: Node<D>): TreemapNode<D> {\n\n        // TODO : require a check on each node to verify that value != null and >0 ? (root.sum has been passed) ?\n\n        val rootTreemap = makeTreemap(root)\n\n        paddingStack = MutableList(root.height + 1, { .0 })\n        rootTreemap.x0 = .0\n        rootTreemap.y0 = .0\n        rootTreemap.x1 = width\n        rootTreemap.y1 = height\n\n        rootTreemap.eachBefore(this::positionNode)\n        paddingStack = mutableListOf(.0)\n\n        if (round) rootTreemap.eachBefore(::roundNode)\n\n        return rootTreemap\n    }\n\n    private fun positionNode(node: TreemapNode<D>) {\n        var p = paddingStack[node.depth]\n        var x0 = node.x0 + p\n        var y0 = node.y0 + p\n        var x1 = node.x1 - p\n        var y1 = node.y1 - p\n\n        if (x1 < x0) {\n            val mid = (x0 + x1) / 2\n            x0 = mid\n            x1 = mid\n        }\n        if (y1 < y0) {\n            val mid = (y0 + y1) / 2\n            y0 = mid\n            y1 = mid\n        }\n        node.x0 = x0\n        node.y0 = y0\n        node.x1 = x1\n        node.y1 = y1\n\n        if (node.children.isNotEmpty()) {\n            paddingStack[node.depth + 1] = paddingInner(node) / 2\n            p = paddingInner(node) / 2\n            x0 += paddingLeft(node) - p\n            y0 += paddingTop(node) - p\n            x1 -= paddingRight(node) - p\n            y1 -= paddingBottom(node) - p\n            if (x1 < x0) {\n                val mid = (x0 + x1) / 2\n                x0 = mid\n                x1 = mid\n            }\n            if (y1 < y0) {\n                val mid = (y0 + y1) / 2\n                y0 = mid\n                y1 = mid\n            }\n            tilingMethod(node, x0, y0, x1, y1)\n        }\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","package io.data2viz.hierarchy.pack\n\nimport io.data2viz.hierarchy.CircleValues\nimport io.data2viz.hierarchy.PackNode\nimport kotlin.math.sqrt\n\nprivate data class Circle(\n    override var x: Double = .0,\n    override var y: Double = .0,\n    override var r: Double = .0\n) : CircleValues\n\n/**\n * Computes the smallest circle that encloses the specified array of circles, each of which must have a circle.r\n * property specifying the circle\u2019s radius, and circle.x and circle.y properties specifying the circle\u2019s center.\n * The enclosing circle is computed using the Matou\u0161ek-Sharir-Welzl algorithm.\n */\nfun enclose(circles: List<CircleValues>): CircleValues? {\n    var i = 0\n    val shuffledCircles = circles.shuffled()\n    val n = shuffledCircles.size\n    var B = listOf<CircleValues>()\n    var e: CircleValues? = null\n\n    while (i < n) {\n        val p = shuffledCircles[i]\n        if (e != null && enclosesWeak(e, p)) i++\n        else {\n            B = extendBasis(B, p)\n            e = encloseBasis(B)\n            i = 0\n        }\n    }\n    return e\n}\n\nprivate fun enclosesWeak(a: CircleValues, b: CircleValues): Boolean {\n    val dr = a.r - b.r + epsilon\n    val dx = b.x - a.x\n    val dy = b.y - a.y\n    return (dr > 0) && ((dr * dr) > ((dx * dx) + (dy * dy)))\n}\n\nprivate fun enclosesWeakAll(a: CircleValues, B: List<CircleValues>): Boolean {\n    for (i in 0 until B.size) {\n        if (!enclosesWeak(a, B[i])) {\n            return false\n        }\n    }\n    return true\n}\n\nprivate fun enclosesNot(a: CircleValues, b: CircleValues): Boolean {\n    val dr = a.r - b.r\n    val dx = b.x - a.x\n    val dy = b.y - a.y\n    return (dr < 0) || ((dr * dr) < ((dx * dx) + (dy * dy)))\n}\n\nprivate fun encloseBasis(B:List<CircleValues>): CircleValues {\n    when (B.size) {\n        1 -> return encloseBasis1(B[0])\n        2 -> return encloseBasis2(B[0], B[1])\n        else -> return encloseBasis3(B[0], B[1], B[2])\n    }\n}\n\nprivate fun encloseBasis1(a: CircleValues) = Circle(a.x, a.y, a.r)\n\nprivate fun encloseBasis2(a: CircleValues, b: CircleValues): CircleValues {\n    val x1 = a.x\n    val y1 = a.y\n    val r1 = a.r\n    val x2 = b.x\n    val y2 = b.y\n    val r2 = b.r\n    val x21 = x2 - x1\n    val y21 = y2 - y1\n    val r21 = r2 - r1\n    val l = sqrt(x21 * x21 + y21 * y21)\n    return Circle((x1 + x2 + x21 / l * r21) / 2, (y1 + y2 + y21 / l * r21) / 2, (l + r1 + r2) / 2)\n}\n\nprivate fun encloseBasis3(a: CircleValues, b: CircleValues, c: CircleValues): CircleValues {\n    val x1 = a.x\n    val y1 = a.y\n    val r1 = a.r\n    val x2 = b.x\n    val y2 = b.y\n    val r2 = b.r\n    val x3 = c.x\n    val y3 = c.y\n    val r3 = c.r\n    val a2 = x1 - x2\n    val a3 = x1 - x3\n    val b2 = y1 - y2\n    val b3 = y1 - y3\n    val c2 = r2 - r1\n    val c3 = r3 - r1\n    val d1 = x1 * x1 + y1 * y1 - r1 * r1\n    val d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2\n    val d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3\n    val ab = a3 * b2 - a2 * b3\n    val xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1\n    val xb = (b3 * c2 - b2 * c3) / ab\n    val ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1\n    val yb = (a2 * c3 - a3 * c2) / ab\n    val A = xb * xb + yb * yb - 1\n    val B = 2 * (r1 + xa * xb + ya * yb)\n    val C = xa * xa + ya * ya - r1 * r1\n    val r = -(if (A != .0) (B + sqrt(B * B - 4 * A * C)) / (2 * A) else C / B)\n    return Circle(x1 + xa + xb * r, y1 + ya + yb * r, r)\n}\n\nprivate fun extendBasis(B: List<CircleValues>, p: CircleValues): List<CircleValues> {\n    if (enclosesWeakAll(p, B)) return listOf(p)\n\n    // If we get here then B must have at least one element.\n    for (i in 0 until B.size) {\n        if (enclosesNot(p, B[i])\n            && enclosesWeakAll(encloseBasis2(B[i], p), B)\n        ) {\n            return listOf(B[i], p)\n        }\n    }\n\n    // If we get here then B must have at least two elements.\n    for (i in 0 until B.size - 1) {\n        for (j in (i + 1) until B.size) {\n            if (enclosesNot(encloseBasis2(B[i], B[j]), p)\n                && enclosesNot(encloseBasis2(B[i], p), B[j])\n                && enclosesNot(encloseBasis2(B[j], p), B[i])\n                && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)\n            ) {\n                return listOf(B[i], B[j], p)\n            }\n        }\n    }\n\n    // If we get here then something is very wrong.\n    throw RuntimeException(\"Unable to compute enclosing circle for PackLayout.\")\n}\n","package io.data2viz.hierarchy.pack\n\nimport io.data2viz.hierarchy.CircleValues\nimport kotlin.math.max\nimport kotlin.math.sqrt\nimport io.data2viz.hierarchy.PackNode\nimport io.data2viz.hierarchy.packNode\n\nval epsilon = 1e-6\n\nfun <D> packEnclose(circles:List<PackNode<D>>):Double {\n    if (circles.isEmpty()) return .0\n\n    val n = circles.size\n\n    // Place the first circle.\n    var a = circles.first()\n    a.x = .0\n    a.y = .0\n    if (n < 2) return a.r\n\n    // Place the second circle.\n    var b = circles[1]\n    a.x = -b.r\n    b.x = a.r\n    b.y = .0\n    if (n < 3) return a.r + b.r\n\n    // Place the third circle.\n    var c = circles[2]\n    place(b, a, c)\n\n    // Initialize the front-chain using the first three circles a, b and c.\n    a = packNode(a)\n    b = packNode(b)\n    c = packNode(c)\n    a.next = b\n    c.previous = b\n    b.next = c\n    a.previous = c\n    c.next = a\n    b.previous = a\n\n    // Attempt to place each remaining circle\u2026\n    var i = 3\n    pack@ while (i < n) {\n        c = circles[i]\n        i++\n        place(a, b, c)\n\n        // Find the closest intersecting circle on the front-chain, if any.\n        // \u201cCloseness\u201d is determined by linear distance along the front-chain.\n        // \u201cAhead\u201d or \u201cbehind\u201d is likewise determined by linear distance.\n        var j = b.next!!\n        var k = a.previous!!\n        var sj = b.r\n        var sk = a.r\n        do {\n            if (sj <= sk) {\n                if (intersects(j, c)) {\n                    b = j\n                    a.next = b\n                    b.previous = a\n                    i--\n                    continue@pack\n                }\n                sj += j.r\n                j = j.next!!\n            } else {\n                if (intersects(k, c)) {\n                    a = k\n                    a.next = b\n                    b.previous = a\n                    i--\n                    continue@pack\n                }\n                sk += k.r\n                k = k.previous!!\n            }\n        } while (j !== k.next)\n\n        // Success! Insert the new circle c between a and b.\n        c.previous = a\n        c.next = b\n        b = c\n        b.previous = c\n        a.next = c\n\n        // Compute the new closest circle pair to the centroid.\n        var aa = score(a)\n        c = c.next!!\n        while (c !== b) {\n            val ca = score(c)\n            if (ca < aa) {\n                a = c\n                aa = ca\n            }\n            c = c.next!!\n        }\n        b = a.next!!\n    }\n\n    // Compute the enclosing circle of the front chain.\n    val chain = mutableListOf(b)\n    c = b\n    c = c.next!!\n    while (c != b) {\n        chain.add(c)\n        c = c.next!!\n    }\n    val circle = enclose(chain)!!\n\n    // Translate the circles to put the enclosing circle around the origin.\n    (0 until n).forEach {\n        a = circles[it]\n        a.x -= circle.x\n        a.y -= circle.y\n    }\n\n    return circle.r\n}\n\nprivate fun <D> score(node: PackNode<D>): Double {\n    val a = node\n    val b = node.next!!\n    val ab = a.r + b.r\n    val dx = (a.x * b.r + b.x * a.r) / ab\n    val dy = (a.y * b.r + b.y * a.r) / ab\n    return dx * dx + dy * dy\n}\n\nprivate fun intersects(a: CircleValues, b: CircleValues): Boolean {\n    val dx = b.x - a.x\n    val dy = b.y - a.y\n    val dr = a.r + b.r\n    return dr * dr - epsilon > dx * dx + dy * dy;\n}\n\nprivate fun place(a:CircleValues, b:CircleValues, c:CircleValues) {\n    val ax = a.x\n    val ay = a.y\n    var da = b.r + c.r\n    var db = a.r + c.r\n    val dx = b.x - ax\n    val dy = b.y - ay\n    val dc = (dx * dx) + (dy * dy)\n    if (dc != .0) {\n        db *= db\n        da *= da\n        val x = 0.5 + (db - da) / (2 * dc)\n        val temp1: Double = 2.0 * da * (db + dc)\n        db -= dc\n        val y = sqrt(max(.0, temp1 - db * db - da * da)) / (2 * dc)\n        c.x = ax + x * dx + y * dy\n        c.y = ay + x * dy - y * dx\n    } else {\n        c.x = ax + db\n        c.y = ay\n    }\n}","package io.data2viz.hierarchy.treemap\n\nimport io.data2viz.hierarchy.ParentValued\nimport io.data2viz.hierarchy.TreemapNode\n\nfun <D> treemapBinary(parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) = TreemapBinary<D>().binary(parent, x0, y0, x1, y1)\n\n/**\n * Recursively partitions the specified nodes into an approximately-balanced binary tree, choosing horizontal\n * partitioning for wide rectangles and vertical partitioning for tall rectangles.\n */\nclass TreemapBinary<D> {\n\n    var nodes: MutableList<ParentValued<TreemapNode<D>>> = mutableListOf()\n    var sums: MutableList<Double> = mutableListOf()\n\n    fun binary(parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n\n        nodes = parent.children.toMutableList()\n        val size = nodes.size\n        sums = MutableList(size + 1, { .0 })\n        var sum = .0\n\n        for (i in 0 until size) {\n            sum += nodes[i].value!!\n            sums[i + 1] = sum\n        }\n\n        partition(0, size, parent.value!!, x0, y0, x1, y1)\n    }\n\n    private fun partition(i: Int, j: Int, value: Double, x0: Double, y0: Double, x1: Double, y1: Double) {\n        if (i >= j - 1) {\n            val node = nodes[i] as TreemapNode\n            node.x0 = x0\n            node.y0 = y0\n            node.x1 = x1\n            node.y1 = y1\n            return\n        }\n\n        val valueOffset = sums[i]\n        val valueTarget = (value / 2) + valueOffset\n        var k = i + 1\n        var hi = j - 1\n\n        while (k < hi) {\n            val mid = (k + hi).ushr(1)     // TODO raw conversion from JS : k + hi >>> 1... need explanation (unsigned right shift .... WHY ?)\n            if (sums[mid] < valueTarget) k = mid + 1\n            else hi = mid\n        }\n\n        if ((valueTarget - sums[k - 1]) < (sums[k] - valueTarget) && i + 1 < k) --k\n\n        val valueLeft = sums[k] - valueOffset\n        val valueRight = value - valueLeft\n\n        if ((x1 - x0) > (y1 - y0)) {\n            val xk = (x0 * valueRight + x1 * valueLeft) / value\n            partition(i, k, valueLeft, x0, y0, xk, y1)\n            partition(k, j, valueRight, xk, y0, x1, y1)\n        } else {\n            val yk = (y0 * valueRight + y1 * valueLeft) / value\n            partition(i, k, valueLeft, x0, y0, x1, yk)\n            partition(k, j, valueRight, x0, yk, x1, y1)\n        }\n    }\n}","package io.data2viz.hierarchy.treemap\n\nimport io.data2viz.hierarchy.TreemapNode\n\n/**\n * Like treemapSquarify, except preserves the topology (node adjacencies) of the previous layout computed by\n * treemapResquarify, if there is one and it used the same target aspect ratio.\n * This tiling method is good for animating changes to treemaps because it only changes node sizes and\n * not their relative positions, thus avoiding distracting shuffling and occlusion.\n * The downside of a stable update, however, is a suboptimal layout for subsequent updates: only the first layout\n * uses the Bruls et al. squarified algorithm.\n */\n// TODO\nfun treemapResquarify(parent: TreemapNode<*>, x0:Double, y0:Double, x1:Double, y1:Double) {\n    /*if ((rows = parent._squarify) && (rows.ratio === ratio)) {\n        var rows,\n        row,\n        nodes,\n        i,\n        j = -1,\n        n,\n        m = rows.length,\n        value = parent.value;\n\n        while (++j < m) {\n            row = rows[j], nodes = row.children;\n            for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;\n            if (row.dice) treemapDice(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);\n            else treemapSlice(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);\n            value -= row.value;\n        }\n    } else {\n        parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);\n        rows.ratio = ratio;\n    }*/\n}","package io.data2viz.hierarchy.treemap\n\nimport io.data2viz.hierarchy.ParentValued\nimport io.data2viz.hierarchy.TreemapNode\n\n/**\n * Divides the rectangular area specified by x0, y0, x1, y1 vertically according the value of each\n * of the specified node\u2019s children.\n * The children are positioned in order, starting with the top edge (y0) of the given rectangle.\n * If the sum of the children\u2019s values is less than the specified node\u2019s value (i.e., if the specified node\n * has a non-zero internal value), the remaining empty space will be positioned\n * on the bottom edge (y1) of the given rectangle.\n */\nfun <D> treemapSlice(parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n    var newY = y0\n    val nodes = parent.children\n    var i = 0\n    val n = nodes.size\n    val k = if (parent.value != null && parent.value != .0) (y1 - newY) / parent.value!! else .0\n\n    while (i < n) {\n        val node = nodes[i] as TreemapNode<*>\n\n        node.x0 = x0\n        node.x1 = x1\n        node.y0 = newY\n        newY += k * node.value!!\n        node.y1 = newY\n        i++\n    }\n}\n\n/**\n * Divides the rectangular area specified by x0, y0, x1, y1 horizontally according the value of each\n * of the specified node\u2019s children. The children are positioned in order, starting with the left edge (x0)\n * of the given rectangle.\n * If the sum of the children\u2019s values is less than the specified node\u2019s value (i.e., if the specified node\n * has a non-zero internal value), the remaining empty space will be positioned\n * on the right edge (x1) of the given rectangle.\n */\nfun <D> treemapDice(parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n    var newX = x0\n    val nodes = parent.children\n    var i = 0\n    val n = nodes.size\n    val k = if (parent.value != null && parent.value != .0) (x1 - newX) / parent.value!! else .0\n\n    while (i < n) {\n        val node = nodes[i] as TreemapNode<*>\n\n        node.y0 = y0\n        node.y1 = y1\n        node.x0 = newX\n        newX += k * node.value!!\n        node.x1 = newX\n        i++\n    }\n}\n\n/**\n * If the specified node has odd depth, delegates to treemapSlice; otherwise delegates to treemapDice.\n */\nfun <D> treemapSliceDice(parent: ParentValued<TreemapNode<D>>, x0: Double, y0: Double, x1: Double, y1: Double) {\n    if ((parent as TreemapNode<D>).depth % 2 == 1) treemapSlice(parent, x0, y0, x1, y1) else treemapDice(parent, x0, y0, x1, y1)\n}","package io.data2viz.hierarchy.treemap\n\nimport io.data2viz.hierarchy.ParentValued\nimport io.data2viz.hierarchy.Row\nimport io.data2viz.hierarchy.TreemapNode\nimport kotlin.math.max\nimport kotlin.math.sqrt\n\nval phi = (1 + sqrt(5.0)) / 2\n\n/**\n * Implements the squarified treemap algorithm by Bruls et al., which seeks to produce rectangles\n * of a given aspect ratio.\n */\nfun <D> treemapSquarify(parent: ParentValued<TreemapNode<D>>, x0:Double, y0:Double, x1:Double, y1:Double): List<Row<D>> {\n    return squarifyRatio(phi, parent as TreemapNode<D>, x0, y0, x1, y1)\n}\n\nprivate fun <D> squarifyRatio(ratio: Double, parent: TreemapNode<D>, x0: Double, y0: Double, x1: Double, y1: Double): List<Row<D>> {\n\n    val rows = mutableListOf<Row<D>>()\n    val nodes = parent.children\n\n    var newx = x0\n    var newY = y0\n    var i0 = 0\n    var i1 = 0\n    val size = nodes.size\n    var dx: Double\n    var dy: Double\n    var value = parent.value!!          // should have been checked that root.sum() has been called and values are not null\n    var sumValue:Double\n\n    while (i0 < size) {\n        dx = x1 - newx\n        dy = y1 - newY\n\n        // Find the next non-empty node.\n        do sumValue = nodes[i1++].value!! while (sumValue == .0 && i1 < size)\n\n        var minValue = sumValue\n        var maxValue = sumValue\n        val alpha = max(dy / dx, dx / dy) / (value * ratio)\n\n        var beta = sumValue * sumValue * alpha;\n        var minRatio = max(maxValue / beta, beta / minValue);\n\n        // Keep adding nodes while the aspect ratio maintains or improves.\n        while(i1 < size) {\n            val nodeValue = nodes[i1].value!!\n            sumValue += nodeValue\n            if (nodeValue < minValue) minValue = nodeValue\n            if (nodeValue > maxValue) maxValue = nodeValue\n            beta = sumValue * sumValue * alpha\n            val newRatio = max(maxValue / beta, beta / minValue)\n            if (newRatio > minRatio) {\n                sumValue -= nodeValue\n                break\n            }\n            minRatio = newRatio\n            i1++\n        }\n\n        // Position and record the row orientation.\n        val row = Row(sumValue, dx < dy, nodes.slice(i0 until i1))\n        rows.add(row)\n        if (row.dice) {\n            if (value != .0) {\n                val temp = newY + dy * sumValue / value\n                treemapDice(row, newx, newY, x1, temp)\n                newY = temp\n            } else treemapDice(row, newx, newY, x1, y1)\n        } else {\n            if (value != .0) {\n                val temp = newx + dx * sumValue / value\n                treemapSlice(row, newx, newY, temp, y1)\n                newx = temp\n            } else treemapSlice(row, newx, newY, x1, y1)\n        }\n        value -= sumValue\n        i0 = i1\n    }\n\n    return rows.toList()\n}\n\n/**\n * Specifies the desired aspect ratio of the generated rectangles. The ratio must be specified as a number greater\n * than or equal to one.\n * Note that the orientation of the generated rectangles (tall or wide) is not implied by the ratio;\n * for example, a ratio of two will attempt to produce a mixture of rectangles whose width:height ratio\n * is either 2:1 or 1:2. (However, you can approximately achieve this result by generating a square treemap\n * at different dimensions, and then stretching the treemap to the desired aspect ratio.)\n * Furthermore, the specified ratio is merely a hint to the tiling algorithm; the rectangles are not guaranteed\n * to have the specified aspect ratio.\n * If not specified, the aspect ratio defaults to the golden ratio, \u03c6 = (1 + sqrt(5)) / 2, per Kong et al.\n */\n/*treemapSquarify.ratio = function(x) {\n    return custom((x = +x) > 1 ? x : 1);\n}*/"],"names":[],"mappings":"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I0C4B,CAAV,YAAU,IAAV,E;INuId,YAAY,eMvIR,SNuIQ,E;IACZ,WFxFoD,gB;IEyFpD,OFXwD,CEWjD,KFXkD,UEWzD,C;MACI,WAAW,KAAM,kBAAe,cAAN,KAAM,CAAf,C;MACjB,IAAK,WAAI,IAAJ,C;MACL,eAAe,IAAK,S;MACpB,IFfoD,CEehD,QFfiD,UEerD,C;QCg2CY,U;QAAA,SD/1CR,QC+1CQ,W;QAAhB,OAAgB,gBAAhB,C;UAAgB,2B;UD91CM,U;UAAJ,gBAAI,uBC81CO,OD91CP,iCAAJ,C;;;;IC81CF,U;IAAA,SD11CX,SAAL,IAAK,CC01CW,W;IAAhB,OAAgB,gBAAhB,C;MAAgB,6B;MD11CQ,QC01CF,CAAO,SAAP,C;;IK5+ClB,cAAA,SAAU,OAAV,cAAuB,CAAC,SAAU,U;IACxB,sE;aJ5ClB,yB;II4C6B,CAAX,YAAW,IAAX,E;INiHd,cAAY,eMjHR,SNiHQ,E;IACZ,OFUwD,CEVjD,OFUkD,UEVzD,C;MACI,aAAW,OAAM,kBAAe,cAAN,OAAM,CAAf,C;MACjB,WAAS,MAAT,C;MACA,iBAAe,MAAK,S;MACpB,IFMoD,CENhD,UFMiD,UENrD,C;QCq3CY,U;QAAA,SDp3CP,OAAS,cAAT,UAAS,CAAT,EAA0B,CAA1B,CCo3CO,W;QAAhB,OAAgB,gBAAhB,C;UAAgB,6B;UDn3CM,U;UAAJ,kBAAI,8CCm3CO,SDn3CP,kCAAJ,C;;;;IMrHd,IAAI,eAAJ,C;MAAwB,uE;eJ/ChC,0B;MI+C2C,CAAX,YAAW,IAAX,E;MN8G5B,cAAY,eM9GM,SN8GN,E;MACZ,OFUwD,CEVjD,OFUkD,UEVzD,C;QACI,aAAW,OAAM,kBAAe,cAAN,OAAM,CAAf,C;QACjB,WAAS,MAAT,C;QACA,iBAAe,MAAK,S;QACpB,IFMoD,CENhD,UFMiD,UENrD,C;UCq3CY,U;UAAA,SDp3CP,OAAS,cAAT,UAAS,CAAT,EAA0B,CAA1B,CCo3CO,W;UAAhB,OAAgB,gBAAhB,C;YAAgB,6B;YDn3CM,U;YAAJ,kBAAI,8CCm3CO,SDn3CP,kCAAJ,C;;;;;;MMhHV,eAAW,SAAX,C;MACA,gBAAY,SAAZ,C;MACA,iB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"}